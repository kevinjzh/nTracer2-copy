{"version":3,"file":"162.f2e5bd83130a3d69.js","sources":["webpack://neuroglancer/./src/kvstore/auto_detect.ts","webpack://neuroglancer/./src/kvstore/byte_range/file_handle.ts","webpack://neuroglancer/./src/kvstore/http/read.ts","webpack://neuroglancer/./src/kvstore/index.ts","webpack://neuroglancer/./src/kvstore/ocdbt/version_specifier.ts","webpack://neuroglancer/./src/kvstore/s3/list.ts","webpack://neuroglancer/./src/kvstore/url.ts","webpack://neuroglancer/./src/segmentation_graph/segment_id.ts","webpack://neuroglancer/./src/trackable_value.ts","webpack://neuroglancer/./src/util/abort.ts","webpack://neuroglancer/./src/util/bigint.ts","webpack://neuroglancer/./src/util/disposable.ts","webpack://neuroglancer/./src/util/geom.ts","webpack://neuroglancer/./src/util/gzip.ts","webpack://neuroglancer/./src/util/json.ts","webpack://neuroglancer/./src/util/matrix.ts","webpack://neuroglancer/./src/util/progress_listener.ts","webpack://neuroglancer/./src/util/random.ts","webpack://neuroglancer/./src/util/signal.ts","webpack://neuroglancer/./src/mesh/draco/index.ts","webpack://neuroglancer/./src/chunk_manager/base.ts","webpack://neuroglancer/./src/navigation_state.ts","webpack://neuroglancer/./src/util/data_type.ts","webpack://neuroglancer/./src/util/endian.ts","webpack://neuroglancer/./src/annotation/index.ts","webpack://neuroglancer/./src/datasource/nifti/backend.ts","webpack://neuroglancer/./src/single_mesh/backend.ts","webpack://neuroglancer/./src/datasource/zarr/codec/sharding_indexed/resolve.ts","webpack://neuroglancer/./src/datasource/zarr/codec/resolve.ts","webpack://neuroglancer/./src/kvstore/ocdbt/decode_utils.ts","webpack://neuroglancer/./src/kvstore/zip/metadata.ts","webpack://neuroglancer/./src/worker_rpc.ts","webpack://neuroglancer/./src/shared_watchable_value.ts","webpack://neuroglancer/./src/util/pairing_heap.ts","webpack://neuroglancer/./src/chunk_manager/backend.ts","webpack://neuroglancer/./src/credentials_provider/index.ts","webpack://neuroglancer/./src/credentials_provider/shared_counterpart.ts","webpack://neuroglancer/./src/kvstore/backend.ts","webpack://neuroglancer/./src/render_layer_backend.ts","webpack://neuroglancer/./src/util/array.ts","webpack://neuroglancer/./src/util/si_units.ts","webpack://neuroglancer/./src/util/vector.ts","webpack://neuroglancer/./src/coordinate_transform.ts","webpack://neuroglancer/./src/util/trackable.ts","webpack://neuroglancer/./src/display_context.ts","webpack://neuroglancer/./src/render_coordinate_transform.ts","webpack://neuroglancer/./src/sliceview/base.ts","webpack://neuroglancer/./src/util/velocity_estimation.ts","webpack://neuroglancer/./src/visibility_priority/backend.ts","webpack://neuroglancer/./src/sliceview/backend.ts","webpack://neuroglancer/./src/util/erf.ts","webpack://neuroglancer/./src/perspective_view/backend.ts","webpack://neuroglancer/./src/volume_rendering/base.ts","webpack://neuroglancer/./src/volume_rendering/backend.ts","webpack://neuroglancer/./src/annotation/base.ts","webpack://neuroglancer/./src/shared_disjoint_sets.ts","webpack://neuroglancer/./src/gpu_hash/hash_table.ts","webpack://neuroglancer/./src/uint64_map.ts","webpack://neuroglancer/./src/uint64_set.ts","webpack://neuroglancer/./src/segmentation_display_state/base.ts","webpack://neuroglancer/./src/segmentation_display_state/backend.ts","webpack://neuroglancer/./src/annotation/backend.ts","webpack://neuroglancer/./src/datasource/boss/api.ts","webpack://neuroglancer/./src/util/zorder.ts","webpack://neuroglancer/./src/mesh/backend.ts","webpack://neuroglancer/./src/mesh/multiscale.ts","webpack://neuroglancer/./src/async_computation/encode_compressed_segmentation_request.ts","webpack://neuroglancer/./src/async_computation/index.ts","webpack://neuroglancer/./src/async_computation/request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/postprocess.ts","webpack://neuroglancer/./src/util/numpy_dtype.ts","webpack://neuroglancer/./src/util/npy.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/bossNpz.ts","webpack://neuroglancer/./src/async_computation/decode_jpeg_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/jpeg.ts","webpack://neuroglancer/./src/sliceview/volume/backend.ts","webpack://neuroglancer/./src/datasource/boss/backend.ts","webpack://neuroglancer/./src/util/color.ts","webpack://neuroglancer/./src/util/hex.ts","webpack://neuroglancer/./src/util/float.ts","webpack://neuroglancer/./src/util/lerp.ts","webpack://neuroglancer/./src/datasource/brainmaps/api.ts","webpack://neuroglancer/./src/skeleton/backend.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/compressed_segmentation.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/raw.ts","webpack://neuroglancer/./src/datasource/brainmaps/backend.ts","webpack://neuroglancer/./src/async_computation/decode_png_request.ts","webpack://neuroglancer/./src/datasource/deepzoom/backend.ts","webpack://neuroglancer/./src/datasource/dvid/api.ts","webpack://neuroglancer/./src/skeleton/decode_swc_skeleton.ts","webpack://neuroglancer/./src/datasource/dvid/backend.ts","webpack://neuroglancer/./src/datasource/graphene/base.ts","webpack://neuroglancer/./src/util/object_id.ts","webpack://neuroglancer/./src/chunk_manager/generic_file_source.ts","webpack://neuroglancer/./src/util/hash.ts","webpack://neuroglancer/./src/datasource/precomputed/sharded.ts","webpack://neuroglancer/./src/async_computation/decode_compresso_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/compresso.ts","webpack://neuroglancer/./src/async_computation/decode_jxl_request.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/jxl.ts","webpack://neuroglancer/./src/sliceview/backend_chunk_decoders/png.ts","webpack://neuroglancer/./src/datasource/precomputed/backend.ts","webpack://neuroglancer/./src/skeleton/decode_precomputed_skeleton.ts","webpack://neuroglancer/./src/datasource/graphene/backend.ts","webpack://neuroglancer/./src/async_computation/decode_blosc_request.ts","webpack://neuroglancer/./src/async_computation/decode_zstd_request.ts","webpack://neuroglancer/./src/datasource/n5/backend.ts","webpack://neuroglancer/./src/async_computation/obj_mesh_request.ts","webpack://neuroglancer/./src/datasource/obj/backend.ts","webpack://neuroglancer/./src/datasource/render/backend.ts","webpack://neuroglancer/./src/async_computation/vtk_mesh_request.ts","webpack://neuroglancer/./src/datasource/vtk/backend.ts","webpack://neuroglancer/./src/datasource/zarr/codec/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/blosc/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/zstd/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/bytes/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/crc32c/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/gzip/decode.ts","webpack://neuroglancer/./src/datasource/zarr/metadata/parse_util.ts","webpack://neuroglancer/./src/datasource/zarr/metadata/parse.ts","webpack://neuroglancer/./src/datasource/zarr/codec/sharding_indexed/decode.ts","webpack://neuroglancer/./src/datasource/zarr/codec/transpose/decode.ts","webpack://neuroglancer/./src/datasource/zarr/backend.ts","webpack://neuroglancer/./src/kvstore/proxy.ts","webpack://neuroglancer/./src/kvstore/http/backend.ts","webpack://neuroglancer/./src/kvstore/http/register_backend.ts","webpack://neuroglancer/./src/kvstore/icechunk/crockford_base32.ts","webpack://neuroglancer/./src/kvstore/icechunk/decode_utils.ts","webpack://neuroglancer/./src/kvstore/icechunk/manifest.ts","webpack://neuroglancer/./src/kvstore/icechunk/ref.ts","webpack://neuroglancer/./src/kvstore/icechunk/snapshot.ts","webpack://neuroglancer/./src/kvstore/icechunk/metadata_cache.ts","webpack://neuroglancer/./src/kvstore/icechunk/read.ts","webpack://neuroglancer/./src/kvstore/icechunk/url.ts","webpack://neuroglancer/./src/kvstore/icechunk/backend.ts","webpack://neuroglancer/./src/kvstore/icechunk/list.ts","webpack://neuroglancer/./src/kvstore/icechunk/complete_url.ts","webpack://neuroglancer/./src/kvstore/icechunk/register_backend.ts","webpack://neuroglancer/./src/kvstore/middleauth/register_backend.ts","webpack://neuroglancer/./src/util/leb128.ts","webpack://neuroglancer/./src/kvstore/ocdbt/key.ts","webpack://neuroglancer/./src/kvstore/ocdbt/indirect_data_reference.ts","webpack://neuroglancer/./src/kvstore/ocdbt/btree.ts","webpack://neuroglancer/./src/kvstore/ocdbt/version_tree.ts","webpack://neuroglancer/./src/kvstore/ocdbt/manifest.ts","webpack://neuroglancer/./src/kvstore/ocdbt/metadata_cache.ts","webpack://neuroglancer/./src/kvstore/ocdbt/list.ts","webpack://neuroglancer/./src/kvstore/ocdbt/read.ts","webpack://neuroglancer/./src/kvstore/ocdbt/read_version.ts","webpack://neuroglancer/./src/kvstore/ocdbt/backend.ts","webpack://neuroglancer/./src/kvstore/ocdbt/list_versions.ts","webpack://neuroglancer/./src/kvstore/ocdbt/complete_url.ts","webpack://neuroglancer/./src/kvstore/ocdbt/register_backend.ts","webpack://neuroglancer/./src/kvstore/s3/backend.ts","webpack://neuroglancer/./src/kvstore/s3/register_backend.ts","webpack://neuroglancer/./src/kvstore/zip/backend.ts","webpack://neuroglancer/./src/kvstore/zip/register_backend.ts","webpack://neuroglancer/./src/worker_rpc_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { KvStoreContext } from \"#src/kvstore/context.js\";\nimport { readKvStore } from \"#src/kvstore/index.js\";\nimport { pathIsDirectory } from \"#src/kvstore/url.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport { ProgressSpan } from \"#src/util/progress_listener.js\";\n\nexport interface AutoDetectDirectoryOptions {\n  url: string;\n  fileNames: Set<string>;\n  subDirectories: Set<string>;\n  signal?: AbortSignal;\n}\n\nexport interface AutoDetectMatch {\n  suffix: string;\n  description: string;\n}\n\nexport interface AutoDetectDirectorySpec {\n  fileNames?: Set<string>;\n  subDirectories?: Set<string>;\n  match: (options: AutoDetectDirectoryOptions) => Promise<AutoDetectMatch[]>;\n}\n\nexport function simpleFilePresenceAutoDetectDirectorySpec(\n  fileNames: Set<string>,\n  match: AutoDetectMatch,\n): AutoDetectDirectorySpec {\n  return {\n    fileNames,\n    match: async (options) => {\n      const detectedFileNames = options.fileNames;\n      for (const fileName of fileNames) {\n        if (detectedFileNames.has(fileName)) {\n          return [match];\n        }\n      }\n      return [];\n    },\n  };\n}\n\nexport interface AutoDetectFileOptions {\n  url: string;\n  prefix: Uint8Array<ArrayBuffer>;\n  suffix?: Uint8Array<ArrayBuffer>;\n  totalSize: number | undefined;\n  signal?: AbortSignal;\n}\n\nexport interface AutoDetectFileSpec {\n  prefixLength: number;\n  suffixLength: number;\n  match: (options: AutoDetectFileOptions) => Promise<AutoDetectMatch[]>;\n}\n\nfunction composeMatchFunctions<Options>(\n  specs: {\n    match: (options: Options) => Promise<AutoDetectMatch[]>;\n  }[],\n): (options: Options) => Promise<AutoDetectMatch[]> {\n  return async (options: Options) => {\n    const matches: AutoDetectMatch[] = [];\n    const results = await Promise.allSettled(\n      specs.map((spec) => spec.match(options)),\n    );\n    for (const result of results) {\n      if (result.status !== \"fulfilled\") continue;\n      matches.push(...result.value);\n    }\n    return matches;\n  };\n}\n\nexport function composeAutoDetectDirectorySpecs(\n  specs: AutoDetectDirectorySpec[],\n): AutoDetectDirectorySpec {\n  const fileNames = new Set<string>();\n  const subDirectories = new Set<string>();\n  for (const spec of specs) {\n    const { fileNames: curFileNames, subDirectories: curSubDirectories } = spec;\n    if (curFileNames !== undefined) {\n      for (const fileName of curFileNames) {\n        fileNames.add(fileName);\n      }\n    }\n    if (curSubDirectories !== undefined) {\n      for (const subDirectory of curSubDirectories) {\n        subDirectories.add(subDirectory);\n      }\n    }\n  }\n  return { fileNames, subDirectories, match: composeMatchFunctions(specs) };\n}\n\nexport function composeAutoDetectFileSpecs(\n  specs: AutoDetectFileSpec[],\n): AutoDetectFileSpec {\n  let prefixLength = 0;\n  let suffixLength = 0;\n  for (const spec of specs) {\n    prefixLength = Math.max(prefixLength, spec.prefixLength);\n    suffixLength = Math.max(suffixLength, spec.suffixLength);\n  }\n  return { prefixLength, suffixLength, match: composeMatchFunctions(specs) };\n}\n\nexport class AutoDetectRegistry {\n  directorySpecs: AutoDetectDirectorySpec[] = [];\n  fileSpecs: AutoDetectFileSpec[] = [];\n  private _directorySpec: AutoDetectDirectorySpec | undefined;\n  private _fileSpec: AutoDetectFileSpec | undefined;\n\n  registerDirectoryFormat(spec: AutoDetectDirectorySpec) {\n    this.directorySpecs.push(spec);\n    this._directorySpec = undefined;\n  }\n\n  registerFileFormat(spec: AutoDetectFileSpec) {\n    this.fileSpecs.push(spec);\n    this._fileSpec = undefined;\n  }\n\n  copyTo(registry: AutoDetectRegistry) {\n    registry.directorySpecs.push(...this.directorySpecs);\n    registry.fileSpecs.push(...this.fileSpecs);\n    registry._fileSpec = undefined;\n    registry._directorySpec = undefined;\n  }\n\n  get directorySpec() {\n    return (\n      this._directorySpec ?? (this._directorySpec = this.getDirectorySpec())\n    );\n  }\n\n  private getDirectorySpec() {\n    return composeAutoDetectDirectorySpecs(this.directorySpecs);\n  }\n\n  get fileSpec() {\n    return this._fileSpec ?? (this._fileSpec = this.getFileSpec());\n  }\n\n  private getFileSpec() {\n    const { fileSpecs } = this;\n    const specs = [...fileSpecs];\n    return composeAutoDetectFileSpecs(specs);\n  }\n}\n\nexport interface AutoDetectFormatOptions extends Partial<ProgressOptions> {\n  kvStoreContext: KvStoreContext;\n  url: string;\n  autoDetectDirectory: () => AutoDetectDirectorySpec;\n  autoDetectFile: () => AutoDetectFileSpec;\n}\n\nexport async function autoDetectFormat(\n  options: AutoDetectFormatOptions,\n): Promise<{ matches: AutoDetectMatch[]; url: string }> {\n  const kvStore = options.kvStoreContext.getKvStore(options.url);\n  const { progressListener } = options;\n  using _span =\n    progressListener &&\n    new ProgressSpan(progressListener, {\n      message: `Auto-detecting data format at ${options.url}`,\n    });\n  if (!pathIsDirectory(kvStore.path) || kvStore.store.singleKey === true) {\n    const statResponse = await kvStore.store.stat(kvStore.path, {\n      signal: options.signal,\n      progressListener: options.progressListener,\n    });\n    if (statResponse !== undefined) {\n      // Match as file.\n      const autoDetectFile = options.autoDetectFile();\n      const { totalSize } = statResponse;\n      let prefix: Uint8Array<ArrayBuffer>;\n      let suffix: Uint8Array<ArrayBuffer> | undefined;\n      if (totalSize !== undefined && autoDetectFile.suffixLength > 0) {\n        if (\n          totalSize <=\n          autoDetectFile.prefixLength + autoDetectFile.suffixLength\n        ) {\n          // Perform a single read\n          const readResponse = await readKvStore(kvStore.store, kvStore.path, {\n            signal: options.signal,\n            progressListener: options.progressListener,\n            throwIfMissing: true,\n          });\n          prefix = suffix = new Uint8Array(\n            await readResponse.response.arrayBuffer(),\n          );\n        } else {\n          [prefix, suffix] = await Promise.all(\n            [\n              { offset: 0, length: autoDetectFile.prefixLength },\n              {\n                offset: totalSize - autoDetectFile.suffixLength,\n                length: autoDetectFile.suffixLength,\n              },\n            ].map((byteRange) =>\n              readKvStore(kvStore.store, kvStore.path, {\n                signal: options.signal,\n                progressListener: options.progressListener,\n                throwIfMissing: true,\n                byteRange,\n              })\n                .then((readResponse) => readResponse.response.arrayBuffer())\n                .then((arrayBuffer) => new Uint8Array(arrayBuffer)),\n            ),\n          );\n        }\n      } else {\n        prefix = new Uint8Array(\n          await (\n            await readKvStore(kvStore.store, kvStore.path, {\n              signal: options.signal,\n              progressListener: options.progressListener,\n              throwIfMissing: true,\n              byteRange: { offset: 0, length: autoDetectFile.prefixLength },\n            })\n          ).response.arrayBuffer(),\n        );\n      }\n      return {\n        matches: await autoDetectFile.match({\n          url: options.url,\n          prefix,\n          suffix,\n          totalSize,\n          signal: options.signal,\n        }),\n        url: options.url,\n      };\n    }\n\n    if (kvStore.store.singleKey === true) {\n      return { matches: [], url: options.url };\n    }\n    kvStore.path += \"/\";\n  }\n\n  const autoDetectDirectory = options.autoDetectDirectory();\n  const detectedFileNames = new Set<string>();\n  await Promise.all(\n    Array.from(autoDetectDirectory.fileNames ?? [], async (fileName) => {\n      const response = await kvStore.store.stat(kvStore.path + fileName, {\n        signal: options.signal,\n        progressListener: options.progressListener,\n      });\n      if (response !== undefined) {\n        detectedFileNames.add(fileName);\n      }\n    }),\n  );\n  const url = kvStore.store.getUrl(kvStore.path);\n  const matches = await autoDetectDirectory.match({\n    url,\n    fileNames: detectedFileNames,\n    subDirectories: new Set(),\n    signal: options.signal,\n  });\n  return { matches, url };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ByteRange,\n  ByteRangeRequest,\n  DriverReadOptions,\n  FileHandle,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport { readFileHandle } from \"#src/kvstore/index.js\";\n\nexport function composeByteRangeRequest(\n  outer: ByteRange,\n  inner: ByteRangeRequest | undefined,\n): { outer: ByteRange; inner: ByteRange } {\n  if (inner === undefined) {\n    return { outer, inner: { offset: 0, length: outer.length } };\n  }\n  if (\"suffixLength\" in inner) {\n    const length = Math.min(outer.length, inner.suffixLength);\n    return {\n      outer: { offset: outer.offset + (outer.length - length), length },\n      inner: { offset: outer.length - length, length },\n    };\n  }\n  if (inner.offset + inner.length > outer.length) {\n    throw new Error(\n      `Requested byte range ${JSON.stringify(\n        inner,\n      )} not valid for value of length ${outer.length}`,\n    );\n  }\n  return {\n    outer: { offset: outer.offset + inner.offset, length: inner.length },\n    inner,\n  };\n}\n\nexport function handleByteRangeRequestFromUint8Array(\n  value: Uint8Array,\n  byteRange: ByteRangeRequest | undefined,\n): ReadResponse {\n  const {\n    outer: { offset, length },\n  } = composeByteRangeRequest({ offset: 0, length: value.length }, byteRange);\n  return {\n    offset,\n    length,\n    totalSize: value.length,\n    response: new Response(value.subarray(offset, offset + length)),\n  };\n}\n\nexport class FileByteRangeHandle implements FileHandle {\n  constructor(\n    public base: FileHandle,\n    public byteRange: ByteRange,\n  ) {}\n\n  async stat(options: StatOptions): Promise<StatResponse | undefined> {\n    options;\n    return { totalSize: this.byteRange.length };\n  }\n\n  async read(options: DriverReadOptions): Promise<ReadResponse> {\n    const { byteRange } = this;\n    const { outer: outerByteRange, inner: innerByteRange } =\n      composeByteRangeRequest(byteRange, options.byteRange);\n    if (outerByteRange.length === 0) {\n      return {\n        response: new Response(new Uint8Array(0)),\n        totalSize: byteRange.length,\n        ...innerByteRange,\n      };\n    }\n    const response = await readFileHandle(this.base, {\n      signal: options.signal,\n      byteRange: outerByteRange,\n      strictByteRange: true,\n      throwIfMissing: true,\n    });\n    return {\n      response: response.response,\n      totalSize: byteRange.length,\n      ...innerByteRange,\n    };\n  }\n\n  getUrl() {\n    const { offset, length } = this.byteRange;\n    return `${this.base.getUrl()}|range:${offset}-${offset + length}`;\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { composeByteRangeRequest } from \"#src/kvstore/byte_range/file_handle.js\";\nimport type {\n  ByteRange,\n  DriverReadOptions,\n  ReadableKvStore,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport { KvStoreFileHandle, NotFoundError } from \"#src/kvstore/index.js\";\nimport type { FetchOk } from \"#src/util/http_request.js\";\nimport { fetchOk, HttpError, isNotFoundError } from \"#src/util/http_request.js\";\nimport type { ProgressListener } from \"#src/util/progress_listener.js\";\n\nfunction getRangeHeader(request: ByteRange | undefined): string | undefined {\n  if (request === undefined) return undefined;\n  return `bytes=${request.offset}-${request.offset + request.length - 1}`;\n}\n\n/**\n * On Chromium, multiple concurrent byte range requests to the same URL are serialized unless the\n * cache is disabled.  Disabling the cache works around the problem.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=969828\n */\nconst byteRangeCacheMode =\n  navigator.userAgent.indexOf(\"Chrome\") !== -1 ? \"no-store\" : \"default\";\n\nfunction wasRedirectedToDirectoryListing(url: string, response: Response) {\n  return new URL(url).pathname + \"/\" === new URL(response.url).pathname;\n}\n\nfunction parse206ContentRangeHeader(contentRange: string) {\n  const m = contentRange.match(/bytes ([0-9]+)-([0-9]+)\\/([0-9]+|\\*)/);\n  if (m === null) {\n    throw new Error(\n      `Invalid content-range header: ${JSON.stringify(contentRange)}`,\n    );\n  }\n  const offset = parseInt(m[1], 10);\n  const endPos = parseInt(m[2], 10);\n  let totalSize: number | undefined;\n  if (m[3] !== \"*\") {\n    totalSize = parseInt(m[3], 10);\n  }\n  const length = endPos - offset + 1;\n  return { offset, length, totalSize };\n}\n\nexport async function read<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  url: string,\n  options: DriverReadOptions,\n  fetchOkImpl: FetchOk = fetchOk,\n): Promise<ReadResponse | undefined> {\n  let resolvedByteRange: ByteRange | undefined;\n  try {\n    const { byteRange: byteRangeRequest } = options;\n    let rangeHeader: string | undefined;\n    // The HTTP spec supports suffixLength requests directly via \"Range:\n    // bytes=-N\" requests, which avoids the need for a separate HEAD request.\n    // However, per\n    // https://fetch.spec.whatwg.org/#cors-safelisted-request-header a suffix\n    // length byte range request header will always trigger an OPTIONS preflight\n    // request, which would otherwise be avoided. This negates the benefit of\n    // using a suffixLength request directly. Additionally, some servers such as\n    // the npm http-server package and https://uk1s3.embassy.ebi.ac.uk/ do not\n    // correctly handle suffixLength requests or do not correctly handle CORS\n    // preflight requests. To avoid those issues, always just issue a separate\n    // HEAD request to determine the length.\n    if (byteRangeRequest !== undefined) {\n      if (\"suffixLength\" in byteRangeRequest) {\n        const statResponse = await stat(store, key, url, options, fetchOkImpl);\n        if (statResponse === undefined) return undefined;\n        const { totalSize } = statResponse;\n        if (totalSize === undefined) {\n          throw new Error(\n            `Failed to determine total size of ${store.getUrl(key)} in order to fetch suffix ${JSON.stringify(byteRangeRequest)}`,\n          );\n        }\n        resolvedByteRange = composeByteRangeRequest(\n          { offset: 0, length: totalSize },\n          byteRangeRequest,\n        ).outer;\n        if (resolvedByteRange.length === 0) {\n          // Skip zero-byte read, since totalSize is already known.\n          return {\n            ...resolvedByteRange,\n            totalSize,\n            response: new Response(new Uint8Array(0)),\n          };\n        }\n        rangeHeader = getRangeHeader(resolvedByteRange);\n      } else {\n        resolvedByteRange = byteRangeRequest;\n        if (resolvedByteRange.length === 0) {\n          // The HTTP range header does not support zero-length byte range\n          // requests.\n          //\n          // Convert zero-length byte range to length-1 byte range, and then\n          // discard the response. If the requested offset is 0, and the file is\n          // empty, then this will result in a 416 Range Not Satisfiable\n          // response.\n          rangeHeader = getRangeHeader({\n            offset: Math.max(resolvedByteRange.offset - 1, 0),\n            length: 1,\n          });\n        } else {\n          rangeHeader = getRangeHeader(resolvedByteRange);\n        }\n      }\n    }\n    const requestInit: RequestInit & { progressListener?: ProgressListener } = {\n      signal: options.signal,\n      progressListener: options.progressListener,\n    };\n    if (rangeHeader !== undefined) {\n      requestInit.headers = { range: rangeHeader };\n      requestInit.cache = byteRangeCacheMode;\n    }\n    let response = await fetchOkImpl(url, requestInit);\n    if (wasRedirectedToDirectoryListing(url, response)) {\n      return undefined;\n    }\n    let offset: number | undefined;\n    let length: number | undefined;\n    let totalSize: number | undefined;\n    if (response.status === 206) {\n      const contentRange = response.headers.get(\"content-range\");\n      if (contentRange === null) {\n        // Content-range should always be sent, but some buggy servers don't\n        // send it.\n        if (resolvedByteRange !== undefined) {\n          offset = resolvedByteRange.offset;\n        } else {\n          throw new Error(\n            \"Unexpected HTTP 206 response when no byte range specified.\",\n          );\n        }\n      }\n      if (contentRange !== null) {\n        ({ offset, length, totalSize } =\n          parse206ContentRangeHeader(contentRange));\n      }\n    } else {\n      length = totalSize = getBodyLength(response.headers);\n    }\n    if (offset === undefined) {\n      offset = 0;\n    }\n    if (length === undefined) {\n      length = getBodyLength(response.headers);\n    }\n    if (resolvedByteRange?.length === 0) {\n      response = new Response(new Uint8Array(0));\n      offset = resolvedByteRange.offset;\n      length = 0;\n    }\n    return {\n      response,\n      offset,\n      length,\n      totalSize,\n    };\n  } catch (e) {\n    if (\n      e instanceof HttpError &&\n      e.status === 416 &&\n      resolvedByteRange?.length === 0 &&\n      resolvedByteRange.offset === 0\n    ) {\n      return {\n        response: new Response(new Uint8Array(0)),\n        offset: 0,\n        length: 0,\n        totalSize: 0,\n      };\n    }\n    return handleThrowIfMissing(store, key, options, e);\n  }\n}\n\nfunction getBodyLength(headers: Headers): number | undefined {\n  const contentLength = headers.get(\"content-length\");\n  const contentEncoding = headers.get(\"content-encoding\");\n  if (contentEncoding === null && contentLength !== null) {\n    const size = Number(contentLength);\n    if (!Number.isFinite(size) || size < 0) {\n      throw new Error(`Invalid content-length: {contentLength}`);\n    }\n    return size;\n  }\n  return undefined;\n}\n\nfunction handleThrowIfMissing<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  options: { throwIfMissing?: boolean },\n  error: unknown,\n) {\n  if (isNotFoundError(error)) {\n    if (options.throwIfMissing === true) {\n      throw new NotFoundError(new KvStoreFileHandle(store, key), {\n        cause: error,\n      });\n    }\n    return undefined;\n  }\n  throw error;\n}\n\nexport async function stat<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  url: string,\n  options: StatOptions,\n  fetchOkImpl: FetchOk = fetchOk,\n): Promise<StatResponse | undefined> {\n  // First try HEAD request.\n  try {\n    const response = await fetchOkImpl(url, {\n      method: \"HEAD\",\n      signal: options.signal,\n      progressListener: options.progressListener,\n    });\n    if (wasRedirectedToDirectoryListing(url, response)) return undefined;\n    return { totalSize: getBodyLength(response.headers) };\n  } catch (e) {\n    if (\n      e instanceof HttpError &&\n      (e.status === 405 /* method not allowed */ ||\n        e.status === 501) /* not implemented */\n    ) {\n      // HEAD may not be supported, use GET with one byte range instead.\n      //\n      // For example,\n      // https://data-proxy.ebrains.eu/api/v1/buckets/localizoom/14122_mPPC_BDA_s186.tif/14122_mPPC_BDA_s186.dzi\n      // returns HTTP 405 Method Not Allowed in response to HEAD requests.\n      //\n      // Servers are not supposed to return 501 for HEAD requests\n      // (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501), but\n      // some do anyway:\n      //\n      // https://github.com/google/neuroglancer/issues/704\n    } else {\n      return handleThrowIfMissing(store, key, options, e);\n    }\n  }\n\n  // Try GET with one-byte range instead.\n  try {\n    const response = await fetchOkImpl(url, {\n      signal: options.signal,\n      progressListener: options.progressListener,\n      headers: { range: \"bytes=0-0\" },\n    });\n    if (wasRedirectedToDirectoryListing(url, response)) return undefined;\n    let totalSize: number | undefined;\n    if (response.status === 200) {\n      totalSize = getBodyLength(response.headers);\n    } else {\n      const contentRange = response.headers.get(\"content-range\");\n      if (contentRange !== null) {\n        ({ totalSize } = parse206ContentRangeHeader(contentRange));\n      }\n    }\n    return { totalSize };\n  } catch (e) {\n    if (e instanceof HttpError && e.status === 416) {\n      return { totalSize: 0 };\n    }\n    return handleThrowIfMissing(store, key, options, e);\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\n\nexport interface ByteRange {\n  offset: number;\n  length: number;\n}\n\nexport type ByteRangeRequest =\n  | ByteRange\n  | {\n      suffixLength: number;\n    };\n\nexport interface ReadResponse {\n  response: Response;\n  offset: number;\n  length: number | undefined;\n  totalSize: number | undefined;\n}\n\nexport interface DriverReadOptions extends Partial<ProgressOptions> {\n  byteRange?: ByteRangeRequest;\n  throwIfMissing?: boolean;\n}\n\nexport class NotFoundError extends Error {\n  constructor(handle: FileHandle, options?: { cause: any }) {\n    super(`${handle.getUrl()} not found`, options);\n  }\n}\n\nexport interface ReadOptions extends DriverReadOptions {\n  strictByteRange?: boolean;\n}\n\nexport type DriverListOptions = Partial<ProgressOptions>;\n\nexport type ListResponseKeyKind = \"path\" | \"suffix\" | \"url\";\n\nexport interface ListOptions extends DriverListOptions {\n  responseKeys?: ListResponseKeyKind;\n}\n\nexport interface ListEntry {\n  key: string;\n}\n\nexport interface ListResponse {\n  entries: ListEntry[];\n  directories: string[];\n}\n\nexport interface StatOptions extends Partial<ProgressOptions> {\n  throwIfMissing?: boolean;\n}\n\nexport interface StatResponse {\n  totalSize: number | undefined;\n}\n\nexport interface ReadableKvStore<Key = string> {\n  stat(key: Key, options: StatOptions): Promise<StatResponse | undefined>;\n  read(key: Key, options: DriverReadOptions): Promise<ReadResponse | undefined>;\n  getUrl(key: Key): string;\n\n  // Reads with non-zero byte offset are supported.\n  supportsOffsetReads: boolean;\n\n  // Reads with `suffixLength` byte range are supported.\n  supportsSuffixReads: boolean;\n}\n\nexport interface ListableKvStore {\n  list?: (prefix: string, options: DriverListOptions) => Promise<ListResponse>;\n}\n\nexport interface KvStore extends ReadableKvStore, ListableKvStore {\n  // Indicates that the only valid key is the empty string.\n  singleKey?: boolean;\n}\n\nexport interface KvStoreWithPath {\n  store: KvStore;\n  path: string;\n}\n\nexport function getKvStoreUrl(kvstore: KvStoreWithPath): string {\n  return kvstore.store.getUrl(kvstore.path);\n}\n\nexport function readKvStore<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  options: ReadOptions & { throwIfMissing: true },\n): Promise<ReadResponse>;\n\nexport function readKvStore<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  options?: ReadOptions,\n): Promise<ReadResponse | undefined>;\n\nexport async function readKvStore<Key>(\n  store: ReadableKvStore<Key>,\n  key: Key,\n  options: ReadOptions = {},\n): Promise<ReadResponse | undefined> {\n  return readFileHandle(new KvStoreFileHandle(store, key), options);\n}\n\nexport function readFileHandle(\n  handle: FileHandle,\n  options: ReadOptions & { throwIfMissing: true },\n): Promise<ReadResponse>;\n\nexport function readFileHandle(\n  handle: FileHandle,\n  options?: ReadOptions,\n): Promise<ReadResponse | undefined>;\n\nexport async function readFileHandle(\n  handle: FileHandle,\n  options: ReadOptions = {},\n): Promise<ReadResponse | undefined> {\n  const response = await handle.read(options);\n  if (options?.throwIfMissing === true) {\n    if (response === undefined) {\n      throw new NotFoundError(handle);\n    }\n  }\n  if (options?.strictByteRange === true && response !== undefined) {\n    const { byteRange } = options;\n    const { offset, length } = response;\n    if (byteRange !== undefined) {\n      if (\n        \"suffixLength\" in byteRange\n          ? length !== byteRange.suffixLength\n          : offset !== byteRange.offset ||\n            (length !== undefined && length !== byteRange.length)\n      ) {\n        throw new Error(\n          `Received truncated response for ${handle.getUrl()}, expected ${JSON.stringify(\n            byteRange,\n          )} but received offset=${offset}, length=${length}`,\n        );\n      }\n    }\n  }\n  return response;\n}\n\nfunction transformListResponse(\n  response: ListResponse,\n  prefix: string,\n  kvStore: KvStore,\n  responseKeys?: ListResponseKeyKind,\n) {\n  switch (responseKeys) {\n    case \"suffix\": {\n      const offset = prefix.length;\n      return {\n        directories: response.directories.map((key) => key.substring(offset)),\n        entries: response.entries.map(({ key, ...entry }) => ({\n          ...entry,\n          key: key.substring(offset),\n        })),\n      };\n    }\n    case \"url\": {\n      return {\n        directories: response.directories.map((key) => kvStore.getUrl(key)),\n        entries: response.entries.map(({ key, ...entry }) => ({\n          ...entry,\n          key: kvStore.getUrl(key),\n        })),\n      };\n    }\n    default: {\n      return response;\n    }\n  }\n}\n\nexport async function listKvStore(\n  kvStore: KvStore,\n  prefix: string,\n  options: ListOptions = {},\n): Promise<ListResponse> {\n  if (!kvStore.list) {\n    throw new Error(\"Listing not supported\");\n  }\n  return transformListResponse(\n    await kvStore.list(prefix, options),\n    prefix,\n    kvStore,\n    options.responseKeys,\n  );\n}\n\nexport async function listKvStoreRecursively(\n  kvStore: KvStore,\n  prefix: string,\n  options: ListOptions = {},\n): Promise<ListEntry[]> {\n  if (!kvStore.list) {\n    throw new Error(\"Listing not supported\");\n  }\n  const entries: ListEntry[] = [];\n  async function process(path: string) {\n    const response = await kvStore.list!(path, options);\n    entries.push(...response.entries);\n    await Promise.all(response.directories.map((name) => process(name + \"/\")));\n  }\n  await process(prefix);\n  return transformListResponse(\n    normalizeListResponse({ entries, directories: [] }),\n    prefix,\n    kvStore,\n    options.responseKeys,\n  ).entries;\n}\n\nexport function kvStoreAppendPath(\n  kvstore: KvStoreWithPath,\n  suffix: string,\n): KvStoreWithPath {\n  return { store: kvstore.store, path: kvstore.path + suffix };\n}\n\nexport interface FileHandle {\n  stat(options: StatOptions): Promise<StatResponse | undefined>;\n  read(options: DriverReadOptions): Promise<ReadResponse | undefined>;\n  getUrl(): string;\n}\n\nexport class KvStoreFileHandle<Key> implements FileHandle {\n  constructor(\n    public store: ReadableKvStore<Key>,\n    public key: Key,\n  ) {}\n\n  stat(options: StatOptions): Promise<StatResponse | undefined> {\n    return this.store.stat(this.key, options);\n  }\n\n  read(options: DriverReadOptions): Promise<ReadResponse | undefined> {\n    return this.store.read(this.key, options);\n  }\n\n  getUrl() {\n    return this.store.getUrl(this.key);\n  }\n}\n\nexport function normalizeListResponse(response: ListResponse): ListResponse {\n  response.entries.sort(({ key: a }, { key: b }) => defaultStringCompare(a, b));\n  response.directories.sort(defaultStringCompare);\n  return response;\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CommitTime,\n  GenerationNumber,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\n\nexport type VersionSpecifier =\n  | { generationNumber: GenerationNumber }\n  | { commitTime: CommitTime };\n\nexport function formatVersion(version: VersionSpecifier | undefined) {\n  if (version === undefined) return \"HEAD\";\n  if (\"generationNumber\" in version) {\n    return `v${version.generationNumber}`;\n  }\n  const { commitTime } = version;\n  return formatCommitTime(commitTime);\n}\n\nexport function parseVersion(\n  versionString: string | undefined,\n): VersionSpecifier | undefined {\n  if (versionString === undefined) return undefined;\n  const m = versionString.match(\n    /^(?:v([1-9]\\d*)|(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d*)?Z))$/,\n  );\n  if (m === null) {\n    throw new Error(\n      `Invalid OCDBT version specifier: ${JSON.stringify(versionString)}`,\n    );\n  }\n  const [, generationString] = m;\n  if (generationString !== undefined) {\n    const generationNumber = BigInt(generationString);\n    if (generationNumber > 0xffffffffffffffffn) {\n      throw new Error(`Invalid generation number: ${generationNumber}`);\n    }\n    return { generationNumber };\n  }\n  return { commitTime: parseCommitTime(versionString) };\n}\n\nfunction parseCommitTime(versionString: string): CommitTime {\n  const m = versionString.match(\n    /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2})(?:(\\.\\d*))?Z$/,\n  );\n  if (m === null)\n    throw new Error(\n      `Invalid commit timestamp: ${JSON.stringify(versionString)}`,\n    );\n  const [, commitTimeString, commitTimeFractionalSeconds] = m;\n  return commitTimeFromSecondsAndSubseconds(\n    Date.parse(commitTimeString + \"Z\"),\n    commitTimeFractionalSeconds,\n  );\n}\n\nfunction commitTimeFromSecondsAndSubseconds(\n  seconds: number,\n  subseconds: string | undefined,\n) {\n  let commitTime = BigInt(seconds) * 1000000n;\n  if (subseconds !== undefined && subseconds.length > 1) {\n    const fraction = Number(subseconds);\n    commitTime += BigInt(Math.min(999999999, Math.round(fraction * 1e9)));\n  }\n  return commitTime;\n}\n\nexport function formatCommitTime(commitTime: CommitTime) {\n  let fractionalSeconds = commitTime % 1000000000n;\n  let seconds = commitTime / 1000000000n;\n  if (fractionalSeconds < 0n) {\n    fractionalSeconds += 1000000000n;\n    seconds -= 1n;\n  }\n  let timestampString = new Date(Number(seconds) * 1000).toISOString();\n  if (timestampString.length !== 24) {\n    throw new Error(`Invalid commit time: ${commitTime} -> ${timestampString}`);\n  }\n  // Strip off .nnnZ portion.\n  timestampString = timestampString.slice(0, 19);\n  if (fractionalSeconds !== 0n) {\n    timestampString +=\n      \".\" + fractionalSeconds.toString().padStart(9, \"0\").replace(/0+$/, \"\");\n  }\n  timestampString += \"Z\";\n  return timestampString;\n}\n\nconst COMMIT_TIME_PREFIX_REGEXP = new RegExp(\n  \"^\" +\n    \"(\\\\d{0,4})\" + // year, always matches\n    \"(?:(?<=\\\\d{4})-\" + // month separator, only allowed after 4-digit year\n    \"(\\\\d{0,2})\" + // month\n    \"(?:(?<=\\\\d{2})-\" + // day separator, only allowed after 2-digit month\n    \"(\\\\d{0,2})\" + // day\n    \"(?:(?<=\\\\d{2})T\" + // hour separator, only allowed after 2-digit day\n    \"(\\\\d{0,2})\" + // hour\n    \"(?:(?<=\\\\d{2}):\" + // minute separator, only allowed after 2-digit hour\n    \"(\\\\d{0,2})\" + // minute\n    \"(?:(?<=\\\\d{2}):\" + // second separator, only allowed after 2-digit minute\n    \"(\\\\d{0,2})\" + // second\n    \"(?:(?<=\\\\d{2})\" + // subseconds and Z only allowed after 2-digit second\n    \"(\\\\.\\\\d*)?\" + // subseconds\n    \"(Z)?\" + // Z suffix, indicates an exact timestamp rather than a prefix\n    \")?\" + // end of subsecond/Z group\n    \")?\" + // end of second group\n    \")?\" + // end of minute group\n    \")?\" + // end of hour group\n    \")?\" + // end of day group\n    \")?\" + // end of month group\n    \"$\",\n);\n\nfunction getMinMaxDateComponent(\n  componentName: string,\n  prefix: string | undefined,\n  digits: number,\n  inclusiveMinBound: number,\n  inclusiveMaxBound: number,\n) {\n  prefix = prefix ?? \"\";\n  const min = parseInt(prefix.padEnd(digits, \"0\"), 10);\n  const max = parseInt(prefix.padEnd(digits, \"9\"), 10);\n  if (min > inclusiveMaxBound) {\n    throw new Error(`Invalid ${componentName} prefix: ${prefix}`);\n  }\n  return [Math.max(inclusiveMinBound, min), Math.min(inclusiveMaxBound, max)];\n}\n\nfunction getDaysInMonth(year: number, month: number) {\n  const d = new Date(0);\n  d.setUTCFullYear(year);\n  d.setUTCMonth(month);\n  d.setUTCDate(0);\n  return d.getUTCDate();\n}\n\nexport function parseCommitTimePrefix(\n  versionString: string,\n): [CommitTime, CommitTime] {\n  const m = versionString.match(COMMIT_TIME_PREFIX_REGEXP);\n  if (m === null) {\n    throw new Error(\n      `Expected prefix of ISO-8601 \"YYYY-MM-DDThh:mm:ss.sssssssssZ\" format, but received: ${JSON.stringify(versionString)}`,\n    );\n  }\n  const year = getMinMaxDateComponent(\"year\", m[1], 4, 0, 9999);\n  const month = getMinMaxDateComponent(\"month\", m[2], 2, 1, 12);\n  const daysInMaxMonth = getDaysInMonth(year[1], month[1]);\n  const day = getMinMaxDateComponent(\"day\", m[3], 2, 1, daysInMaxMonth);\n  const hour = getMinMaxDateComponent(\"hour\", m[4], 2, 0, 23);\n  const minute = getMinMaxDateComponent(\"minute\", m[5], 2, 0, 59);\n  const second = getMinMaxDateComponent(\"second\", m[6], 2, 0, 59);\n  const subsecondString = m[7] ?? \".\";\n  const z = m[8];\n  const minSubseconds = subsecondString.padEnd(10, \"0\");\n  const maxSubseconds =\n    z === undefined ? subsecondString.padEnd(10, \"9\") : minSubseconds;\n  const subseconds = [minSubseconds, maxSubseconds];\n  function getDate(i: number): CommitTime {\n    const date = new Date(0);\n    date.setUTCFullYear(year[i]);\n    date.setUTCMonth(month[i] - 1);\n    date.setUTCDate(day[i]);\n    date.setUTCHours(hour[i]);\n    date.setUTCMinutes(minute[i]);\n    date.setUTCSeconds(second[i]);\n    return commitTimeFromSecondsAndSubseconds(date.getTime(), subseconds[i]);\n  }\n  return [getDate(0), getDate(1)];\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ListEntry, ListResponse } from \"#src/kvstore/index.js\";\nimport { encodePathForUrl, getBaseHttpUrlAndPath } from \"#src/kvstore/url.js\";\nimport type { FetchOk } from \"#src/util/http_request.js\";\nimport type { StringMemoize } from \"#src/util/memoize.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nconst EXPECTED_XML_NAMESPACE_URIS = [\n  \"http://doc.s3.amazonaws.com/2006-03-01/\",\n  \"http://s3.amazonaws.com/doc/2006-03-01/\",\n];\n\nfunction isValidListObjectsResponse(documentElement: Element): boolean {\n  return (\n    EXPECTED_XML_NAMESPACE_URIS.includes(documentElement.namespaceURI!) &&\n    documentElement.tagName === \"ListBucketResult\"\n  );\n}\n\nexport function isS3ListResponse(text: string): boolean {\n  let doc: Document;\n  try {\n    doc = new DOMParser().parseFromString(text, \"application/xml\");\n  } catch {\n    return false;\n  }\n  return isValidListObjectsResponse(doc.documentElement);\n}\n\nexport async function getS3BucketListing(\n  bucketUrl: string,\n  prefix: string,\n  fetchOkImpl: FetchOk,\n  options: Partial<ProgressOptions>,\n): Promise<ListResponse> {\n  const delimiter = \"/\";\n  try {\n    const response = await fetchOkImpl(\n      `${bucketUrl}?list-type=2&prefix=${encodeURIComponent(prefix)}` +\n        `&delimiter=${encodeURIComponent(delimiter)}&encoding-type=url`,\n      /*init=*/ {\n        headers: { accept: \"application/xml,text/xml\" },\n        signal: options.signal,\n        progressListener: options.progressListener,\n      },\n    );\n    const contentType = response.headers.get(\"content-type\");\n    // Per https://github.com/getmoto/moto/issues/8560, also allow text/html.\n    if (\n      contentType === null ||\n      /\\b(application\\/xml|text\\/xml|text\\/html)\\b/i.exec(contentType) === null\n    ) {\n      throw new Error(`Expected XML content-type but received: ${contentType}`);\n    }\n    const text = await response.text();\n    const doc = new DOMParser().parseFromString(text, \"application/xml\");\n    const { documentElement } = doc;\n    if (!isValidListObjectsResponse(documentElement)) {\n      throw new Error(\n        `Received unexpected XML root element <${documentElement.tagName} xmlns=\"${documentElement.namespaceURI}\">`,\n      );\n    }\n    const namespaceURI = documentElement.namespaceURI!;\n    const namespaceResolver: XPathNSResolver = () => namespaceURI;\n    const commonPrefixNodes = doc.evaluate(\n      \"//CommonPrefixes/Prefix\",\n      doc,\n      namespaceResolver,\n      XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    );\n    const directories: string[] = [];\n    for (let i = 0, n = commonPrefixNodes.snapshotLength; i < n; ++i) {\n      let name = commonPrefixNodes.snapshotItem(i)!.textContent;\n      if (name === null) continue;\n      name = decodeURIComponent(name);\n      // Exclude delimiter from end of `name`.\n      directories.push(name.substring(0, name.length - delimiter.length));\n    }\n\n    const entries: ListEntry[] = [];\n    const contents = doc.evaluate(\n      \"//Contents/Key\",\n      doc,\n      namespaceResolver,\n      XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    );\n    for (let i = 0, n = contents.snapshotLength; i < n; ++i) {\n      const name = contents.snapshotItem(i)!.textContent;\n      if (name === null) continue;\n      entries.push({ key: decodeURIComponent(name) });\n    }\n    return { directories, entries };\n  } catch (e) {\n    throw new Error(`S3-compatible listing not supported`, { cause: e });\n  }\n}\n\nfunction getVirtualHostedStyleListing(\n  url: string,\n  fetchOkImpl: FetchOk,\n  options: Partial<ProgressOptions>,\n): Promise<ListResponse> {\n  const { baseUrl, path } = getBaseHttpUrlAndPath(url);\n  return getS3BucketListing(baseUrl, path, fetchOkImpl, options);\n}\n\nfunction parsePathStyleUrl(url: string):\n  | {\n      bucketUrl: string;\n      bucket: string;\n      prefix: string;\n    }\n  | undefined {\n  const u = new URL(url);\n  const m = u.pathname.match(/^\\/([^/]+)(?:\\/(.*))$/)!;\n  if (m === null) {\n    return undefined;\n  }\n  const [, bucket, path] = m;\n  return {\n    bucketUrl: `${u.origin}/${bucket}/${u.search}`,\n    bucket: decodeURIComponent(bucket),\n    prefix: decodeURIComponent(path),\n  };\n}\n\nasync function getPathStyleListing(\n  url: string,\n  fetchOkImpl: FetchOk,\n  options: Partial<ProgressOptions>,\n): Promise<ListResponse> {\n  const parsed = parsePathStyleUrl(url);\n  if (parsed === undefined) {\n    throw new Error(\n      `Path-style S3 URL ${JSON.stringify(url)} must specify bucket`,\n    );\n  }\n  const { bucketUrl, bucket, prefix } = parsed;\n  const response = await getS3BucketListing(\n    bucketUrl,\n    prefix,\n    fetchOkImpl,\n    options,\n  );\n  const bucketPrefix = encodePathForUrl(bucket) + \"/\";\n  return {\n    entries: response.entries.map((entry) => ({\n      key: bucketPrefix + entry.key,\n    })),\n    directories: response.directories.map((name) => bucketPrefix + name),\n  };\n}\n\nexport type S3UrlKind = \"virtual\" | \"path\";\n\n// Map of known S3-compatible servers, indicating the URL type.\n//\n// The key is the origin / base URL.\n//\n// A value of `null` indicates that S3-style listing is not supported.\nfunction getUrlKindCache(memoize: StringMemoize) {\n  return memoize.getUncounted(\n    \"s3:urlkind\",\n    () => new Map<string, S3UrlKind | null>(),\n  );\n}\n\n// Lists an S3-compatible URL.\n//\n// Both virtual hosted-style URLS `https://{host}/{path}` and\n// `https://{host}/{bucket}/{path}` are supported.\nexport async function listS3CompatibleUrl(\n  url: string,\n  origin: string,\n  memoize: StringMemoize,\n  fetchOkImpl: FetchOk,\n  options: Partial<ProgressOptions>,\n): Promise<ListResponse> {\n  const cache = getUrlKindCache(memoize);\n  const urlKind = cache.get(origin);\n  if (urlKind === \"virtual\") {\n    return await getVirtualHostedStyleListing(url, fetchOkImpl, options);\n  }\n  if (urlKind === \"path\") {\n    return await getPathStyleListing(url, fetchOkImpl, options);\n  }\n  if (urlKind !== null) {\n    try {\n      const { result, urlKind } = await Promise.any([\n        getVirtualHostedStyleListing(url, fetchOkImpl, options).then(\n          (result) => ({\n            result,\n            urlKind: \"virtual\" as const,\n          }),\n        ),\n        getPathStyleListing(url, fetchOkImpl, options).then((result) => ({\n          result,\n          urlKind: \"path\" as const,\n        })),\n      ]);\n      cache.set(origin, urlKind);\n      return result;\n    } catch (e) {\n      options.signal?.throwIfAborted();\n      cache.set(origin, null);\n      throw new Error(\n        `Neither virtual hosted nor path-style S3 listing supported`,\n        { cause: e },\n      );\n    }\n  }\n  throw new Error(`Neither virtual hosted nor path-style S3 listing supported`);\n}\n\nexport function getS3UrlKind(\n  memoize: StringMemoize,\n  origin: string,\n): S3UrlKind | null | undefined {\n  return getUrlKindCache(memoize).get(origin);\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function kvstoreEnsureDirectoryPipelineUrl(url: string): string {\n  const m = url.match(\n    /^((?:.*?\\|)?)([a-zA-Z][a-zA-Z0-9-+.]*)(?:(:[^?#|]*)((?:[?#][^|]*)?))?$/,\n  );\n  if (m === null) {\n    throw new Error(`Invalid URL: ${url}`);\n  }\n  const [, pipelinePrefix, scheme, path, queryAndFragment] = m;\n  if (path === undefined) {\n    return `${pipelinePrefix}${scheme}:`;\n  }\n  if (path === \":\" || path.endsWith(\"/\")) return url;\n  return `${pipelinePrefix}${scheme}${path}/${queryAndFragment ?? \"\"}`;\n}\n\nexport function finalPipelineUrlComponent(url: string) {\n  // match is infallible\n  const m = url.match(/.*?([^|]*)$/)!;\n  return m[1];\n}\n\nexport const schemePattern = /^(?:([a-zA-Z][a-zA-Z0-9-+.]*):)?(.*)$/;\n\nexport function parsePipelineUrlComponent(url: string): UrlWithParsedScheme {\n  // schemePattern always matches\n  const m = url.match(schemePattern)!;\n  const scheme = m[1];\n  const suffix = m[2];\n  if (scheme === undefined) {\n    return { url, scheme: url, suffix: undefined };\n  } else {\n    return { url, scheme: scheme, suffix };\n  }\n}\n\nexport const urlComponentPattern =\n  /^(?:([a-zA-Z][a-zA-Z0-9-+.]*):)?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/;\n\nexport function parseUrlSuffix(suffix: string | undefined): {\n  authorityAndPath: string | undefined;\n  query: string | undefined;\n  fragment: string | undefined;\n} {\n  if (suffix === undefined) {\n    return {\n      authorityAndPath: undefined,\n      query: undefined,\n      fragment: undefined,\n    };\n  }\n  // Infallible pattern.\n  const [, authorityAndPath, query, fragment] = suffix.match(\n    /^([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$/,\n  )!;\n  return {\n    authorityAndPath,\n    query: query ?? undefined,\n    fragment: fragment ?? undefined,\n  };\n}\n\nexport interface UrlWithParsedScheme {\n  // Full original URL.\n  url: string;\n\n  // Scheme (excluding \":\").\n  scheme: string;\n\n  // Suffix following \"<scheme>:\", including initial \"//\" if present.\n  suffix: string | undefined;\n}\n\n// Splits a URL containing multiple \"|\"-separate parts.\nexport function splitPipelineUrl(url: string): UrlWithParsedScheme[] {\n  return url.split(\"|\").map(parsePipelineUrlComponent);\n}\n\nexport function pipelineUrlJoin(\n  baseUrl: string,\n  ...additionalParts: string[]\n): string {\n  // Strip off any ? or # parameters, since they are not part of the path.\n  // Infallible pattern\n  let [, base, queryAndFragment] = baseUrl.match(/^(.*?[^|?#]*)([^|]*)$/)!;\n  for (let part of additionalParts) {\n    if (part.startsWith(\"/\")) {\n      part = part.substring(1);\n    }\n    if (part === \"\") continue;\n    base = kvstoreEnsureDirectoryPipelineUrl(base);\n    base += encodePathForUrl(part);\n  }\n  return base + queryAndFragment;\n}\n\nexport function joinPath(base: string, ...additionalParts: string[]) {\n  for (let part of additionalParts) {\n    if (part.startsWith(\"/\")) {\n      part = part.substring(1);\n    }\n    if (part === \"\") continue;\n    base = ensurePathIsDirectory(base);\n    base += part;\n  }\n  return base;\n}\n\nexport function ensurePathIsDirectory(path: string) {\n  if (!pathIsDirectory(path)) {\n    path += \"/\";\n  }\n  return path;\n}\n\nexport function ensureNoQueryOrFragmentParameters(url: UrlWithParsedScheme) {\n  const { suffix } = url;\n  if (suffix === undefined) return;\n  if (suffix.match(/[#?]/)) {\n    throw new Error(\n      `Invalid URL ${url.url}: query parameters and/or fragment not supported`,\n    );\n  }\n}\n\nexport function ensureEmptyUrlSuffix(url: UrlWithParsedScheme) {\n  if (url.suffix) {\n    throw new Error(\n      `Invalid URL syntax ${JSON.stringify(url.url)}, expected \"${url.scheme}:\"`,\n    );\n  }\n}\n\nexport function extractQueryAndFragment(url: string): {\n  base: string;\n  queryAndFragment: string;\n} {\n  const [, base, queryAndFragment] = url.match(/^(.*?[^|?#]*)([^|]*)$/)!;\n  return { base, queryAndFragment };\n}\n\n// Resolves `relativePath` relative to `basePath`.\n//\n// Note that the parameters are both expected to be plain paths, not full URLs\n// or URL pipelines.\nexport function resolveRelativePath(basePath: string, relativePath: string) {\n  const origBasePath = basePath;\n  if (basePath.endsWith(\"/\")) {\n    basePath = basePath.substring(0, basePath.length - 1);\n  }\n  for (const component of relativePath.split(\"/\")) {\n    if (component === \"\" || component === \".\") {\n      continue;\n    }\n    if (component === \"..\") {\n      const prevSlash = basePath.lastIndexOf(\"/\");\n      if (prevSlash <= 0) {\n        throw new Error(\n          `Invalid relative path ${JSON.stringify(relativePath)} from base path ${JSON.stringify(origBasePath)}`,\n        );\n      }\n      basePath = basePath.substring(0, prevSlash);\n      continue;\n    }\n    if (basePath !== \"\") {\n      basePath += \"/\";\n    }\n    basePath += component;\n  }\n  if (relativePath.endsWith(\"/\")) {\n    basePath += \"/\";\n  }\n  return basePath;\n}\n\nexport function pathIsDirectory(path: string) {\n  return path === \"\" || path.endsWith(\"/\");\n}\n\n// Plain paths can have arbitrary characters, but to be included in a URL\n// pipeline, special characters must be percent encoded.\nexport function encodePathForUrl(path: string) {\n  return encodeURI(path).replace(\n    /[?#@]/g,\n    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`,\n  );\n}\n\nexport function joinBaseUrlAndPath(baseUrl: string, path: string) {\n  const { base, queryAndFragment } = extractQueryAndFragment(baseUrl);\n  return base + encodePathForUrl(path) + queryAndFragment;\n}\n\nexport function getBaseHttpUrlAndPath(url: string) {\n  const parsed = new URL(url);\n  if (parsed.hash) {\n    throw new Error(\"fragment not supported\");\n  }\n  if (parsed.username || parsed.password) {\n    throw new Error(\"basic auth credentials not supported\");\n  }\n  return {\n    baseUrl: `${parsed.origin}/${parsed.search}`,\n    path: decodeURIComponent(parsed.pathname.substring(1)),\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum VisibleSegmentEquivalencePolicy {\n  MIN_REPRESENTATIVE = 0, // defafult, representative elmement is the minimum element in equivalence set\n  MAX_REPRESENTATIVE = 1, // representative elmement is the maximum element in equivalence set\n  REPRESENTATIVE_EXCLUDED = 1 << 1, // filter out the representative element when iterating over visible segments\n  NONREPRESENTATIVE_EXCLUDED = 1 << 2, // filter out non representative elements when iterating over visible segments\n}\n\n// Returns `true` if `segmentId` is a base segment id, rather than a segment id added to the graph.\nexport function isBaseSegmentId(segmentId: bigint) {\n  return segmentId & 0x8000000000000000n ? false : true;\n}\n\nexport const UNKNOWN_NEW_SEGMENT_ID = 0xffffffffffffffffn;\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\nimport type { Borrowed, Disposable, Owned } from \"#src/util/disposable.js\";\nimport { invokeDisposers, RefCounted } from \"#src/util/disposable.js\";\nimport type { NullaryReadonlySignal } from \"#src/util/signal.js\";\nimport { neverSignal, NullarySignal, Signal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\n\nexport interface WatchableValueInterface<T> {\n  value: T;\n  changed: NullaryReadonlySignal;\n}\n\nexport interface WatchableValueChangeInterface<T> {\n  readonly value: T;\n  readonly changed: Signal<(oldValue: T, newValue: T) => void>;\n}\n\nexport class WatchableValue<T> implements WatchableValueInterface<T> {\n  get value() {\n    return this.value_;\n  }\n  set value(newValue: T) {\n    if (newValue !== this.value_) {\n      this.value_ = newValue;\n      this.changed.dispatch();\n    }\n  }\n  changed = new NullarySignal();\n  constructor(protected value_: T) {}\n}\n\nexport class TrackableValue<T> extends WatchableValue<T> implements Trackable {\n  constructor(\n    value: T,\n    public validator: (value: any) => T,\n    public defaultValue = value,\n  ) {\n    super(value);\n  }\n  toJSON(): any {\n    const { value_ } = this;\n    if (value_ === this.defaultValue) {\n      return undefined;\n    }\n    return this.value_;\n  }\n  reset() {\n    this.value = this.defaultValue;\n  }\n  restoreState(x: any) {\n    if (x !== undefined) {\n      const { validator } = this;\n      try {\n        this.value = validator(x);\n        return;\n      } catch {\n        // Ignore invalid values in JSON representation.\n      }\n    }\n    this.value = this.defaultValue;\n  }\n}\n\nclass DerivedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  changed = new NullarySignal();\n  get value() {\n    return this.f(...this.ws.map((w) => w.value));\n  }\n  private f: (...v: any[]) => U;\n  private ws: WatchableValueInterface<any>[];\n\n  constructor(f: (...v: any[]) => U, ws: WatchableValueInterface<any>[]) {\n    super();\n    this.f = f;\n    this.ws = ws;\n    for (const w of ws) {\n      this.registerDisposer(w.changed.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport function makeDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ...ws: { [K in keyof T]: WatchableValueInterface<T[K]> }\n) {\n  return new DerivedWatchableValue(f, ws);\n}\n\nclass CachedLazyDerivedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  changed = new NullarySignal();\n  private value_: U | undefined;\n  private valueGeneration = -1;\n  get value() {\n    const generation = this.changed.count;\n    if (generation !== this.valueGeneration) {\n      this.value_ = this.f(...this.ws.map((w) => w.value));\n      this.valueGeneration = generation;\n    }\n    return this.value_ as U;\n  }\n  private f: (...v: any[]) => U;\n  private ws: WatchableValueInterface<any>[];\n\n  constructor(f: (...v: any[]) => U, ws: WatchableValueInterface<any>[]) {\n    super();\n    this.f = f;\n    this.ws = ws;\n    for (const w of ws) {\n      this.registerDisposer(w.changed.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport function makeCachedLazyDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ...ws: { [K in keyof T]: WatchableValueInterface<T[K]> }\n) {\n  return new CachedLazyDerivedWatchableValue(f, ws);\n}\n\nexport class CachedWatchableValue<T>\n  extends RefCounted\n  implements WatchableValueInterface<T>\n{\n  changed = new Signal();\n  value: T;\n  constructor(\n    base: WatchableValueInterface<T>,\n    isEqual: (a: T, b: T) => boolean = (a, b) => a === b,\n  ) {\n    super();\n    this.value = base.value;\n    this.registerDisposer(\n      base.changed.add(() => {\n        const newValue = base.value;\n        if (!isEqual(this.value, newValue)) {\n          this.value = newValue;\n          this.changed.dispatch();\n        }\n      }),\n    );\n  }\n}\n\nexport function makeCachedDerivedWatchableValue<U, T extends any[]>(\n  f: (...v: T) => U,\n  ws: { [K in keyof T]: WatchableValueInterface<T[K]> },\n  isEqual?: (a: U, b: U) => boolean,\n) {\n  const derived = new DerivedWatchableValue(f, ws);\n  const cached = new CachedWatchableValue(derived, isEqual);\n  cached.registerDisposer(derived);\n  return cached;\n}\n\nexport class AggregateWatchableValue<T>\n  extends RefCounted\n  implements WatchableValueInterface<T>\n{\n  changed = new NullarySignal();\n  value: T;\n  constructor(\n    getWatchables: (self: RefCounted) => {\n      [k in keyof T]: WatchableValueInterface<T[k]>;\n    },\n  ) {\n    super();\n    const watchables = getWatchables(this);\n    const keys = Object.keys(watchables) as (keyof T)[];\n    const updateValue = () => {\n      const obj = (Array.isArray(watchables) ? [] : {}) as T;\n      for (const k of keys) {\n        obj[k] = watchables[k].value;\n      }\n      this.value = obj;\n      this.changed.dispatch();\n    };\n    updateValue();\n    for (const k of keys) {\n      const watchable = watchables[k];\n      // Ensure a unique function is used each time in case the same watchable is assigned to\n      // multiple properties.\n      this.registerDisposer(watchable.changed.add(() => updateValue()));\n    }\n  }\n}\n\nexport class ComputedWatchableValue<U>\n  extends RefCounted\n  implements WatchableValueInterface<U>\n{\n  get value() {\n    return this.f();\n  }\n  changed = new NullarySignal();\n  constructor(\n    public f: () => U,\n    ...signals: NullarySignal[]\n  ) {\n    super();\n    for (const signal of signals) {\n      this.registerDisposer(signal.add(this.changed.dispatch));\n    }\n  }\n}\n\nexport class WatchableRefCounted<T extends RefCounted>\n  extends RefCounted\n  implements WatchableValueInterface<T | undefined>\n{\n  changed = new NullarySignal();\n\n  private value_: Owned<T> | undefined;\n  private valueHandler: (() => void) | undefined;\n\n  get value(): Borrowed<T> | undefined {\n    return this.value_;\n  }\n\n  set value(value: Owned<T> | undefined) {\n    const { value_ } = this;\n    this.value_ = value;\n    if (value_ !== undefined) {\n      value_.dispose();\n      value_.unregisterDisposer(this.valueHandler!);\n      this.valueHandler = undefined;\n    }\n    if (value !== undefined) {\n      const valueHandler = (this.valueHandler = () => {\n        if (this.value_ === value) {\n          this.value_ = undefined;\n          this.changed.dispatch();\n        }\n      });\n      value.registerDisposer(valueHandler);\n    }\n\n    if (value !== value_) {\n      this.changed.dispatch();\n    }\n  }\n\n  reset() {\n    this.value = undefined;\n  }\n\n  disposed() {\n    if (this.value_ !== undefined) {\n      this.value_.unregisterDisposer(this.valueHandler!);\n      this.value_.dispose();\n    }\n    this.value_ = undefined;\n    super.disposed();\n  }\n}\n\nexport interface TrackableValueInterface<T>\n  extends WatchableValueInterface<T>,\n    Trackable {}\n\nexport class TrackableRefCounted<T extends RefCounted>\n  extends WatchableRefCounted<T>\n  implements TrackableValueInterface<T | undefined>\n{\n  constructor(\n    public validator: (value: any) => T | undefined,\n    public jsonConverter: (value: T) => any,\n  ) {\n    super();\n  }\n  toJSON() {\n    const { value } = this;\n    return value && this.jsonConverter(value);\n  }\n\n  restoreState(x: any) {\n    this.value = this.validator(x);\n  }\n}\n\nexport class WatchableSet<T> {\n  changed = new Signal<(x: T | null, add: boolean) => void>();\n  values: Set<T>;\n  constructor(values?: Iterable<T>) {\n    if (values === undefined) {\n      this.values = new Set();\n    } else {\n      this.values = new Set(values);\n    }\n  }\n  add(x: T) {\n    const { values } = this;\n    if (!values.has(x)) {\n      values.add(x);\n      this.changed.dispatch(x, true);\n    }\n    return this;\n  }\n  delete(x: T) {\n    const { values } = this;\n    if (values.delete(x)) {\n      this.changed.dispatch(x, false);\n      return true;\n    }\n    return false;\n  }\n  has(x: T) {\n    return this.values.has(x);\n  }\n  get size() {\n    return this.values.size;\n  }\n  [Symbol.iterator]() {\n    return this.values[Symbol.iterator]();\n  }\n  clear() {\n    const { values } = this;\n    if (values.size > 0) {\n      values.clear();\n      this.changed.dispatch(null, false);\n    }\n  }\n}\n\nexport interface NestedStateManager<T = undefined> extends Disposable {\n  flush: () => void;\n  value: T;\n}\n\nexport function registerNested<U, T extends any[]>(\n  f: (context: RefCounted, ...values: T) => U,\n  ...watchables: { [K in keyof T]: WatchableValueInterface<T[K]> }\n): NestedStateManager<U> {\n  const values = watchables.map((w) => w.value) as T;\n  const count = watchables.length;\n  let context = new RefCounted();\n  let result = f(context, ...values);\n\n  const handleChange = debounce(() => {\n    let changed = false;\n    for (let i = 0; i < count; ++i) {\n      const watchable = watchables[i];\n      const value = watchable.value;\n      if (values[i] !== value) {\n        values[i] = value;\n        changed = true;\n      }\n    }\n    if (!changed) return;\n    context.dispose();\n    context = new RefCounted();\n    result = f(context, ...values);\n  }, 0);\n\n  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));\n\n  return {\n    flush() {\n      handleChange.flush();\n    },\n    dispose() {\n      handleChange.cancel();\n      invokeDisposers(signalDisposers);\n      context.dispose();\n    },\n    get value() {\n      handleChange.flush();\n      return result;\n    },\n  };\n}\n\nexport function registerNestedSync<U, T extends any[]>(\n  f: (context: RefCounted, ...values: T) => U,\n  ...watchables: { [K in keyof T]: WatchableValueInterface<T[K]> }\n): { readonly value: U; dispose(): void } {\n  const values = watchables.map((w) => w.value) as T;\n  const count = watchables.length;\n  let context = new RefCounted();\n  let result = f(context, ...values);\n\n  const handleChange = () => {\n    let changed = false;\n    for (let i = 0; i < count; ++i) {\n      const watchable = watchables[i];\n      const value = watchable.value;\n      if (values[i] !== value) {\n        values[i] = value;\n        changed = true;\n      }\n    }\n    if (!changed) return;\n    context.dispose();\n    context = new RefCounted();\n    result = f(context, ...values);\n  };\n\n  const signalDisposers = watchables.map((w) => w.changed.add(handleChange));\n\n  return {\n    dispose() {\n      invokeDisposers(signalDisposers);\n      context.dispose();\n    },\n    get value() {\n      return result;\n    },\n  };\n}\n\nexport function constantWatchableValue<T>(\n  value: T,\n): WatchableValueInterface<T> {\n  return { changed: neverSignal, value };\n}\n\nexport function observeWatchable<T>(\n  callback: (value: T) => void,\n  watchable: WatchableValueInterface<T>,\n) {\n  callback(watchable.value);\n  return watchable.changed.add(() => callback(watchable.value));\n}\n\nexport function linkWatchableValue<T>(\n  source: WatchableValueInterface<T>,\n  target: WatchableValueInterface<T>,\n) {\n  target.value = source.value;\n  return source.changed.add(() => {\n    target.value = source.value;\n  });\n}\n\nexport class IndirectWatchableValue<U, T>\n  implements Disposable, WatchableValueInterface<T>\n{\n  protected inner: WatchableValueInterface<T>;\n  changed = new NullarySignal();\n  disposer: (() => void) | undefined;\n  private update = () => {\n    const { disposer, outer } = this;\n    if (disposer !== undefined) {\n      disposer();\n    }\n    const inner = (this.inner = this.getInner(outer.value));\n    this.disposer = inner.changed.add(this.changed.dispatch);\n    this.changed.dispatch();\n  };\n  constructor(\n    private outer: WatchableValueInterface<U>,\n    private getInner: (outer: U) => WatchableValueInterface<T>,\n  ) {\n    outer.changed.add(this.update);\n    this.update();\n  }\n\n  dispose() {\n    this.outer.changed.remove(this.update);\n    this.disposer!();\n  }\n\n  get value() {\n    return this.inner.value;\n  }\n  set value(value: T) {\n    this.inner.value = value;\n  }\n}\n\nexport class IndirectTrackableValue<U, T>\n  extends IndirectWatchableValue<U, T>\n  implements Trackable\n{\n  declare inner: TrackableValueInterface<T>;\n  reset() {\n    this.inner.reset();\n  }\n  restoreState(obj: unknown) {\n    this.inner.restoreState(obj);\n  }\n  toJSON() {\n    return this.inner.toJSON();\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function scopedAbortCallback(\n  signal: AbortSignal | undefined,\n  callback: (reason: any) => void,\n): Disposable | undefined {\n  if (signal === undefined) return undefined;\n  if (signal.aborted) {\n    callback(signal.reason);\n    return undefined;\n  }\n  function wrappedCallback(this: AbortSignal) {\n    callback(this.reason);\n  }\n  signal.addEventListener(\"abort\", wrappedCallback, { once: true });\n  return {\n    [Symbol.dispose]() {\n      signal.removeEventListener(\"abort\", wrappedCallback);\n    },\n  };\n}\n\n// Abort controller that aborts when *all* consumers have aborted.\nexport class SharedAbortController {\n  private consumers = new Map<(this: AbortSignal) => void, AbortSignal>();\n  private controller = new AbortController();\n  private retainCount = 0;\n\n  get signal(): AbortSignal {\n    return this.controller.signal;\n  }\n\n  addConsumer(signal: AbortSignal | undefined): void {\n    if (this.controller.signal.aborted) return undefined;\n    if (signal !== undefined) {\n      if (signal.aborted) return;\n      const self = this;\n      function wrappedCallback(this: AbortSignal) {\n        self.consumers.delete(wrappedCallback);\n        if (--self.retainCount === 0) {\n          self.controller.abort();\n          self[Symbol.dispose]();\n        }\n      }\n      signal.addEventListener(\"abort\", wrappedCallback, { once: true });\n    }\n    ++this.retainCount;\n  }\n\n  [Symbol.dispose](): void {\n    for (const [wrappedCallback, signal] of this.consumers) {\n      signal.removeEventListener(\"abort\", wrappedCallback);\n    }\n    this.consumers.clear();\n    this.retainCount = 0;\n  }\n\n  // Marks this controller as started. Aborts if there are no consumers.\n  start(): void {\n    if (this.retainCount === 0) {\n      this.controller.abort();\n    }\n  }\n}\n\nexport function promiseWithResolversAndAbortCallback<T>(\n  signal: AbortSignal,\n  abortCallback: (reason: any) => void,\n): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: any) => void;\n} {\n  const { promise, resolve, reject } = Promise.withResolvers<T>();\n  const cleanup = scopedAbortCallback(signal, abortCallback);\n  return {\n    promise,\n    resolve: (value: T) => {\n      cleanup?.[Symbol.dispose]();\n      resolve(value);\n    },\n    reject: (reason: any) => {\n      cleanup?.[Symbol.dispose]();\n      reject(reason);\n    },\n  };\n}\n\nexport function raceWithAbort<T>(\n  promise: Promise<T>,\n  signal: AbortSignal | undefined,\n): Promise<T> {\n  if (signal === undefined) return promise;\n  if (signal.aborted) return Promise.reject(signal.reason);\n\n  return new Promise((resolve, reject) => {\n    const cleanup = scopedAbortCallback(signal, (reason) => {\n      reject(reason);\n    });\n    promise.then(\n      (value) => {\n        cleanup?.[Symbol.dispose]();\n        resolve(value);\n      },\n      (reason) => {\n        cleanup?.[Symbol.dispose]();\n        reject(reason);\n      },\n    );\n  });\n}\n\nexport function abortPromise(signal: AbortSignal) {\n  return new Promise((_resolve, reject) => {\n    signal.addEventListener(\n      \"abort\",\n      () => {\n        reject(signal.reason);\n      },\n      { once: true },\n    );\n  });\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bigintCompare(a: bigint, b: bigint) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport function uint64FromLowHigh(low: number, high: number) {\n  return BigInt(low) | (BigInt(high) << 32n);\n}\n\nexport function randomUint64(): bigint {\n  const low = (Math.random() * 0x100000000) >>> 0;\n  const high = (Math.random() * 0x100000000) >>> 0;\n  return uint64FromLowHigh(low, high);\n}\n\nexport function wrapSigned32BitIntegerToUint64(value: number): bigint {\n  return uint64FromLowHigh(value >>> 0, value < 0 ? 0xffffffff : 0);\n}\n\nexport function bigintMin(a: bigint, b: bigint): bigint {\n  return a < b ? a : b;\n}\n\nexport function bigintMax(a: bigint, b: bigint): bigint {\n  return a > b ? a : b;\n}\n\nexport const UINT64_MAX = 0xffffffffffffffffn;\n\nexport function clampToUint64(x: bigint): bigint {\n  if (x < 0n) return 0n;\n  if (x > UINT64_MAX) return UINT64_MAX;\n  return x;\n}\n\nexport function bigintAbs(x: bigint): bigint {\n  return x < 0n ? -x : x;\n}\n\nexport function roundToUint64(x: number | bigint): bigint {\n  if (typeof x === \"number\") {\n    if (x === Number.POSITIVE_INFINITY) return UINT64_MAX;\n    if (!Number.isFinite(x)) return 0n;\n    x = BigInt(Math.round(x));\n  }\n  return clampToUint64(x);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface Disposable {\n  dispose: () => void;\n}\n\nexport type Disposer = Disposable | (() => void);\n\nconst DEBUG_REF_COUNTS = false;\n\nexport function invokeDisposer(disposer: Disposer) {\n  if (typeof disposer === \"object\") {\n    disposer.dispose();\n  } else {\n    disposer();\n  }\n}\n\nexport function invokeDisposers(disposers: Disposer[]) {\n  for (let i = disposers.length; i > 0; --i) {\n    invokeDisposer(disposers[i - 1]);\n  }\n}\n\nexport function registerEventListener(\n  target: EventTarget,\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) {\n  target.addEventListener(type, listener, options);\n  return () => target.removeEventListener(type, listener, options);\n}\n\nexport class RefCounted implements Disposable {\n  public refCount = 1;\n  wasDisposed: boolean | undefined;\n  private disposers: Disposer[];\n  addRef() {\n    ++this.refCount;\n    return this;\n  }\n  disposedStacks: any;\n  dispose() {\n    if (DEBUG_REF_COUNTS) {\n      (this.disposedStacks = this.disposedStacks || []).push(new Error().stack);\n    }\n    if (--this.refCount !== 0) {\n      return;\n    }\n    this.refCountReachedZero();\n  }\n  [Symbol.dispose]() {\n    this.dispose();\n  }\n\n  protected refCountReachedZero() {\n    this.disposed();\n    const { disposers } = this;\n    if (disposers !== undefined) {\n      invokeDisposers(disposers);\n      this.disposers = <any>undefined;\n    }\n    this.wasDisposed = true;\n  }\n  disposed() {}\n  registerDisposer<T extends Disposer>(f: T): T {\n    const { disposers } = this;\n    if (disposers == null) {\n      this.disposers = [f];\n    } else {\n      disposers.push(f);\n    }\n    return f;\n  }\n  unregisterDisposer<T extends Disposer>(f: T): T {\n    const { disposers } = this;\n    if (disposers != null) {\n      const index = disposers.indexOf(f);\n      if (index !== -1) {\n        disposers.splice(index, 1);\n      }\n    }\n    return f;\n  }\n  registerEventListener(\n    target: EventTarget,\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ) {\n    this.registerDisposer(\n      registerEventListener(target, type, listener, options),\n    );\n  }\n  registerCancellable<T extends { cancel: () => void }>(cancellable: T) {\n    this.registerDisposer(() => {\n      cancellable.cancel();\n    });\n    return cancellable;\n  }\n}\n\nexport class RefCountedValue<T> extends RefCounted {\n  constructor(public value: T) {\n    super();\n  }\n}\n\n/**\n * A variable of this type is associated with an increment of the reference count.  If a function\n * parameter is declared with this type, then callers must donate a reference count.\n */\nexport type Owned<T extends Disposable> = T;\n\n/**\n * A variable of this type is not associated with an increment of the reference count.\n */\nexport type Borrowed<T extends Disposable> = T;\n\nexport function disposableOnce(value: Disposer | undefined) {\n  return () => {\n    if (value !== undefined) {\n      const x = value;\n      value = undefined;\n      invokeDisposer(x);\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { mat3, mat4, quat, vec3, vec4 } from \"gl-matrix\";\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport { findMatchingIndices } from \"#src/util/array.js\";\n\nexport { mat2, mat3, mat4, quat, vec2, vec3, vec4 } from \"gl-matrix\";\n\nexport const identityMat4 = mat4.create();\n\nexport const AXES_NAMES = [\"x\", \"y\", \"z\"];\n\nexport const kAxes = [\n  vec3.fromValues(1, 0, 0),\n  vec3.fromValues(0, 1, 0),\n  vec3.fromValues(0, 0, 1),\n];\nexport const kZeroVec = vec3.fromValues(0, 0, 0);\nexport const kZeroVec4 = vec4.fromValues(0, 0, 0, 0);\nexport const kOneVec = vec3.fromValues(1, 1, 1);\nexport const kInfinityVec = vec3.fromValues(Infinity, Infinity, Infinity);\nexport const kIdentityQuat = quat.create();\n\nexport interface OrientedSliceScales {\n  width: { scale: number; unit: string };\n  height: { scale: number; unit: string };\n}\n\nexport function prod3(x: ArrayLike<number>) {\n  return x[0] * x[1] * x[2];\n}\n\nexport function prod4(x: ArrayLike<number>) {\n  return x[0] * x[1] * x[2] * x[3];\n}\n\n/**\n * Implements a one-to-one conversion from Vec3 to string, suitable for use a Map key.\n *\n * Specifically, returns the string representation of the 3 values separated by commas.\n */\nexport function vec3Key(x: ArrayLike<number>) {\n  return `${x[0]},${x[1]},${x[2]}`;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about X, stores result in `out`.\n */\nexport function quatRotateX180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = w;\n  out[1] = z;\n  out[2] = -y;\n  out[3] = -x;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about Y, stores result in `out`.\n */\nexport function quatRotateY180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = -z;\n  out[1] = w;\n  out[2] = x;\n  out[3] = -y;\n}\n\n/**\n * Transforms `a` by a 180-degree rotation about Z, stores result in `out`.\n */\nexport function quatRotateZ180(out: quat, a: quat) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = a[3];\n  out[0] = y;\n  out[1] = -x;\n  out[2] = w;\n  out[3] = -z;\n}\n\n/**\n * Transforms a vector `a` by a homogenous transformation matrix `m`.  The translation component of\n * `m` is ignored.\n */\nexport function transformVectorByMat4(out: vec3, a: vec3, m: mat4) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[4] * y + m[8] * z;\n  out[1] = m[1] * x + m[5] * y + m[9] * z;\n  out[2] = m[2] * x + m[6] * y + m[10] * z;\n  return out;\n}\n\n/**\n * Transforms a vector `a` by the transpose of a homogenous transformation matrix `m`.  The\n * translation component of `m` is ignored.\n */\nexport function transformVectorByMat4Transpose(out: vec3, a: vec3, m: mat4) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[1] * y + m[2] * z;\n  out[1] = m[4] * x + m[5] * y + m[6] * z;\n  out[2] = m[8] * x + m[9] * y + m[10] * z;\n  return out;\n}\n\nexport function translationRotationScaleZReflectionToMat4(\n  out: mat4,\n  translation: vec3,\n  rotation: quat,\n  scale: vec3,\n  zReflection: number,\n) {\n  const temp: Float32Array = out;\n  out[0] = scale[0];\n  out[1] = scale[1];\n  out[2] = scale[2] * zReflection;\n  return mat4.fromRotationTranslationScale(\n    out,\n    rotation,\n    translation,\n    <vec3>temp,\n  );\n}\n\n/**\n * Returns the value of `t` that minimizes `(p - (a + t * (b - a)))`.\n */\nexport function findClosestParameterizedLinePosition(\n  a: Float32Array,\n  b: Float32Array,\n  p: Float32Array,\n) {\n  // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n  // Compute t: -dot(a-p, b-a) / |b - a|^2\n  const rank = p.length;\n  let denominator = 0;\n  for (let i = 0; i < rank; ++i) {\n    denominator += (a[i] - b[i]) ** 2;\n  }\n  let numerator = 0;\n  for (let i = 0; i < rank; ++i) {\n    const aValue = a[i];\n    numerator -= (aValue - p[i]) * (b[i] - aValue);\n  }\n  return numerator / Math.max(denominator, 1e-6);\n}\n\n/**\n * Sets `out` to the position on the line segment `[a, b]` closest to `p`.\n */\nexport function projectPointToLineSegment(\n  out: Float32Array,\n  a: Float32Array,\n  b: Float32Array,\n  p: Float32Array,\n) {\n  const rank = out.length;\n  let t = findClosestParameterizedLinePosition(a, b, p);\n  t = Math.max(0.0, Math.min(1.0, t));\n  for (let i = 0; i < rank; ++i) {\n    const aValue = a[i];\n    out[i] = aValue + t * (b[i] - aValue);\n  }\n  return out;\n}\n\nexport function mat3FromMat4(out: mat3, m: mat4) {\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m10 = m[4];\n  const m11 = m[5];\n  const m12 = m[6];\n  const m20 = m[8];\n  const m21 = m[9];\n  const m22 = m[10];\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Extracts the left, right, bottom, top, near, far clipping planes from `projectionMat`.\n * @param out Row-major array of shape `(6, 4)` specifying for each of the left, right, bottom, top,\n *     near, far clipping planes the `a`, `b`, `c`, `d` coefficients such that\n *     `0 < a * x + b * y + c * z + d` if the point `x, y, z` is inside the half-space of the\n * clipping plane.\n * @param m Projection matrix\n */\nexport function getFrustrumPlanes(out: Float32Array, m: mat4): Float32Array {\n  // http://web.archive.org/web/20120531231005/http://crazyjoke.free.fr/doc/3D/plane%20extraction.pdf\n  const m00 = m[0];\n  const m10 = m[1];\n  const m20 = m[2];\n  const m30 = m[3];\n  const m01 = m[4];\n  const m11 = m[5];\n  const m21 = m[6];\n  const m31 = m[7];\n  const m02 = m[8];\n  const m12 = m[9];\n  const m22 = m[10];\n  const m32 = m[11];\n  const m03 = m[12];\n  const m13 = m[13];\n  const m23 = m[14];\n  const m33 = m[15];\n\n  out[0] = m30 + m00; // left: a\n  out[1] = m31 + m01; // left: b\n  out[2] = m32 + m02; // left: c\n  out[3] = m33 + m03; // left: d\n\n  out[4] = m30 - m00; // right: a\n  out[5] = m31 - m01; // right: b\n  out[6] = m32 - m02; // right: c\n  out[7] = m33 - m03; // right: d\n\n  out[8] = m30 + m10; // bottom: a\n  out[9] = m31 + m11; // bottom: b\n  out[10] = m32 + m12; // bottom: c\n  out[11] = m33 + m13; // bottom: d\n\n  out[12] = m30 - m10; // top: a\n  out[13] = m31 - m11; // top: b\n  out[14] = m32 - m12; // top: c\n  out[15] = m33 - m13; // top: d\n\n  const nearA = m30 + m20; // near: a\n  const nearB = m31 + m21; // near: b\n  const nearC = m32 + m22; // near: c\n  const nearD = m33 + m23; // near: d\n\n  const farA = m30 - m20; // far: a\n  const farB = m31 - m21; // far: b\n  const farC = m32 - m22; // far: c\n  const farD = m33 - m23; // far: d\n\n  // Normalize near plane\n  const nearNorm = Math.sqrt(nearA ** 2 + nearB ** 2 + nearC ** 2);\n  out[16] = nearA / nearNorm;\n  out[17] = nearB / nearNorm;\n  out[18] = nearC / nearNorm;\n  out[19] = nearD / nearNorm;\n\n  // Also normalize far plane\n  const farNorm = Math.sqrt(farA ** 2 + farB ** 2 + farC ** 2);\n  out[20] = farA / farNorm;\n  out[21] = farB / farNorm;\n  out[22] = farC / farNorm;\n  out[23] = farD / farNorm;\n\n  return out;\n}\n\n/**\n * Checks whether the specified axis-aligned bounding box (AABB) intersects the view frustrum.\n *\n * @param clippingPlanes Array of length 24 specifying the clipping planes of the view frustrum, as\n *     computed by `getFrustrumPlanes`\n */\nexport function isAABBVisible(\n  xLower: number,\n  yLower: number,\n  zLower: number,\n  xUpper: number,\n  yUpper: number,\n  zUpper: number,\n  clippingPlanes: Float32Array,\n) {\n  for (let i = 0; i < 6; ++i) {\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const sum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper) +\n      d;\n    if (sum < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isAABBIntersectingPlane(\n  xLower: number,\n  yLower: number,\n  zLower: number,\n  xUpper: number,\n  yUpper: number,\n  zUpper: number,\n  clippingPlanes: Float32Array,\n) {\n  for (let i = 0; i < 4; ++i) {\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const sum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper) +\n      d;\n    if (sum < 0) {\n      return false;\n    }\n  }\n  {\n    const i = 5;\n    const a = clippingPlanes[i * 4];\n    const b = clippingPlanes[i * 4 + 1];\n    const c = clippingPlanes[i * 4 + 2];\n    const d = clippingPlanes[i * 4 + 3];\n    const maxSum =\n      Math.max(a * xLower, a * xUpper) +\n      Math.max(b * yLower, b * yUpper) +\n      Math.max(c * zLower, c * zUpper);\n    const minSum =\n      Math.min(a * xLower, a * xUpper) +\n      Math.min(b * yLower, b * yUpper) +\n      Math.min(c * zLower, c * zUpper);\n    const epsilon = Math.abs(d) * 1e-6;\n    if (minSum > -d + epsilon || maxSum < -d - epsilon) return false;\n  }\n  return true;\n}\n\n/**\n * Returns the list (in sorted order) of input dimensions that depend on any of the specified output\n * dimensions.\n */\nexport function getDependentTransformInputDimensions(\n  transform: Float32Array | Float64Array,\n  rank: number,\n  outputDimensions: readonly number[],\n  transpose = false,\n): number[] {\n  const numOutputDimensions = outputDimensions.length;\n  const isDependentInputDimension: boolean[] = [];\n  const inputStride = transpose ? 1 : rank + 1;\n  const outputStride = transpose ? rank + 1 : 1;\n  for (let i = 0; i < numOutputDimensions; ++i) {\n    const outputDim = outputDimensions[i];\n    for (let inputDim = 0; inputDim < rank; ++inputDim) {\n      if (transform[inputDim * inputStride + outputDim * outputStride] !== 0) {\n        isDependentInputDimension[inputDim] = true;\n      }\n    }\n  }\n  return findMatchingIndices(isDependentInputDimension, true);\n}\n\nexport function scaleMat3Input(\n  out: mat3,\n  input: mat3,\n  scales: TypedNumberArray,\n) {\n  for (let j = 0; j < 3; ++j) {\n    const s = scales[j];\n    for (let i = 0; i < 3; ++i) {\n      out[i + j * 3] = s * input[i + j * 3];\n    }\n  }\n  return out;\n}\n\nexport function scaleMat3Output(\n  out: mat3,\n  input: mat3,\n  scales: TypedNumberArray,\n) {\n  for (let i = 0; i < 3; ++i) {\n    const s = scales[i];\n    for (let j = 0; j < 3; ++j) {\n      out[i + j * 3] = s * input[i + j * 3];\n    }\n  }\n  return out;\n}\n\nexport function getViewFrustrumVolume(projectionMat: mat4) {\n  if (projectionMat[15] === 1) {\n    // orthographic projection\n    const depth = 2 / Math.abs(projectionMat[10]);\n    const width = 2 / Math.abs(projectionMat[0]);\n    const height = 2 / Math.abs(projectionMat[5]);\n    return width * height * depth;\n  }\n  // perspective projection\n  // a = (far + near) / (near - far);\n  // b = 2 * far * near / (near - far);\n  const a = projectionMat[10];\n  const b = projectionMat[14];\n  const near = (2 * b) / (2 * a - 2);\n  const far = ((a - 1) * near) / (a + 1);\n\n  const baseArea = 4 / (projectionMat[0] * projectionMat[5]);\n  return (baseArea / 3) * (Math.abs(far) ** 3 - Math.abs(near) ** 3);\n}\n\nexport function getViewFrustrumDepthRange(projectionMat: mat4) {\n  if (projectionMat[15] === 1) {\n    // orthographic projection\n    const depth = 2 / Math.abs(projectionMat[10]);\n    return depth;\n  }\n  // perspective projection\n  // a = (far + near) / (near - far);\n  // b = 2 * far * near / (near - far);\n  const a = projectionMat[10];\n  const b = projectionMat[14];\n  const near = (2 * b) / (2 * a - 2);\n  const far = ((a - 1) * near) / (a + 1);\n  const depth = Math.abs(far - near);\n  return depth;\n}\n\n// Ensures the z output is 0.  Useful for disabling depth clipping.\nexport function disableZProjection(mat: mat4) {\n  mat[2] = 0;\n  mat[6] = 0;\n  mat[10] = 0;\n  mat[14] = 0;\n  return mat;\n}\n\nconst tempVec3 = vec3.create();\n\n// Determines the bounding box in world coordinates of the view frustrum for a given view-projection\n// matrix.\n//\n// https://gamedev.stackexchange.com/questions/29999/how-do-i-create-a-bounding-frustum-from-a-view-projection-matrix\nexport function getViewFrustrumWorldBounds(\n  invViewProjectionMat: mat4,\n  bounds: Float32Array,\n) {\n  bounds[0] = bounds[1] = bounds[2] = Number.POSITIVE_INFINITY;\n  bounds[3] = bounds[4] = bounds[5] = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < 8; ++i) {\n    tempVec3[0] = 2 * (i & 1) - 1;\n    tempVec3[1] = 2 * ((i >>> 1) & 1) - 1;\n    tempVec3[2] = 2 * ((i >>> 2) & 1) - 1;\n    vec3.transformMat4(tempVec3, tempVec3, invViewProjectionMat);\n    for (let j = 0; j < 3; ++j) {\n      const x = tempVec3[j];\n      bounds[j] = Math.min(bounds[j], x);\n      bounds[j + 3] = Math.max(bounds[j + 3], x);\n    }\n  }\n}\n\nexport function calculateOrientedSliceScales(\n  orientation: quat | undefined,\n  scales: vec3,\n  units: readonly string[],\n  tolerance: number = 1e-6,\n): OrientedSliceScales | null {\n  function nearlyEqualScales(a: number, b: number): boolean {\n    return Math.abs(a - b) / Math.max(a, b) < tolerance;\n  }\n  function extractContributingScales(\n    matrixRow: 0 | 1 | 2,\n  ): { scale: number; unit: string } | null {\n    let contributingScale: number | undefined;\n    let contributingUnit: string | undefined;\n    for (let i = 0; i < 3; ++i) {\n      const index = i + 3 * matrixRow;\n      if (Math.abs(rotationMatrix[index]) > tolerance) {\n        if (contributingUnit === undefined || contributingScale === undefined) {\n          contributingScale = scales[i];\n          contributingUnit = units[i];\n        } else if (\n          contributingUnit !== units[i] ||\n          !nearlyEqualScales(contributingScale, scales[i])\n        )\n          return null;\n      }\n    }\n    if (contributingScale === undefined || contributingUnit === undefined)\n      return null;\n    return { scale: contributingScale, unit: contributingUnit };\n  }\n  if (orientation === undefined) orientation = kIdentityQuat;\n\n  const rotationMatrix = mat3.create();\n  mat3.fromQuat(rotationMatrix, orientation);\n\n  const width = extractContributingScales(0 /* matrixRow */);\n  const height = extractContributingScales(1 /* matrixRow */);\n\n  return width && height ? { width, height } : null;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Detects gzip format based on the 3 magic bytes at the start.\n */\nexport function isGzipFormat(data: ArrayBufferView) {\n  const view = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  return (\n    view.length >= 3 && view[0] === 0x1f && view[1] === 0x8b && view[2] === 0x08\n  );\n}\n\nexport async function decodeGzip(\n  data: ArrayBuffer | ArrayBufferView | Response,\n  format: CompressionFormat,\n  signal?: AbortSignal,\n) {\n  try {\n    const decompressedStream = decodeGzipStream(\n      data instanceof Response ? data : new Response(data),\n      format,\n      signal,\n    );\n    return await new Response(decompressedStream).arrayBuffer();\n  } catch {\n    signal?.throwIfAborted();\n    throw new Error(`Failed to decode ${format}`);\n  }\n}\n\nexport function decodeGzipStream(\n  response: Response,\n  format: CompressionFormat,\n  signal?: AbortSignal,\n): ReadableStream<Uint8Array> {\n  return response.body!.pipeThrough(new DecompressionStream(format), {\n    signal: signal,\n  });\n}\n\n/**\n * Decompress `data` if it is in gzip format, otherwise just return it.\n */\nexport async function maybeDecompressGzip(data: ArrayBuffer | ArrayBufferView) {\n  let byteView: Uint8Array;\n  if (data instanceof ArrayBuffer) {\n    byteView = new Uint8Array(data);\n  } else {\n    byteView = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  }\n  if (isGzipFormat(byteView)) {\n    return new Uint8Array(await decodeGzip(byteView, \"gzip\"));\n  }\n  return byteView;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { WritableArrayLike } from \"#src/util/array.js\";\nimport { UINT64_MAX } from \"#src/util/bigint.js\";\nimport { vec3 } from \"#src/util/geom.js\";\n\nexport function verifyFloat(obj: any): number {\n  const t = typeof obj;\n  if (t === \"number\" || t === \"string\") {\n    const x = parseFloat(\"\" + obj);\n    if (!Number.isNaN(x)) {\n      return x;\n    }\n  }\n  throw new Error(\n    `Expected floating-point number, but received: ${JSON.stringify(obj)}.`,\n  );\n}\n\nexport function verifyFiniteFloat(obj: any): number {\n  const x = verifyFloat(obj);\n  if (Number.isFinite(x)) {\n    return x;\n  }\n  throw new Error(`Expected finite floating-point number, but received: ${x}.`);\n}\n\nexport function verifyFiniteNonNegativeFloat(obj: any): number {\n  const x = verifyFloat(obj);\n  if (Number.isFinite(x) && x >= 0) {\n    return x;\n  }\n  throw new Error(\n    `Expected finite non-negative floating-point number, but received: ${x}.`,\n  );\n}\n\nexport function verifyFinitePositiveFloat(obj: any): number {\n  const x = verifyFiniteFloat(obj);\n  if (x > 0) {\n    return x;\n  }\n  throw new Error(\n    `Expected positive finite floating-point number, but received: ${x}.`,\n  );\n}\n\nexport function makeVerifyNumberInInterval(minValue: number, maxValue: number) {\n  return (obj: any) => {\n    const x = verifyFloat(obj);\n    if (x >= minValue && x <= maxValue) {\n      return x;\n    }\n    throw new Error(\n      `Expected floating-point number in range [${minValue}, ${maxValue}], but received: ${x}.`,\n    );\n  };\n}\n\nexport function parseXYZ<A extends WritableArrayLike<number>>(\n  out: A,\n  obj: any,\n  validator: (x: any) => number = verifyFloat,\n): A {\n  verifyObject(obj);\n  out[0] = out[1] = out[2] = 0;\n  for (const key of Object.keys(obj)) {\n    switch (key) {\n      case \"x\":\n        out[0] = validator(obj[key]);\n        break;\n      case \"y\":\n        out[1] = validator(obj[key]);\n        break;\n      case \"z\":\n        out[2] = validator(obj[key]);\n        break;\n      default:\n        throw new Error(\n          `Expected object to have keys ['x', 'y', 'z'], but received: ${JSON.stringify(\n            obj,\n          )}.`,\n        );\n    }\n  }\n  return out;\n}\n\nexport function parseFiniteVec<U extends WritableArrayLike<number>>(\n  out: U,\n  obj: any[],\n) {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\"Incompatible sizes\");\n  }\n\n  for (let i = 0; i < length; ++i) {\n    if (!Number.isFinite(parseFloat(obj[i]))) {\n      throw new Error(\"Non-finite value.\");\n    }\n  }\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseFloat(obj[i]);\n  }\n  return out;\n}\n\nexport function parseIntVec<U extends WritableArrayLike<number>>(\n  out: U,\n  obj: any,\n) {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\"Incompatible sizes.\");\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const val = parseInt(obj[i], undefined);\n    if (!Number.isInteger(val)) {\n      throw new Error(\"Non-integer value.\");\n    }\n  }\n\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseInt(obj[i], undefined);\n  }\n  return out;\n}\n\n/**\n * Returns a JSON representation of x, with object keys sorted to ensure a\n * consistent result.\n */\nexport function stableStringify(x: any) {\n  if (typeof x === \"object\") {\n    if (x === null) {\n      return \"null\";\n    }\n    if (Array.isArray(x)) {\n      let s = \"[\";\n      const size = x.length;\n      let i = 0;\n      if (i < size) {\n        s += stableStringify(x[i]);\n        while (++i < size) {\n          s += \",\";\n          s += stableStringify(x[i]);\n        }\n      }\n      s += \"]\";\n      return s;\n    }\n    let s = \"{\";\n    const keys = Object.keys(x).sort();\n    let i = 0;\n    const size = keys.length;\n    if (i < size) {\n      let key = keys[i];\n      s += JSON.stringify(key);\n      s += \":\";\n      s += stableStringify(x[key]);\n      while (++i < size) {\n        s += \",\";\n        key = keys[i];\n        s += JSON.stringify(key);\n        s += \":\";\n        s += stableStringify(x[key]);\n      }\n    }\n    s += \"}\";\n    return s;\n  }\n  if (typeof x === \"bigint\") {\n    return x.toString();\n  }\n  return JSON.stringify(x);\n}\n\nfunction swapQuotes(x: string) {\n  return x.replace(/['\"]/g, (s) => {\n    return s === '\"' ? \"'\" : '\"';\n  });\n}\n\nexport function urlSafeStringifyString(x: string) {\n  return swapQuotes(JSON.stringify(swapQuotes(x)));\n}\n\nconst URL_SAFE_COMMA = \"_\";\n\nexport function urlSafeStringify(x: any): string {\n  if (typeof x === \"object\") {\n    if (x === null) {\n      return \"null\";\n    }\n    const toJSON = x.toJSON;\n    if (typeof toJSON === \"function\") {\n      return urlSafeStringify(toJSON.call(x));\n    }\n    if (Array.isArray(x)) {\n      let s = \"[\";\n      const size = x.length;\n      let i = 0;\n      if (i < size) {\n        s += urlSafeStringify(x[i]);\n        while (++i < size) {\n          s += URL_SAFE_COMMA;\n          s += urlSafeStringify(x[i]);\n        }\n      }\n      s += \"]\";\n      return s;\n    }\n    let s = \"{\";\n    const keys = Object.keys(x);\n    let first = true;\n    for (const key of keys) {\n      const value = x[key];\n      if (value === undefined) {\n        continue;\n      }\n      const valueString = urlSafeStringify(value);\n      if (!valueString) {\n        continue;\n      }\n      if (!first) {\n        s += URL_SAFE_COMMA;\n      } else {\n        first = false;\n      }\n      s += urlSafeStringifyString(key);\n      s += \":\";\n      s += valueString;\n    }\n    s += \"}\";\n    return s;\n  }\n  if (typeof x === \"string\") {\n    return urlSafeStringifyString(x);\n  }\n  return JSON.stringify(x);\n}\n\nconst SINGLE_QUOTE_STRING_PATTERN = /('(?:[^'\\\\]|(?:\\\\.))*')/;\nconst DOUBLE_QUOTE_STRING_PATTERN = /(\"(?:[^\"\\\\]|(?:\\\\.))*\")/;\nconst SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN = new RegExp(\n  `${SINGLE_QUOTE_STRING_PATTERN.source}|${DOUBLE_QUOTE_STRING_PATTERN.source}`,\n);\nconst DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN = new RegExp(\n  `${DOUBLE_QUOTE_STRING_PATTERN.source}|${SINGLE_QUOTE_STRING_PATTERN.source}`,\n);\n\nconst DOUBLE_QUOTE_PATTERN = /^((?:[^\"'\\\\]|(?:\\\\[^']))*)(\"|\\\\')/;\nconst SINGLE_QUOTE_PATTERN = /^((?:[^\"'\\\\]|(?:\\\\.))*)'/;\n\nfunction convertStringLiteral(\n  x: string,\n  quoteInitial: string,\n  quoteReplace: string,\n  quoteSearch: RegExp,\n) {\n  if (\n    x.length >= 2 &&\n    x.charAt(0) === quoteInitial &&\n    x.charAt(x.length - 1) === quoteInitial\n  ) {\n    let inner = x.substr(1, x.length - 2);\n    let s = quoteReplace;\n    while (inner.length > 0) {\n      const m = inner.match(quoteSearch);\n      if (m === null) {\n        s += inner;\n        break;\n      }\n      s += m[1];\n      if (m[2] === quoteReplace) {\n        // We received a single unescaped quoteReplace character.\n        s += \"\\\\\";\n        s += quoteReplace;\n      } else {\n        // We received \"\\\\\" + quoteInitial.  We need to remove the escaping.\n        s += quoteInitial;\n      }\n      inner = inner.substr(m.index! + m[0].length);\n    }\n    s += quoteReplace;\n    return s;\n  }\n  return x;\n}\n\n/**\n * Converts a string literal delimited by either single or double quotes into a string literal\n * delimited by double quotes.\n */\nexport function normalizeStringLiteral(x: string) {\n  return convertStringLiteral(x, \"'\", '\"', DOUBLE_QUOTE_PATTERN);\n}\n\n// quoteChar: des\nfunction convertJsonHelper(\n  x: string,\n  desiredCommaChar: string,\n  desiredQuoteChar: string,\n) {\n  const commaSearch = /[&_,]/g;\n  let quoteInitial: string;\n  let quoteSearch: RegExp;\n  let stringLiteralPattern: RegExp;\n  if (desiredQuoteChar === '\"') {\n    quoteInitial = \"'\";\n    quoteSearch = DOUBLE_QUOTE_PATTERN;\n    stringLiteralPattern = SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN;\n  } else {\n    quoteInitial = '\"';\n    quoteSearch = SINGLE_QUOTE_PATTERN;\n    stringLiteralPattern = DOUBLE_OR_SINGLE_QUOTE_STRING_PATTERN;\n  }\n  let s = \"\";\n  while (x.length > 0) {\n    const m = x.match(stringLiteralPattern);\n    let before: string;\n    let replacement: string;\n    if (m === null) {\n      before = x;\n      x = \"\";\n      replacement = \"\";\n    } else {\n      before = x.substr(0, m.index);\n      x = x.substr(m.index! + m[0].length);\n      const originalString = m[1];\n      if (originalString !== undefined) {\n        replacement = convertStringLiteral(\n          originalString,\n          quoteInitial,\n          desiredQuoteChar,\n          quoteSearch,\n        );\n      } else {\n        replacement = m[2];\n      }\n    }\n    s += before.replace(commaSearch, desiredCommaChar);\n    s += replacement;\n  }\n  return s;\n}\n\nexport function urlSafeToJSON(x: string) {\n  return convertJsonHelper(x, \",\", '\"');\n}\n\nexport function jsonToUrlSafe(x: string) {\n  return convertJsonHelper(x, \"_\", \"'\");\n}\n\nexport function urlSafeParse(x: string) {\n  return JSON.parse(urlSafeToJSON(x));\n}\n\n// Converts a string containing a Python literal into a string containing an equivalent JSON\n// literal.\nexport function pythonLiteralToJSON(x: string) {\n  let s = \"\";\n  while (x.length > 0) {\n    const m = x.match(SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN);\n    let before: string;\n    let replacement: string;\n    if (m === null) {\n      before = x;\n      x = \"\";\n      replacement = \"\";\n    } else {\n      before = x.substr(0, m.index);\n      x = x.substr(m.index! + m[0].length);\n      const singleQuoteString = m[1];\n      if (singleQuoteString !== undefined) {\n        replacement = normalizeStringLiteral(singleQuoteString);\n      } else {\n        replacement = m[2];\n      }\n    }\n    s += before\n      .replace(/\\(/g, \"[\")\n      .replace(/\\)/g, \"]\")\n      .replace(\"True\", \"true\")\n      .replace(\"False\", \"false\")\n      .replace(/,\\s*([}\\]])/g, \"$1\");\n    s += replacement;\n  }\n  return s;\n}\n\n// Converts a string containing a Python literal into an equivalent JavaScript value.\nexport function pythonLiteralParse(x: string) {\n  return JSON.parse(pythonLiteralToJSON(x));\n}\n\nexport function expectArray(x: unknown, length?: number): any[] {\n  if (!Array.isArray(x)) {\n    throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);\n  }\n  if (length !== undefined && x.length !== length) {\n    throw new Error(\n      `Expected array of length ${length}, but received: ${JSON.stringify(x)}.`,\n    );\n  }\n  return x;\n}\n\n// Checks that `x' is an array, maps each element by parseElement.\nexport function parseArray<T>(\n  x: any,\n  parseElement: (x: any, index: number) => T,\n): T[] {\n  if (!Array.isArray(x)) {\n    throw new Error(`Expected array, but received: ${JSON.stringify(x)}.`);\n  }\n  return (<any[]>x).map(parseElement);\n}\n\nexport function parseFixedLengthArray<T, U extends WritableArrayLike<T>>(\n  out: U,\n  obj: any,\n  parseElement: (x: any, index: number) => T,\n): U {\n  const length = out.length;\n  if (!Array.isArray(obj) || obj.length !== length) {\n    throw new Error(\n      `Expected length ${length} array, but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  for (let i = 0; i < length; ++i) {\n    out[i] = parseElement(obj[i], i);\n  }\n  return out;\n}\n\nexport function verifyObject(obj: any) {\n  if (typeof obj !== \"object\" || obj == null || Array.isArray(obj)) {\n    throw new Error(\n      `Expected JSON object, but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  return obj;\n}\n\nexport function verifyInt(obj: any) {\n  const result = parseInt(obj, 10);\n  if (!Number.isInteger(result)) {\n    throw new Error(`Expected integer, but received: ${JSON.stringify(obj)}.`);\n  }\n  return result;\n}\n\nexport function verifyPositiveInt(obj: any) {\n  const result = verifyInt(obj);\n  if (result <= 0) {\n    throw new Error(`Expected positive integer, but received: ${result}.`);\n  }\n  return result;\n}\n\nexport function verifyNonnegativeInt(obj: any) {\n  const result = verifyInt(obj);\n  if (result < 0) {\n    throw new Error(`Expected non-negative integer, but received: ${result}.`);\n  }\n  return result;\n}\n\nexport function verifyMapKey<U>(obj: any, map: Map<string, U>) {\n  const result = map.get(obj);\n  if (result === undefined) {\n    throw new Error(\n      `Expected one of ${JSON.stringify(Array.from(map.keys()))}, ` +\n        `but received: ${JSON.stringify(obj)}.`,\n    );\n  }\n  return result;\n}\n\nexport function verifyString(obj: any) {\n  if (typeof obj !== \"string\") {\n    throw new Error(`Expected string, but received: ${JSON.stringify(obj)}.`);\n  }\n  return obj;\n}\n\nexport function verifyOptionalString(obj: any): string | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  return verifyString(obj);\n}\n\nexport function verifyOptionalInt(obj: any): number | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  return verifyInt(obj);\n}\n\nexport function verifyOptionalBoolean(obj: any): boolean | undefined {\n  if (obj === undefined) {\n    return undefined;\n  }\n  if (typeof obj === \"boolean\") {\n    return obj;\n  }\n  if (obj === \"true\") {\n    return true;\n  }\n  if (obj === \"false\") {\n    return false;\n  }\n  throw new Error(\n    `Expected string or boolean but received: ${JSON.stringify(obj)}`,\n  );\n}\n\nexport function valueOr<T>(value: T | undefined, defaultValue: T) {\n  return value === undefined ? defaultValue : value;\n}\n\nexport function verifyObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n): T {\n  const value = Object.prototype.hasOwnProperty.call(obj, propertyName)\n    ? obj[propertyName]\n    : undefined;\n  try {\n    return validator(value);\n  } catch (parseError) {\n    throw new Error(\n      `Error parsing ${JSON.stringify(propertyName)} property: ${\n        parseError.message\n      }`,\n    );\n  }\n}\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n): T | undefined;\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n  defaultValue: T,\n): T;\n\nexport function verifyOptionalObjectProperty<T>(\n  obj: any,\n  propertyName: string,\n  validator: (value: any) => T,\n  defaultValue?: any,\n) {\n  return verifyObjectProperty(obj, propertyName, (x) =>\n    x === undefined ? defaultValue : validator(x),\n  );\n}\n\nexport function verifyObjectAsMap<T>(\n  obj: any,\n  validator: (value: any) => T,\n): Map<string, T> {\n  verifyObject(obj);\n  const map = new Map<string, T>();\n  for (const key of Object.keys(obj)) {\n    try {\n      map.set(key, validator(obj[key]));\n    } catch (parseError) {\n      throw new Error(\n        `Error parsing value associated with key ${JSON.stringify(key)}: ${\n          parseError.message\n        }`,\n      );\n    }\n  }\n  return map;\n}\n\nexport function verifyFloat01(obj: any): number {\n  if (typeof obj !== \"number\" || !Number.isFinite(obj) || obj < 0 || obj > 1) {\n    throw new Error(\n      `Expected floating point number in [0,1], but received: ${JSON.stringify(\n        obj,\n      )}.`,\n    );\n  }\n  return obj;\n}\n\n/**\n * The query string parameters may either be specified in the usual\n * 'name=value&otherName=otherValue' form or as (optionally urlSafe) JSON: '{\"name\":\"value\"}`.\n */\nexport function parseQueryStringParameters(queryString: string) {\n  if (queryString === \"\") {\n    return {};\n  }\n  if (queryString.startsWith(\"{\")) {\n    return urlSafeParse(queryString);\n  }\n  const result: any = {};\n  const parts = queryString.split(/[&;]/);\n  for (const part of parts) {\n    const m = part.match(/^([^=&;]+)=([^&;]*)$/);\n    if (m === null) {\n      throw new Error(`Invalid query string part: ${JSON.stringify(part)}.`);\n    }\n    result[m[1]] = decodeURIComponent(m[2]);\n  }\n  return result;\n}\n\nexport function unparseQueryStringParameters(parameters: any) {\n  if (parameters === undefined) return \"\";\n  const keys = Object.keys(parameters);\n  if (keys.length === 0) return \"\";\n  if (keys.some((key) => typeof parameters[key] !== \"string\")) {\n    return JSON.stringify(parameters);\n  }\n  return keys\n    .map(\n      (key) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(parameters[key])}`,\n    )\n    .join(\"&\");\n}\n\n/**\n * Verifies that `obj' is a string that, when converted to uppercase, matches a string property of\n * `enumType`.\n *\n * @returns The corresponding numerical value.\n */\nexport function verifyEnumString<T extends number>(\n  obj: any,\n  enumType: { [x: string]: T | string },\n  pattern: RegExp = /^[a-zA-Z]/,\n): T {\n  if (typeof obj === \"string\" && obj.match(pattern) !== null) {\n    const objUpperCase = obj.toUpperCase();\n    if (Object.prototype.hasOwnProperty.call(enumType, objUpperCase)) {\n      return enumType[objUpperCase] as T;\n    }\n  }\n  throw new Error(`Invalid enum value: ${JSON.stringify(obj)}.`);\n}\n\nexport function verify3dVec(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyFiniteFloat);\n}\n\nexport function verify3dScale(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyFinitePositiveFloat);\n}\n\nexport function verify3dDimensions(obj: any) {\n  return parseFixedLengthArray(vec3.create(), obj, verifyPositiveInt);\n}\n\nexport function verifyStringArray(a: any) {\n  if (!Array.isArray(a)) {\n    throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);\n  }\n  for (const x of a) {\n    if (typeof x !== \"string\") {\n      throw new Error(`Expected string, received: ${JSON.stringify(x)}.`);\n    }\n  }\n  return <string[]>a;\n}\n\nexport function verifyIntegerArray(a: unknown) {\n  if (!Array.isArray(a)) {\n    throw new Error(`Expected array, received: ${JSON.stringify(a)}.`);\n  }\n  for (const x of a) {\n    if (!Number.isInteger(x)) {\n      throw new Error(`Expected integer, received: ${JSON.stringify(x)}.`);\n    }\n  }\n  return <number[]>a;\n}\n\nexport function verifyBoolean(x: any) {\n  if (typeof x !== \"boolean\") {\n    throw new Error(`Expected boolean, received: ${JSON.stringify(x)}`);\n  }\n  return x;\n}\n\n// If `x` is an empty object/array/string, returns undefined.  Otherwise returns `x`.\nexport function emptyToUndefined(x: any) {\n  for (const _ in x) {\n    return x;\n  }\n  return undefined;\n}\n\nexport function verifyConstant<T>(actual: unknown, expected: T) {\n  if (actual !== expected) {\n    throw new Error(\n      `Expected ${JSON.stringify(expected)}, but received: ${JSON.stringify(\n        actual,\n      )}`,\n    );\n  }\n  return expected;\n}\n\nexport function verifyOptionalFixedLengthArrayOfStringOrNull(\n  obj: unknown,\n  rank: number,\n) {\n  if (obj === undefined) {\n    const array = new Array<string | null>(rank);\n    array.fill(null);\n    return array;\n  }\n  return parseFixedLengthArray(new Array<string | null>(rank), obj, (value) => {\n    if (value !== null && typeof value !== \"string\") {\n      throw new Error(\n        `Expected string or null, but received: ${JSON.stringify(value)}`,\n      );\n    }\n    return value;\n  });\n}\n\nexport function parseUint64(obj: unknown) {\n  let n: bigint;\n  switch (typeof obj) {\n    case \"string\":\n      if (obj.match(/^(?:0|[1-9][0-9]*)$/) === null) {\n        throw new Error(\n          `Expected base-10 number, but received: ${JSON.stringify(obj)}`,\n        );\n      }\n      n = BigInt(obj);\n      break;\n    case \"number\":\n      n = BigInt(obj);\n      break;\n    case \"bigint\":\n      n = obj;\n      break;\n    default:\n      throw new Error(\n        `Expected uint64 value, but received: ${JSON.stringify(obj)}`,\n      );\n  }\n  if (n < 0n || n > UINT64_MAX) {\n    throw new Error(`Expected uint64 value, but received: ${n}`);\n  }\n  return n;\n}\n\nexport function bigintToStringJsonReplacer(_key: unknown, value: unknown) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedNumberArray } from \"#src/util/array.js\";\n\n/**\n * Sets the `m * k` matrix `c` to the product of `m * n` matrix `a` and `n * k` matrix `b`.\n *\n * `a`, `b` and `c` are column-major with column strides of `lda`, `ldb`, and `ldc`, respectively.\n * `c` must not overlap `a` or `b`.\n */\nexport function multiply<T extends TypedNumberArray>(\n  c: T,\n  ldc: number,\n  a: T,\n  lda: number,\n  b: T,\n  ldb: number,\n  m: number,\n  n: number,\n  k: number,\n): T {\n  for (let mIndex = 0; mIndex < m; ++mIndex) {\n    for (let kIndex = 0; kIndex < k; ++kIndex) {\n      let sum = 0;\n      for (let nIndex = 0; nIndex < n; ++nIndex) {\n        sum += a[mIndex + lda * nIndex] * b[nIndex + ldb * kIndex];\n      }\n      c[mIndex + ldc * kIndex] = sum;\n    }\n  }\n  return c;\n}\n\nexport function identity<T extends TypedNumberArray>(\n  a: T,\n  lda: number,\n  n: number,\n): T {\n  for (let i = 0; i < n; ++i) {\n    const start = lda * i;\n    a.fill(0, start, start + n);\n    a[start + i] = 1;\n  }\n  return a;\n}\n\nexport function createIdentity<T extends TypedNumberArray>(\n  c: { new (n: number): T },\n  rows: number,\n  cols: number = rows,\n): T {\n  return identity(new c(rows * cols), rows, Math.min(rows, cols));\n}\n\nexport function createHomogeneousScaleMatrix<T extends TypedNumberArray>(\n  c: { new (length: number): T },\n  scales: ArrayLike<number>,\n  square = true,\n): T {\n  const rank = scales.length;\n  const stride = square ? rank + 1 : rank;\n  const m = new c(stride * (rank + 1));\n  if (square) {\n    m[m.length - 1] = 1;\n  }\n  for (let i = 0; i < rank; ++i) {\n    m[(stride + 1) * i] = scales[i];\n  }\n  return m;\n}\n\nexport function createHomogeneousTranslationMatrix<T extends TypedNumberArray>(\n  c: { new (length: number): T },\n  translation: ArrayLike<number>,\n  square = true,\n): T {\n  const rank = translation.length;\n  const stride = square ? rank + 1 : rank;\n  const m = createIdentity(c, stride, rank + 1);\n  for (let i = 0; i < rank; ++i) {\n    m[stride * rank + i] = translation[i];\n  }\n  return m;\n}\n\nexport function isIdentity<T extends TypedNumberArray>(\n  a: T,\n  lda: number,\n  n: number,\n) {\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < n; ++j) {\n      if (a[i * lda + j] !== (i === j ? 1 : 0)) return false;\n    }\n  }\n  return true;\n}\n\nexport function copy<T extends TypedNumberArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  m: number,\n  n: number,\n): T {\n  for (let col = 0; col < n; ++col) {\n    const aOff = col * lda;\n    const bOff = col * ldb;\n    for (let row = 0; row < m; ++row) {\n      b[bOff + row] = a[aOff + row];\n    }\n  }\n  return b;\n}\n\nexport function extendHomogeneousTransform<T extends TypedNumberArray>(\n  b: T,\n  bRank: number,\n  a: T,\n  aRank: number,\n) {\n  copy(b, bRank + 1, a, aRank + 1, aRank, aRank);\n  for (let i = 0; i < aRank; ++i) {\n    b[(bRank + 1) * bRank + i] = a[(aRank + 1) * aRank + i];\n  }\n  b[b.length - 1] = 1;\n  for (let i = aRank; i < bRank; ++i) {\n    b[(bRank + 1) * i + i] = 1;\n  }\n  return b;\n}\n\nlet pivots: Uint32Array | undefined;\n\n/**\n * Computes the inverse of a square matrix in place, and returns the determinant.\n */\nexport function inverseInplace<T extends TypedNumberArray>(\n  a: T,\n  lda: number,\n  n: number,\n): number {\n  let determinant = 1;\n  // Use Gauss-Jordan elimination with partial pivoting to compute inverse.\n  if (pivots === undefined || pivots.length < n) {\n    pivots = new Uint32Array(n);\n  }\n  for (let i = 0; i < n; ++i) {\n    pivots[i] = i;\n  }\n  for (let k = 0; k < n; ++k) {\n    const kColOff = lda * k;\n    // Find best pivot (row >= `k` with maximum-magnitude element in column `k`).\n    let pivotRow = k;\n    {\n      let bestPivot = Math.abs(a[kColOff + k]);\n      for (let row = k + 1; row < n; ++row) {\n        const mag = Math.abs(a[kColOff + row]);\n        if (mag > bestPivot) {\n          bestPivot = mag;\n          pivotRow = row;\n        }\n      }\n    }\n    // Swap rows `k` and `pivotRow`.\n    if (k !== pivotRow) {\n      determinant *= -1;\n      for (let col = 0; col < n; ++col) {\n        const off = lda * col;\n        const temp = a[off + k];\n        a[off + k] = a[off + pivotRow];\n        a[off + pivotRow] = temp;\n      }\n\n      // Swap `pivots[k]` with `pivots[pivotRow]`.\n      {\n        const tempPivot = pivots[k];\n        pivots[k] = pivots[pivotRow];\n        pivots[pivotRow] = tempPivot;\n      }\n    }\n    // Eliminate.\n    const pivotValue = a[kColOff + k];\n    const pivotInv = 1.0 / pivotValue;\n\n    // Divide row `k` by the pivot element.\n    determinant *= pivotValue;\n    for (let j = 0; j < n; ++j) {\n      a[lda * j + k] *= pivotInv;\n    }\n    // Convert `a(k, k)` to contain the inverse element.\n    a[kColOff + k] = pivotInv;\n\n    // Subtract a suitable multiple of row `k` from all other rows to ensure column `k` becomes `0`.\n    for (let row = 0; row < n; ++row) {\n      if (row === k) continue;\n      const factor = -a[lda * k + row];\n      for (let j = 0; j < n; ++j) {\n        const jColOff = lda * j;\n        a[jColOff + row] += factor * a[jColOff + k];\n      }\n      // Convert element in column `k` to contain the inverse element.\n      a[lda * k + row] = factor * pivotInv;\n    }\n  }\n  // Permute columns back to correct order.\n  for (let col = 0; col < n; ++col) {\n    let targetCol = pivots[col];\n    while (targetCol !== col) {\n      const colOff = lda * col;\n      const targetColOff = lda * targetCol;\n      for (let i = 0; i < n; ++i) {\n        const off1 = colOff + i;\n        const off2 = targetColOff + i;\n        const temp = a[off1];\n        a[off1] = a[off2];\n        a[off2] = temp;\n      }\n      const temp = (pivots[col] = pivots[targetCol]);\n      pivots[targetCol] = targetCol;\n      targetCol = temp;\n    }\n  }\n  return determinant;\n}\n\n/**\n * Computes the inverse and returns the determinant.\n */\nexport function inverse<T extends TypedNumberArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  n: number,\n): number {\n  copy(b, ldb, a, lda, n, n);\n  return inverseInplace(b, ldb, n);\n}\n\nexport function equal<T extends TypedNumberArray>(\n  a: T,\n  lda: number,\n  b: T,\n  ldb: number,\n  m: number,\n  n: number,\n) {\n  for (let j = 0; j < n; ++j) {\n    const offA = lda * j;\n    const offB = ldb * j;\n    for (let i = 0; i < m; ++i) {\n      if (a[offA + i] !== b[offB + i]) return false;\n    }\n  }\n  return true;\n}\n\nexport function transpose<T extends TypedNumberArray>(\n  b: T,\n  ldb: number,\n  a: T,\n  lda: number,\n  m: number,\n  n: number,\n) {\n  for (let i = 0; i < m; ++i) {\n    for (let j = 0; j < n; ++j) {\n      b[j + i * ldb] = a[i + j * lda];\n    }\n  }\n  return b;\n}\n\nexport function transformPoint<\n  Out extends TypedNumberArray,\n  Matrix extends TypedNumberArray,\n  Vector extends TypedNumberArray,\n>(out: Out, mat: Matrix, matrixStride: number, vec: Vector, rank: number): Out {\n  for (let i = 0; i < rank; ++i) {\n    let sum = mat[matrixStride * rank + i];\n    for (let j = 0; j < rank; ++j) {\n      sum += mat[matrixStride * j + i] * vec[j];\n    }\n    out[i] = sum;\n  }\n  return out;\n}\n\nexport function transformVector<\n  Out extends TypedNumberArray,\n  Matrix extends TypedNumberArray,\n  Vector extends TypedNumberArray,\n>(out: Out, mat: Matrix, matrixStride: number, vec: Vector, rank: number): Out {\n  for (let i = 0; i < rank; ++i) {\n    let sum = 0;\n    for (let j = 0; j < rank; ++j) {\n      sum += mat[matrixStride * j + i] * vec[j];\n    }\n    out[i] = sum;\n  }\n  return out;\n}\n\nexport function permuteRows<\n  Output extends TypedNumberArray,\n  Input extends TypedNumberArray,\n>(\n  output: Output,\n  outputStride: number,\n  input: Input,\n  inputStride: number,\n  outputToInputRow: ReadonlyArray<number>,\n  cols: number,\n) {\n  const rows = outputToInputRow.length;\n  for (let outRow = 0; outRow < rows; ++outRow) {\n    const inRow = outputToInputRow[outRow];\n    for (let col = 0; col < cols; ++col) {\n      output[col * outputStride + outRow] = input[col * inputStride + inRow];\n    }\n  }\n  return output;\n}\n\nexport function permuteCols<\n  Output extends TypedNumberArray,\n  Input extends TypedNumberArray,\n>(\n  output: Output,\n  outputStride: number,\n  input: Input,\n  inputStride: number,\n  outputToInputCol: ReadonlyArray<number>,\n  rows: number,\n) {\n  const cols = outputToInputCol.length;\n  for (let outCol = 0; outCol < cols; ++outCol) {\n    const inCol = outputToInputCol[outCol];\n    for (let row = 0; row < rows; ++row) {\n      output[outCol * outputStride + row] = input[inCol * inputStride + row];\n    }\n  }\n  return output;\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type ProgressSpanId = number;\n\nexport interface ProgressSpanOptions {\n  message: string;\n  startTime?: number;\n  id?: ProgressSpanId;\n}\n\nexport class ProgressSpan implements Disposable {\n  id: ProgressSpanId;\n  startTime: number;\n  message: string;\n\n  constructor(\n    public listener: ProgressListener,\n    options: ProgressSpanOptions,\n  ) {\n    const { id = Math.random(), startTime = Date.now(), message } = options;\n    this.id = id;\n    this.startTime = startTime;\n    this.message = message;\n    listener.addSpan(this);\n  }\n\n  [Symbol.dispose]() {\n    this.listener.removeSpan(this.id);\n  }\n}\n\nexport interface ProgressListener {\n  addSpan(span: ProgressSpan): void;\n  removeSpan(spanId: ProgressSpanId): void;\n}\n\nexport class MultiSet<T> {\n  private items = new Map<T, number>();\n  add(item: T): number {\n    const { items } = this;\n    const count = (items.get(item) ?? 0) + 1;\n    items.set(item, count);\n    return count;\n  }\n\n  delete(item: T): number {\n    const { items } = this;\n    let count = items.get(item)!;\n    if (count > 1) {\n      count -= 1;\n      items.set(item, count);\n      return count;\n    }\n    items.delete(item);\n    return 0;\n  }\n\n  has(item: T): boolean {\n    return this.items.has(item);\n  }\n\n  keys() {\n    return this.items.keys();\n  }\n\n  entries() {\n    return this.items.entries();\n  }\n\n  [Symbol.iterator]() {\n    return this.items.keys();\n  }\n}\n\nexport class KeyedMultiSet<T, Key> {\n  private items = new Map<Key, { value: T; count: number }>();\n  constructor(private getKey: (value: T) => Key) {}\n\n  add(item: T): number {\n    const { items } = this;\n    const key = this.getKey(item);\n    const obj = items.get(key);\n    if (obj === undefined) {\n      items.set(key, { value: item, count: 1 });\n      return 1;\n    } else {\n      return (obj.count += 1);\n    }\n  }\n\n  delete(item: T): number {\n    return this.deleteKey(this.getKey(item));\n  }\n\n  deleteKey(key: Key): number {\n    const { items } = this;\n    const obj = items.get(key);\n    if (obj !== undefined && obj.count > 1) {\n      return (obj.count -= 1);\n    }\n    items.delete(key);\n    return 0;\n  }\n\n  has(item: T): boolean {\n    return this.items.has(this.getKey(item));\n  }\n\n  *[Symbol.iterator]() {\n    for (const obj of this.items.values()) {\n      yield obj.value;\n    }\n  }\n}\n\nfunction getId(span: ProgressSpan) {\n  return span.id;\n}\n\nexport class ProgressSpanSet extends KeyedMultiSet<ProgressSpan, number> {\n  constructor() {\n    super(getId);\n  }\n}\n\nexport class MultiConsumerProgressListener implements ProgressListener {\n  private spans = new ProgressSpanSet();\n  private listeners = new MultiSet<ProgressListener>();\n  addSpan(span: ProgressSpan) {\n    if (this.spans.add(span) !== 1) return;\n    for (const listener of this.listeners) {\n      listener.addSpan(span);\n    }\n  }\n\n  removeSpan(spanId: ProgressSpanId) {\n    if (this.spans.deleteKey(spanId) !== 0) return;\n    for (const listener of this.listeners) {\n      listener.removeSpan(spanId);\n    }\n  }\n\n  addListener(listener: ProgressListener | undefined) {\n    if (listener === undefined) return;\n    if (this.listeners.add(listener) !== 1) return;\n    for (const span of this.spans) {\n      listener.addSpan(span);\n    }\n  }\n\n  removeListener(listener: ProgressListener | undefined) {\n    if (listener === undefined) return;\n    if (this.listeners.delete(listener) !== 0) return;\n    for (const span of this.spans) {\n      listener.removeSpan(span.id);\n    }\n  }\n}\n\nexport interface ProgressOptions {\n  signal: AbortSignal;\n  progressListener: ProgressListener;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArray } from \"#src/util/array.js\";\n\nexport function getRandomHexString(numBits = 128) {\n  const numValues = Math.ceil(numBits / 32);\n  const data = new Uint32Array(numValues);\n  crypto.getRandomValues(data);\n  let s = \"\";\n  for (let i = 0; i < numValues; ++i) {\n    s += (\"00000000\" + data[i].toString(16)).slice(-8);\n  }\n  return s;\n}\n\n/**\n * Calls crypto.getRandomValues as many times as needed to fill array.\n */\nexport function getRandomValues<T extends TypedArray>(array: T): T {\n  const byteArray = new Uint8Array(\n    array.buffer,\n    array.byteOffset,\n    array.byteLength,\n  );\n  const blockSize = 65536;\n  for (let i = 0, length = byteArray.length; i < length; i += blockSize) {\n    crypto.getRandomValues(\n      byteArray.subarray(i, Math.min(length, i + blockSize)),\n    );\n  }\n  return array;\n}\n\nexport function getRandomUint32() {\n  const data = new Uint32Array(1);\n  crypto.getRandomValues(data);\n  return data[0];\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Simple signal dispatch mechanism.\n */\n\n/**\n * This class provides a simple signal dispatch mechanism.  Handlers can be added, and then the\n * `dispatch` method calls all of them.\n *\n * If specified, Callable should be an interface containing only a callable signature returning\n * void.  Due to limitations in TypeScript, any interface containing a callable signature will be\n * accepted by the compiler, but the resultant signature of `dispatch` will not be correct.\n */\nexport class Signal<Callable extends Function = () => void> {\n  private handlers = new Set<Callable>();\n\n  /**\n   * Count of number of times this signal has been dispatched.  This is incremented each time\n   * `dispatch` is called prior to invoking the handlers.\n   */\n  count = 0;\n\n  constructor() {\n    const obj = this;\n    this.dispatch = <Callable>(<Function>function (this: any) {\n      ++obj.count;\n      obj.handlers.forEach((handler) => {\n        // eslint-disable-next-line prefer-rest-params\n        handler.apply(this, arguments);\n      });\n    });\n  }\n\n  /**\n   * Add a handler function.  If `dispatch` is currently be called, then the new handler will be\n   * called before `dispatch` returns.\n   *\n   * @param handler The handler function to add.\n   *\n   * @return A function that unregisters the handler.\n   */\n  add(handler: Callable): () => boolean {\n    this.handlers.add(handler);\n    return () => {\n      return this.remove(handler);\n    };\n  }\n\n  addOnce(handler: Callable): void {\n    const { handlers } = this;\n    function onceWrapper(...args: any) {\n      handlers.delete(onceWrapper as any);\n      handler(...args);\n    }\n    handlers.add(onceWrapper as any);\n  }\n\n  /**\n   * Remove a handler function.  If `dispatch` is currently be called and the new handler has not\n   * yet been called, then it will not be called.\n   *\n   * @param handler Handler to remove.\n   * @return `true` if the handler was present, `false` otherwise.\n   */\n  remove(handler: Callable): boolean {\n    return this.handlers.delete(handler);\n  }\n\n  /**\n   * Invokes each handler function with the same parameters (including `this`) with which it is\n   * called.  Handlers are invoked in the order in which they were added.\n   */\n  dispatch: Callable;\n\n  /**\n   * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.\n   */\n  dispose() {\n    this.handlers = <any>undefined;\n  }\n}\n\nexport function observeSignal(\n  callback: () => void,\n  ...signals: {\n    add(callback: () => void): void;\n    remove(callback: () => void): void;\n  }[]\n) {\n  callback();\n  for (let i = 0, count = signals.length; i < count; ++i) {\n    signals[i].add(callback);\n  }\n  return () => {\n    for (let i = 0, count = signals.length; i < count; ++i) {\n      signals[i].remove(callback);\n    }\n  };\n}\n\n/**\n * Simple specialization of Signal for the common case of a nullary handler signature.\n */\nexport class NullarySignal extends Signal<() => void> {}\n\n/**\n * Interface for a signal excluding the dispatch method.\n *\n * Unlike Signal, this interface is covariant in the type of Callable.\n */\nexport interface ReadonlySignal<Callable extends Function> {\n  readonly count: number;\n  add(handler: Callable): () => void;\n  addOnce(handler: Callable): void;\n  remove(handler: Callable): boolean;\n}\n\nexport type NullaryReadonlySignal = ReadonlySignal<() => void>;\n\nexport const neverSignal: NullaryReadonlySignal = {\n  count: 0,\n  add(_handler: any) {\n    return () => {};\n  },\n  addOnce(_handler: any) {},\n  remove(_handler: any) {\n    return false;\n  },\n};\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { RawPartitionedMeshData, RawMeshData } from \"#src/mesh/backend.js\";\n\nlet decodeResult: RawPartitionedMeshData | Error | undefined = undefined;\nlet numPartitions = 0;\n\nlet wasmModule: WebAssembly.Instance | undefined;\n\nconst libraryEnv = {\n  emscripten_notify_memory_growth: (memoryIndex: number) => {\n    memoryIndex;\n  },\n  neuroglancer_draco_receive_decoded_mesh: (\n    numFaces: number,\n    numVertices: number,\n    indicesPointer: number,\n    vertexPositionsPointer: number,\n    subchunkOffsetsPointer: number,\n  ) => {\n    const numIndices = numFaces * 3;\n    const memory = wasmModule!.exports.memory as WebAssembly.Memory;\n    const indices = new Uint32Array(\n      memory.buffer,\n      indicesPointer,\n      numIndices,\n    ).slice();\n    const vertexPositions = new Uint32Array(\n      memory.buffer,\n      vertexPositionsPointer,\n      3 * numVertices,\n    ).slice();\n    const subChunkOffsets = new Uint32Array(\n      memory.buffer,\n      subchunkOffsetsPointer,\n      numPartitions + 1,\n    ).slice();\n    const mesh: RawPartitionedMeshData = {\n      indices,\n      vertexPositions,\n      subChunkOffsets,\n    };\n    decodeResult = mesh;\n  },\n  proc_exit: (code: number) => {\n    throw `proc exit: ${code}`;\n  },\n};\nlet dracoModulePromise: Promise<WebAssembly.Instance> | undefined;\n\nfunction getDracoModulePromise() {\n  if (dracoModulePromise == undefined) {\n    dracoModulePromise = (async () => {\n      const m = (wasmModule = (\n        await WebAssembly.instantiateStreaming(\n          fetch(new URL(\"./neuroglancer_draco.wasm\", import.meta.url)),\n          {\n            env: libraryEnv,\n            wasi_snapshot_preview1: libraryEnv,\n          },\n        )\n      ).instance);\n      (m.exports._initialize as Function)();\n      return m;\n    })();\n  }\n  return dracoModulePromise;\n}\n\nexport async function decodeDracoPartitioned(\n  buffer: Uint8Array,\n  vertexQuantizationBits: number,\n  partition: boolean,\n): Promise<RawPartitionedMeshData> {\n  const m = await getDracoModulePromise();\n  const offset = (m.exports.malloc as Function)(buffer.byteLength);\n  const heap = new Uint8Array((m.exports.memory as WebAssembly.Memory).buffer);\n  heap.set(buffer, offset);\n  numPartitions = partition ? 8 : 1;\n  const code = (m.exports.neuroglancer_draco_decode as Function)(\n    offset,\n    buffer.byteLength,\n    partition,\n    vertexQuantizationBits,\n    true,\n  );\n  if (code === 0) {\n    const r = decodeResult;\n    decodeResult = undefined;\n    if (r instanceof Error) throw r;\n    return r!;\n  }\n  throw new Error(`Failed to decode draco mesh: ${code}`);\n}\n\nexport async function decodeDraco(buffer: Uint8Array): Promise<RawMeshData> {\n  const m = await getDracoModulePromise();\n  const offset = (m.exports.malloc as Function)(buffer.byteLength);\n  const heap = new Uint8Array((m.exports.memory as WebAssembly.Memory).buffer);\n  heap.set(buffer, offset);\n  const code = (m.exports.neuroglancer_draco_decode as Function)(\n    offset,\n    buffer.byteLength,\n    false,\n    0,\n    false,\n  );\n  if (code === 0) {\n    const r = decodeResult;\n    decodeResult = undefined;\n    if (r instanceof Error) throw r;\n    r!.vertexPositions = new Float32Array(r!.vertexPositions.buffer);\n    return r!;\n  }\n  throw new Error(`Failed to decode draco mesh: ${code}`);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum ChunkState {\n  // Chunk is stored in GPU memory in addition to system memory.\n  GPU_MEMORY = 0,\n  // Chunk is stored only in system memory but not in GPU memory.\n  SYSTEM_MEMORY = 1,\n\n  // Chunk is stored in system memory on worker.\n  SYSTEM_MEMORY_WORKER = 2,\n\n  // Chunk is downloading.\n  DOWNLOADING = 3,\n  // Chunk is not yet downloading.\n  QUEUED = 4,\n\n  // Chunk has just been added.\n  NEW = 5,\n\n  // Download failed.\n  FAILED = 6,\n\n  EXPIRED = 7,\n\n  // If new states are added, keep numChangeStates in sync.\n}\n\nexport const numChunkStates = 8;\n\nexport enum ChunkPriorityTier {\n  FIRST_TIER = 0,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  FIRST_ORDERED_TIER = 0,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  VISIBLE = 0,\n  PREFETCH = 1,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  LAST_ORDERED_TIER = 1,\n  RECENT = 2,\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n  LAST_TIER = 2,\n}\n\nexport const numChunkPriorityTiers = 3;\n\nexport enum ChunkDownloadStatistics {\n  totalTime = 0,\n  totalChunks = 1,\n}\n\nexport enum ChunkMemoryStatistics {\n  numChunks = 0,\n  systemMemoryBytes = 1,\n  gpuMemoryBytes = 2,\n}\n\nexport const numChunkMemoryStatistics = 3;\n\nexport const numChunkDownloadStatistics = 2;\n\nexport const numChunkStatistics =\n  numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics +\n  numChunkDownloadStatistics;\n\nexport function getChunkStateStatisticIndex(\n  state: ChunkState,\n  priorityTier: ChunkPriorityTier,\n) {\n  return state * numChunkPriorityTiers + priorityTier;\n}\n\nexport function getChunkDownloadStatisticIndex(\n  statistic: ChunkDownloadStatistics,\n) {\n  return (\n    numChunkStates * numChunkPriorityTiers * numChunkMemoryStatistics +\n    statistic\n  );\n}\n\nexport const PREFETCH_PRIORITY_MULTIPLIER = 1e13;\n\nexport const CHUNK_QUEUE_MANAGER_RPC_ID = \"ChunkQueueManager\";\nexport const CHUNK_MANAGER_RPC_ID = \"ChunkManager\";\nexport const CHUNK_SOURCE_INVALIDATE_RPC_ID = \"ChunkSource.invalidate\";\n\nexport const REQUEST_CHUNK_STATISTICS_RPC_ID =\n  \"ChunkQueueManager.requestChunkStatistics\";\n\n// Used for sending per-layer visible/prefetch chunk statistics from backend to frontend.\nexport const CHUNK_LAYER_STATISTICS_RPC_ID =\n  \"ChunkManager.chunkLayerStatistics\";\n\nexport interface ChunkSourceParametersConstructor<T> {\n  new (): T;\n  RPC_ID: string;\n}\n\nexport class LayerChunkProgressInfo {\n  numVisibleChunksNeeded = 0;\n  numVisibleChunksAvailable = 0;\n  numPrefetchChunksNeeded = 0;\n  numPrefetchChunksAvailable = 0;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CoordinateSpace,\n  DimensionId,\n} from \"#src/coordinate_transform.js\";\nimport {\n  clampAndRoundCoordinateToVoxelCenter,\n  dimensionNamesFromJson,\n  emptyInvalidCoordinateSpace,\n  getBoundingBoxCenter,\n  getCenterBound,\n} from \"#src/coordinate_transform.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { arraysEqual } from \"#src/util/array.js\";\nimport type { Borrowed, Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { mat3, mat4, quat, vec3 } from \"#src/util/geom.js\";\nimport {\n  parseArray,\n  parseFiniteVec,\n  verifyBoolean,\n  verifyEnumString,\n  verifyFiniteFloat,\n  verifyFinitePositiveFloat,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n} from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\nimport { optionallyRestoreFromJsonMember } from \"#src/util/trackable.js\";\nimport { TrackableEnum } from \"#src/util/trackable_enum.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport enum NavigationLinkType {\n  LINKED = 0,\n  RELATIVE = 1,\n  UNLINKED = 2,\n}\n\nexport enum NavigationSimpleLinkType {\n  LINKED = 0,\n  UNLINKED = 2,\n}\n\nexport class TrackableNavigationLink extends TrackableEnum<NavigationLinkType> {\n  constructor(value = NavigationLinkType.LINKED) {\n    super(NavigationLinkType, value);\n  }\n}\n\nexport class TrackableNavigationSimpleLink extends TrackableEnum<NavigationSimpleLinkType> {\n  constructor(value = NavigationSimpleLinkType.LINKED) {\n    super(NavigationSimpleLinkType, value);\n  }\n}\n\nconst tempVec3 = vec3.create();\nconst tempQuat = quat.create();\n\nfunction makeLinked<\n  T extends RefCounted & { changed: NullarySignal },\n  Difference,\n>(\n  self: T,\n  peer: T,\n  link: TrackableNavigationLink,\n  operations: {\n    assign: (target: T, source: T) => void;\n    isValid: (a: T) => boolean;\n    difference: (a: T, b: T) => Difference;\n    add: (target: T, source: T, amount: Difference) => void;\n    subtract: (target: T, source: T, amount: Difference) => void;\n  },\n): T {\n  let updatingSelf = false;\n  const updatingPeer = false;\n  let selfMinusPeer: Difference | undefined;\n  self.registerDisposer(peer);\n  const handlePeerUpdate = () => {\n    if (updatingPeer) {\n      return;\n    }\n    updatingSelf = true;\n    switch (link.value) {\n      case NavigationLinkType.UNLINKED:\n        if (operations.isValid(self)) {\n          break;\n        }\n      // fallthrough\n      case NavigationLinkType.LINKED:\n        operations.assign(self, peer);\n        break;\n      case NavigationLinkType.RELATIVE:\n        operations.add(self, peer, selfMinusPeer!);\n        break;\n    }\n    updatingSelf = false;\n  };\n  const handleSelfUpdate = () => {\n    if (updatingSelf) {\n      return;\n    }\n    switch (link.value) {\n      case NavigationLinkType.UNLINKED:\n        break;\n      case NavigationLinkType.LINKED:\n        operations.assign(peer, self);\n        break;\n      case NavigationLinkType.RELATIVE:\n        operations.subtract(peer, self, selfMinusPeer!);\n        break;\n    }\n  };\n  let previousLinkValue = NavigationLinkType.UNLINKED;\n  const handleLinkUpdate = () => {\n    const linkValue = link.value;\n    if (linkValue !== previousLinkValue) {\n      switch (linkValue) {\n        case NavigationLinkType.UNLINKED:\n          selfMinusPeer = undefined;\n          break;\n        case NavigationLinkType.LINKED:\n          selfMinusPeer = undefined;\n          operations.assign(self, peer);\n          break;\n        case NavigationLinkType.RELATIVE:\n          selfMinusPeer = operations.difference(self, peer);\n          break;\n      }\n    }\n    previousLinkValue = linkValue;\n    self.changed.dispatch();\n  };\n  self.registerDisposer(self.changed.add(handleSelfUpdate));\n  self.registerDisposer(peer.changed.add(handlePeerUpdate));\n  self.registerDisposer(link.changed.add(handleLinkUpdate));\n  handleLinkUpdate();\n  return self;\n}\n\nfunction makeSimpleLinked<T extends RefCounted & { changed: NullarySignal }>(\n  self: T,\n  peer: T,\n  link: TrackableNavigationSimpleLink,\n  operations: {\n    assign: (target: T, source: T) => void;\n    isValid: (a: T) => boolean;\n  },\n) {\n  return makeLinked(self, peer, link as any, operations as any);\n}\n\nexport class Position extends RefCounted {\n  private coordinates_: Float32Array = vector.kEmptyFloat32Vec;\n  private curCoordinateSpace: CoordinateSpace | undefined;\n  changed = new NullarySignal();\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      coordinateSpace.changed.add(() => {\n        this.handleCoordinateSpaceChanged();\n      }),\n    );\n  }\n\n  get valid() {\n    return this.coordinateSpace.value.valid;\n  }\n\n  /**\n   * Returns the position in voxels.\n   */\n  get value() {\n    this.handleCoordinateSpaceChanged();\n    return this.coordinates_;\n  }\n\n  reset() {\n    this.curCoordinateSpace = undefined;\n    this.coordinates_ = vector.kEmptyFloat32Vec;\n    this.changed.dispatch();\n  }\n\n  set value(coordinates: Float32Array) {\n    const { curCoordinateSpace } = this;\n    if (\n      curCoordinateSpace === undefined ||\n      !curCoordinateSpace.valid ||\n      curCoordinateSpace.rank !== coordinates.length\n    ) {\n      return;\n    }\n    const { coordinates_ } = this;\n    coordinates_.set(coordinates);\n    this.changed.dispatch();\n  }\n\n  private handleCoordinateSpaceChanged() {\n    const coordinateSpace = this.coordinateSpace.value;\n    const prevCoordinateSpace = this.curCoordinateSpace;\n    if (coordinateSpace === prevCoordinateSpace) return;\n    this.curCoordinateSpace = coordinateSpace;\n    const { rank } = coordinateSpace;\n    if (!coordinateSpace.valid) return;\n    if (prevCoordinateSpace === undefined || !prevCoordinateSpace.valid) {\n      let { coordinates_ } = this;\n      if (coordinates_ !== undefined && coordinates_.length === rank) {\n        // Use the existing voxel coordinates if rank is the same.  Otherwise, ignore.\n      } else {\n        coordinates_ = this.coordinates_ = new Float32Array(rank);\n        getBoundingBoxCenter(coordinates_, coordinateSpace.bounds);\n        const { voxelCenterAtIntegerCoordinates } = coordinateSpace.bounds;\n        for (let i = 0; i < rank; ++i) {\n          if (voxelCenterAtIntegerCoordinates[i]) {\n            coordinates_[i] = Math.round(coordinates_[i]);\n          } else {\n            coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;\n          }\n        }\n      }\n      this.changed.dispatch();\n      return;\n    }\n    // Match dimensions by ID.\n    const newCoordinates = new Float32Array(rank);\n    const prevCoordinates = this.coordinates_;\n    const { ids, scales: newScales } = coordinateSpace;\n    const { ids: prevDimensionIds, scales: oldScales } = prevCoordinateSpace;\n    for (let newDim = 0; newDim < rank; ++newDim) {\n      const newDimId = ids[newDim];\n      const oldDim = prevDimensionIds.indexOf(newDimId);\n      if (oldDim === -1) {\n        newCoordinates[newDim] = getCenterBound(\n          coordinateSpace.bounds.lowerBounds[newDim],\n          coordinateSpace.bounds.upperBounds[newDim],\n        );\n      } else {\n        newCoordinates[newDim] =\n          prevCoordinates[oldDim] * (oldScales[oldDim] / newScales[newDim]);\n      }\n    }\n    this.coordinates_ = newCoordinates;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    if (!this.valid && this.coordinates_.length === 0) return undefined;\n    this.handleCoordinateSpaceChanged();\n    const { value } = this;\n    if (value.length === 0) return undefined;\n    return Array.from(value);\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    this.curCoordinateSpace = undefined;\n    this.coordinates_ = Float32Array.from(parseArray(obj, verifyFiniteFloat));\n    this.handleCoordinateSpaceChanged();\n    this.changed.dispatch();\n  }\n\n  snapToVoxel() {\n    this.handleCoordinateSpaceChanged();\n    const {\n      bounds: { voxelCenterAtIntegerCoordinates },\n    } = this.coordinateSpace.value;\n    const { coordinates_ } = this;\n    const rank = coordinates_.length;\n    for (let i = 0; i < rank; ++i) {\n      if (voxelCenterAtIntegerCoordinates[i]) {\n        coordinates_[i] = Math.round(coordinates_[i]);\n      } else {\n        coordinates_[i] = Math.floor(coordinates_[i]) + 0.5;\n      }\n    }\n    this.changed.dispatch();\n  }\n\n  assign(other: Borrowed<Position>) {\n    other.handleCoordinateSpaceChanged();\n    const { curCoordinateSpace, coordinates_ } = other;\n    this.curCoordinateSpace = curCoordinateSpace;\n    this.coordinates_ = Float32Array.from(coordinates_);\n    this.changed.dispatch();\n  }\n\n  /**\n   * Get the offset of `a` relative to `b`.\n   */\n  static getOffset(a: Position, b: Position): Float32Array | undefined {\n    const aCoordinates = a.coordinates_;\n    const bCoordinates = b.coordinates_;\n    const rank = aCoordinates.length;\n    if (rank === bCoordinates.length) {\n      return vector.subtract(\n        new Float32Array(aCoordinates.length),\n        aCoordinates,\n        bCoordinates,\n      );\n    }\n    return undefined;\n  }\n  static addOffset(\n    target: Position,\n    source: Position,\n    offset: Float32Array | undefined,\n    scale = 1,\n  ): void {\n    target.handleCoordinateSpaceChanged();\n    const { value: sourceCoordinates } = source;\n    if (offset !== undefined && sourceCoordinates.length === offset.length) {\n      vector.scaleAndAdd(target.value, sourceCoordinates, offset, scale);\n      target.changed.dispatch();\n    }\n  }\n\n  get legacyJsonView() {\n    const self = this;\n    return {\n      changed: self.changed,\n      toJSON() {\n        return self.toJSON();\n      },\n      reset() {\n        self.reset();\n      },\n      restoreState(obj: unknown) {\n        if (obj === undefined || Array.isArray(obj)) {\n          self.restoreState(obj);\n          return;\n        }\n        verifyObject(obj);\n        optionallyRestoreFromJsonMember(obj, \"voxelCoordinates\", self);\n      },\n    };\n  }\n}\n\nexport enum VelocityBoundaryBehavior {\n  STOP = 0,\n  LOOP = 1,\n  REVERSE = 2,\n}\n\nexport const DEFAULT_PLAYBACK_VELOCITY = 10;\n\nexport class DimensionPlaybackVelocity {\n  // Velocity in global coordinates per second.\n  velocity: number = DEFAULT_PLAYBACK_VELOCITY;\n  atBoundary: VelocityBoundaryBehavior = VelocityBoundaryBehavior.REVERSE;\n  paused = true;\n}\n\nexport function dimensionVelocitiesEqual(\n  a: DimensionPlaybackVelocity,\n  b: DimensionPlaybackVelocity,\n): boolean {\n  return (\n    a.velocity === b.velocity &&\n    a.atBoundary === b.atBoundary &&\n    a.paused === b.paused\n  );\n}\n\nfunction dimensionVelocityFromJson(obj: unknown) {\n  verifyObject(obj);\n  return {\n    velocity: verifyOptionalObjectProperty(\n      obj,\n      \"velocity\",\n      verifyFiniteFloat,\n      DEFAULT_PLAYBACK_VELOCITY,\n    ),\n    atBoundary: verifyOptionalObjectProperty(\n      obj,\n      \"atBoundary\",\n      (value) => verifyEnumString(value, VelocityBoundaryBehavior),\n      VelocityBoundaryBehavior.STOP,\n    ),\n    paused: verifyOptionalObjectProperty(obj, \"paused\", verifyBoolean, true),\n  };\n}\n\nfunction dimensionVelocityToJson(info: DimensionPlaybackVelocity) {\n  const { velocity, atBoundary, paused } = info;\n  return {\n    velocity: velocity,\n    atBoundary:\n      atBoundary === VelocityBoundaryBehavior.STOP\n        ? undefined\n        : VelocityBoundaryBehavior[atBoundary].toLowerCase(),\n    paused: paused ? undefined : false,\n  };\n}\n\nexport class CoordinateSpacePlaybackVelocity extends RefCounted {\n  private velocities_: (Readonly<DimensionPlaybackVelocity> | undefined)[];\n  private curCoordinateSpace: CoordinateSpace | undefined;\n  changed = new NullarySignal();\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      coordinateSpace.changed.add(() => {\n        this.handleCoordinateSpaceChanged();\n      }),\n    );\n    this.curCoordinateSpace = coordinateSpace.value;\n    this.velocities_ = new Array(this.curCoordinateSpace?.rank ?? 0);\n  }\n\n  get valid() {\n    return this.coordinateSpace.value.valid;\n  }\n\n  get value(): (Readonly<DimensionPlaybackVelocity> | undefined)[] {\n    this.handleCoordinateSpaceChanged();\n    return this.velocities_;\n  }\n\n  set value(velocities: (Readonly<DimensionPlaybackVelocity> | undefined)[]) {\n    const { curCoordinateSpace } = this;\n    if (\n      curCoordinateSpace === undefined ||\n      curCoordinateSpace.rank !== velocities.length\n    ) {\n      return;\n    }\n    this.velocities_ = velocities;\n    this.changed.dispatch();\n  }\n\n  get(id: DimensionId): DimensionPlaybackVelocity | undefined {\n    const ids = this.coordinateSpace.value?.ids;\n    if (ids === undefined) return;\n    const index = ids.indexOf(id);\n    if (index === -1) return;\n    const velocities = this.value;\n    return velocities[index];\n  }\n\n  dimensionVelocity(\n    owner: RefCounted,\n    id: DimensionId,\n  ): WatchableValueInterface<DimensionPlaybackVelocity | undefined> {\n    const changed = new NullarySignal();\n    let index = -1;\n    const updateIndex = () => {\n      const ids = this.coordinateSpace.value?.ids;\n      if (ids === undefined) {\n        index = -1;\n      } else if (index === -1 || ids[index] !== id) {\n        index = ids.indexOf(id);\n      }\n    };\n    const getVelocity = () => {\n      updateIndex();\n      if (index === -1) return undefined;\n      return this.value[index];\n    };\n    const setVelocity = (\n      newVelocity: Readonly<DimensionPlaybackVelocity> | undefined,\n    ) => {\n      updateIndex();\n      if (index === -1) return;\n      const velocities = this.value;\n      const oldVelocity = velocities[index];\n      if (oldVelocity === newVelocity) return;\n      velocities[index] = newVelocity;\n      this.changed.dispatch();\n    };\n    let prevVelocity = getVelocity();\n    owner.registerDisposer(\n      this.changed.add(() => {\n        const curVelocity = getVelocity();\n        if (curVelocity !== prevVelocity) {\n          prevVelocity = curVelocity;\n          changed.dispatch();\n        }\n      }),\n    );\n    return {\n      get value() {\n        return getVelocity();\n      },\n      set value(newVelocity: Readonly<DimensionPlaybackVelocity> | undefined) {\n        setVelocity(newVelocity);\n      },\n      changed,\n    };\n  }\n\n  modifyDimension(\n    id: DimensionId,\n    callback: (\n      oldInfo: DimensionPlaybackVelocity | undefined,\n    ) => DimensionPlaybackVelocity | undefined,\n  ) {\n    const ids = this.coordinateSpace.value?.ids;\n    if (ids === undefined) return;\n    const index = ids.indexOf(id);\n    if (index === -1) return;\n    const velocities = this.value;\n    const oldInfo = velocities[index];\n    const newInfo = callback(oldInfo);\n    if (oldInfo === newInfo) return;\n    velocities[index] = newInfo;\n    this.changed.dispatch();\n  }\n\n  togglePlayback(id: DimensionId, newValue: boolean | undefined = undefined) {\n    this.modifyDimension(id, (oldInfo = new DimensionPlaybackVelocity()) => {\n      return { ...oldInfo, paused: newValue ?? !oldInfo.paused };\n    });\n  }\n\n  playbackEnabled(id: DimensionId): WatchableValueInterface<boolean> {\n    const self = this;\n    return {\n      changed: this.changed,\n      get value() {\n        return self.get(id) !== undefined;\n      },\n      set value(enabled: boolean) {\n        self.modifyDimension(id, (oldInfo) =>\n          enabled ? (oldInfo ?? new DimensionPlaybackVelocity()) : undefined,\n        );\n      },\n    };\n  }\n\n  multiplyVelocity(id: DimensionId, factor: number) {\n    this.modifyDimension(id, (oldInfo = new DimensionPlaybackVelocity()) => {\n      let newVelocity = Math.round(oldInfo.velocity * factor);\n      if (newVelocity === 0) {\n        newVelocity = Math.sign(oldInfo.velocity) || 1;\n      }\n      return { ...oldInfo, velocity: newVelocity };\n    });\n  }\n\n  private handleCoordinateSpaceChanged() {\n    const coordinateSpace = this.coordinateSpace.value;\n    const prevCoordinateSpace = this.curCoordinateSpace;\n    if (coordinateSpace === prevCoordinateSpace) return;\n    this.curCoordinateSpace = coordinateSpace;\n    const { rank } = coordinateSpace;\n    if (!coordinateSpace.valid) return;\n    if (prevCoordinateSpace === undefined) {\n      let { velocities_ } = this;\n      if (velocities_.length === rank) {\n        // Use the existing velocities if rank is the same.  Otherwise, ignore.\n      } else {\n        velocities_ = new Array<\n          Readonly<DimensionPlaybackVelocity> | undefined\n        >(rank);\n      }\n      this.changed.dispatch();\n      return;\n    }\n    // Match dimensions by ID.\n    const newVelocities = new Array<\n      Readonly<DimensionPlaybackVelocity> | undefined\n    >(rank);\n    const prevVelocities = this.velocities_;\n    const { ids } = coordinateSpace;\n    const { ids: prevDimensionIds } = prevCoordinateSpace;\n    for (let newDim = 0; newDim < rank; ++newDim) {\n      const newDimId = ids[newDim];\n      const oldDim = prevDimensionIds.indexOf(newDimId);\n      if (oldDim !== -1) {\n        newVelocities[newDim] = prevVelocities[oldDim];\n      }\n    }\n    this.velocities_ = newVelocities;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    this.handleCoordinateSpaceChanged();\n    const { velocities_: velocities, curCoordinateSpace } = this;\n    if (\n      !curCoordinateSpace?.valid ||\n      !velocities.some((velocity) => velocity !== undefined)\n    ) {\n      return undefined;\n    }\n    const obj: Record<string, any> = {};\n    const { names, rank } = curCoordinateSpace;\n    for (let i = 0; i < rank; ++i) {\n      const info = velocities[i];\n      if (info === undefined) continue;\n      obj[names[i]] = dimensionVelocityToJson(info);\n    }\n    return obj;\n  }\n\n  reset() {\n    this.handleCoordinateSpaceChanged();\n    this.velocities_ = new Array(this.curCoordinateSpace?.rank ?? 0);\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    verifyObject(obj);\n    const curCoordinateSpace = (this.curCoordinateSpace =\n      this.coordinateSpace.value);\n    this.velocities_ = new Array(curCoordinateSpace?.rank ?? 0);\n    if (curCoordinateSpace === undefined) {\n      throw new Error(\"Must specify dimensions in order to specify velocities\");\n    }\n    const velocities = (this.velocities_ = new Array(\n      curCoordinateSpace?.rank ?? 0,\n    ));\n    const { names } = curCoordinateSpace;\n    for (const key of Object.keys(obj)) {\n      const i = names.indexOf(key);\n      if (i === -1) {\n        throw new Error(`Invalid dimension name: ${JSON.stringify(key)}`);\n      }\n      velocities[i] = verifyObjectProperty(obj, key, dimensionVelocityFromJson);\n    }\n    this.changed.dispatch();\n  }\n\n  assign(other: Borrowed<CoordinateSpacePlaybackVelocity>) {\n    const otherVelocities = other.value;\n    const velocities = this.value;\n    const rank = velocities.length;\n    let changed = false;\n    for (let i = 0; i < rank; ++i) {\n      const newVelocity = otherVelocities[i];\n      const curVelocity = velocities[i];\n      if (newVelocity !== curVelocity) {\n        if (\n          curVelocity === undefined ||\n          newVelocity === undefined ||\n          !dimensionVelocitiesEqual(curVelocity, newVelocity)\n        ) {\n          changed = true;\n        }\n        velocities[i] = newVelocity;\n      }\n    }\n    if (changed) {\n      this.changed.dispatch();\n    }\n  }\n}\n\nexport class LinkedCoordinateSpacePlaybackVelocity extends RefCounted {\n  changed = new NullarySignal();\n  velocity: CoordinateSpacePlaybackVelocity;\n\n  constructor(\n    public peer: Owned<CoordinateSpacePlaybackVelocity>,\n    public positionLink: TrackableLinkInterface,\n  ) {\n    super();\n    this.velocity = this.registerDisposer(\n      new CoordinateSpacePlaybackVelocity(peer.coordinateSpace),\n    );\n\n    this.registerDisposer(peer);\n    this.velocity.changed.add(() => {\n      if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n        this.changed.dispatch();\n      } else {\n        this.peer.assign(this.velocity);\n      }\n    });\n    const updateSelf = () => {\n      if (this.positionLink.value !== NavigationLinkType.UNLINKED) {\n        this.velocity.assign(this.peer);\n      }\n    };\n    this.registerDisposer(peer.changed.add(updateSelf));\n    updateSelf();\n  }\n\n  toJSON() {\n    if (this.positionLink.value !== NavigationLinkType.UNLINKED) {\n      return undefined;\n    }\n    return this.velocity.toJSON();\n  }\n\n  reset() {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.velocity.reset();\n    }\n  }\n\n  restoreState(obj: unknown) {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.velocity.restoreState(obj);\n    }\n  }\n\n  copyToPeer() {\n    if (this.positionLink.value === NavigationLinkType.UNLINKED) {\n      this.peer.assign(this.velocity);\n    }\n  }\n}\n\ninterface DimensionPlaybackState {\n  dimensionIndex: number;\n  prevCoordinate: number;\n  prevTime: number;\n  generation: number;\n}\n\nexport class PlaybackManager extends RefCounted {\n  private dimensionStates = new Map<DimensionId, DimensionPlaybackState>();\n  private lastUpdateGeneration = 0;\n  private unregisterUpdateStartedCallback: (() => void) | undefined;\n\n  constructor(\n    public display: { updateStarted: NullarySignal; scheduleRedraw(): void },\n    public position: Position,\n    public velocity: CoordinateSpacePlaybackVelocity,\n  ) {\n    super();\n    this.handleVelocityChanged();\n    this.registerDisposer(\n      velocity.changed.add(() => this.handleVelocityChanged()),\n    );\n  }\n\n  disposed() {\n    this.unregisterUpdateStartedCallback?.();\n    super.disposed();\n  }\n\n  private handleVelocityChanged() {\n    const { dimensionStates } = this;\n    const ids = this.position.coordinateSpace.value?.ids ?? [];\n    const rank = ids.length;\n    const velocities = this.velocity.value;\n    const generation = ++this.lastUpdateGeneration;\n    const positionVector = this.position.value;\n    const curTime = Date.now();\n    for (let i = 0; i < rank; ++i) {\n      const velocity = velocities[i];\n      if (velocity === undefined) continue;\n      if (velocity.velocity === 0 || velocity.paused) continue;\n      const id = ids[i];\n      const state = dimensionStates.get(id);\n      if (state === undefined) {\n        dimensionStates.set(id, {\n          prevTime: curTime,\n          dimensionIndex: i,\n          prevCoordinate: positionVector[i],\n          generation,\n        });\n      } else {\n        state.generation = generation;\n        state.dimensionIndex = i;\n      }\n    }\n    for (const [id, state] of dimensionStates) {\n      if (state.generation !== generation) {\n        dimensionStates.delete(id);\n      }\n    }\n    if (dimensionStates.size === 0) {\n      const { unregisterUpdateStartedCallback } = this;\n      if (unregisterUpdateStartedCallback !== undefined) {\n        unregisterUpdateStartedCallback();\n        this.unregisterUpdateStartedCallback = undefined;\n      }\n    } else {\n      if (this.unregisterUpdateStartedCallback === undefined) {\n        this.unregisterUpdateStartedCallback = this.display.updateStarted.add(\n          () => this.updateStarted(),\n        );\n        this.display.scheduleRedraw();\n      }\n    }\n  }\n\n  private updateStarted() {\n    const coordinateSpace = this.position.coordinateSpace.value;\n    if (coordinateSpace === undefined) {\n      return;\n    }\n    const ids = coordinateSpace.ids;\n    const positionVector = this.position.value;\n    let positionChanged = false;\n    let velocityChanged = false;\n    const curTime = Date.now();\n    const velocities = this.velocity.value;\n    const {\n      bounds: { lowerBounds, upperBounds },\n    } = coordinateSpace;\n    for (const [id, dimensionState] of this.dimensionStates) {\n      const { dimensionIndex } = dimensionState;\n      if (ids[dimensionIndex] !== id) continue;\n      const velocity = velocities[dimensionIndex];\n      if (\n        Math.floor(positionVector[dimensionIndex]) !==\n        Math.floor(dimensionState.prevCoordinate)\n      ) {\n        // Pause this dimension.\n        if (velocity?.paused === false) {\n          velocities[dimensionIndex] = { ...velocity, paused: true };\n          velocityChanged = true;\n        }\n        continue;\n      }\n      const timeDelta = curTime - dimensionState.prevTime;\n      const velocityValue = velocity?.velocity ?? 0;\n      const delta = (timeDelta * velocityValue) / 1000;\n      if (delta === 0) continue;\n      let newCoordinate = positionVector[dimensionIndex] + delta;\n      const lowerBound = lowerBounds[dimensionIndex];\n      const upperBound = Math.ceil(upperBounds[dimensionIndex] - 1);\n      const limit = delta > 0 ? upperBound : lowerBound;\n      const oppositeLimit = delta > 0 ? lowerBound : upperBound;\n      const deltaSign = Math.sign(delta);\n      if (\n        Number.isFinite(limit) &&\n        newCoordinate * deltaSign >= limit * deltaSign\n      ) {\n        switch (velocity!.atBoundary) {\n          case VelocityBoundaryBehavior.LOOP:\n            if (Number.isFinite(oppositeLimit)) {\n              newCoordinate = oppositeLimit;\n              break;\n            }\n          // fallthrough\n          case VelocityBoundaryBehavior.STOP:\n            velocities[dimensionIndex] = { ...velocity!, paused: true };\n            velocityChanged = true;\n            newCoordinate = limit;\n            break;\n          case VelocityBoundaryBehavior.REVERSE:\n            velocities[dimensionIndex] = {\n              ...velocity!,\n              velocity: -velocityValue,\n            };\n            velocityChanged = true;\n            newCoordinate = limit;\n            break;\n        }\n      }\n      positionVector[dimensionIndex] = newCoordinate;\n      dimensionState.prevCoordinate = positionVector[dimensionIndex];\n      dimensionState.prevTime = curTime;\n      positionChanged = true;\n    }\n    if (positionChanged) {\n      this.position.changed.dispatch();\n    }\n    if (velocityChanged) {\n      this.velocity.changed.dispatch();\n    }\n    this.display.scheduleRedraw();\n  }\n}\n\ntype TrackableLinkInterface =\n  | TrackableNavigationLink\n  | TrackableNavigationSimpleLink;\n\nfunction restoreLinkedFromJson(\n  link: TrackableLinkInterface,\n  value: { restoreState(obj: unknown): void },\n  json: any,\n) {\n  if (json === undefined || Object.keys(json).length === 0) {\n    link.value = NavigationLinkType.LINKED;\n    return;\n  }\n  verifyObject(json);\n  link.value = NavigationLinkType.UNLINKED;\n  verifyObjectProperty(json, \"value\", (x) => {\n    if (x !== undefined) {\n      value.restoreState(x);\n    }\n  });\n  verifyObjectProperty(json, \"link\", (x) => link.restoreState(x));\n}\n\ninterface LinkableState<T> extends RefCounted, Trackable {\n  assign(other: T): void;\n}\n\nabstract class LinkedBase<\n  T extends LinkableState<T>,\n  Link extends TrackableLinkInterface = TrackableNavigationLink,\n> implements Trackable\n{\n  value: T;\n  get changed() {\n    return this.value.changed;\n  }\n  constructor(\n    public peer: Owned<T>,\n    public link: Link = new TrackableNavigationLink() as any,\n  ) {}\n\n  toJSON() {\n    const { link } = this;\n    if (link.value === NavigationLinkType.LINKED) {\n      return undefined;\n    }\n    return { link: link.toJSON(), value: this.getValueJson() };\n  }\n\n  protected getValueJson(): any {\n    return this.value.toJSON();\n  }\n\n  reset() {\n    this.link.value = NavigationLinkType.LINKED;\n  }\n\n  restoreState(obj: any) {\n    restoreLinkedFromJson(this.link, this.value, obj);\n  }\n\n  copyToPeer() {\n    if (this.link.value !== NavigationLinkType.LINKED) {\n      this.link.value = NavigationLinkType.UNLINKED;\n      this.peer.assign(this.value);\n      this.link.value = NavigationLinkType.LINKED;\n    }\n  }\n}\n\nabstract class SimpleLinkedBase<\n    T extends RefCounted & Trackable & { assign(other: T): void },\n  >\n  extends LinkedBase<T, TrackableNavigationSimpleLink>\n  implements Trackable {}\n\nexport class LinkedPosition extends LinkedBase<Position> {\n  value = makeLinked(\n    new Position(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (a: Position, b: Position) => a.assign(b),\n      isValid: (a: Position) => {\n        return a.valid;\n      },\n      difference: Position.getOffset,\n      add: Position.addOffset,\n      subtract: (\n        target: Position,\n        source: Position,\n        amount: Float32Array | undefined,\n      ) => {\n        Position.addOffset(target, source, amount, -1);\n      },\n    },\n  );\n}\n\nfunction quaternionIsIdentity(q: quat) {\n  return q[0] === 0 && q[1] === 0 && q[2] === 0 && q[3] === 1;\n}\n\nexport class OrientationState extends RefCounted {\n  orientation: quat;\n  changed = new NullarySignal();\n\n  constructor(orientation?: quat) {\n    super();\n    if (orientation == null) {\n      orientation = quat.create();\n    }\n    this.orientation = orientation;\n  }\n  toJSON() {\n    const { orientation } = this;\n    quat.normalize(this.orientation, this.orientation);\n    if (quaternionIsIdentity(orientation)) {\n      return undefined;\n    }\n    return Array.prototype.slice.call(this.orientation);\n  }\n  restoreState(obj: any) {\n    try {\n      parseFiniteVec(this.orientation, obj);\n      quat.normalize(this.orientation, this.orientation);\n    } catch {\n      quat.identity(this.orientation);\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    quat.identity(this.orientation);\n    this.changed.dispatch();\n  }\n\n  snap() {\n    const mat = mat3.create();\n    mat3.fromQuat(mat, this.orientation);\n    const usedAxes = [false, false, false];\n    for (let i = 0; i < 3; ++i) {\n      let maxComponent = 0;\n      let argmaxComponent = 0;\n      for (let j = 0; j < 3; ++j) {\n        const value = mat[i * 3 + j];\n        mat[i * 3 + j] = 0;\n        if (usedAxes[j]) {\n          continue;\n        }\n        if (Math.abs(value) > Math.abs(maxComponent)) {\n          maxComponent = value;\n          argmaxComponent = j;\n        }\n      }\n      mat[i * 3 + argmaxComponent] = Math.sign(maxComponent);\n      usedAxes[argmaxComponent] = true;\n    }\n    quat.fromMat3(this.orientation, mat);\n    this.changed.dispatch();\n  }\n\n  /**\n   * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any\n   * changes to the returned OrientationState will cause a corresponding change in peer, and vice\n   * versa.\n   */\n  static makeRelative(peer: OrientationState, peerToSelf: quat) {\n    const self = new OrientationState(\n      quat.multiply(quat.create(), peer.orientation, peerToSelf),\n    );\n    let updatingPeer = false;\n    self.registerDisposer(\n      peer.changed.add(() => {\n        if (!updatingPeer) {\n          updatingSelf = true;\n          quat.multiply(self.orientation, peer.orientation, peerToSelf);\n          self.changed.dispatch();\n          updatingSelf = false;\n        }\n      }),\n    );\n    let updatingSelf = false;\n    const selfToPeer = quat.invert(quat.create(), peerToSelf);\n    self.registerDisposer(\n      self.changed.add(() => {\n        if (!updatingSelf) {\n          updatingPeer = true;\n          quat.multiply(peer.orientation, self.orientation, selfToPeer);\n          peer.changed.dispatch();\n          updatingPeer = false;\n        }\n      }),\n    );\n    return self;\n  }\n\n  assign(other: Borrowed<OrientationState>) {\n    quat.copy(this.orientation, other.orientation);\n    this.changed.dispatch();\n  }\n}\n\nexport class LinkedOrientationState extends LinkedBase<OrientationState> {\n  value = makeLinked(new OrientationState(), this.peer, this.link, {\n    assign: (a: OrientationState, b: OrientationState) => a.assign(b),\n    isValid: () => true,\n    difference: (a: OrientationState, b: OrientationState) => {\n      const temp = quat.create();\n      return quat.multiply(\n        temp,\n        quat.invert(temp, b.orientation),\n        a.orientation,\n      );\n    },\n    add: (target: OrientationState, source: OrientationState, amount: quat) => {\n      quat.multiply(target.orientation, source.orientation, amount);\n      target.changed.dispatch();\n    },\n    subtract: (\n      target: OrientationState,\n      source: OrientationState,\n      amount: quat,\n    ) => {\n      quat.multiply(\n        target.orientation,\n        source.orientation,\n        quat.invert(tempQuat, amount),\n      );\n      target.changed.dispatch();\n    },\n  });\n}\n\nexport interface RelativeDisplayScales {\n  /**\n   * Array of length `coordinateSpace.rank` specifying scale factors on top of (will be multiply by)\n   * `coordinateSpace.scales` to use for display purposes.  This allows non-uniform zooming.\n   */\n  factors: Float64Array;\n}\n\nexport class TrackableRelativeDisplayScales\n  extends RefCounted\n  implements Trackable, WatchableValueInterface<RelativeDisplayScales>\n{\n  changed = new NullarySignal();\n  private curCoordinateSpace = emptyInvalidCoordinateSpace;\n  private value_: RelativeDisplayScales = { factors: new Float64Array(0) };\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(coordinateSpace.changed.add(() => this.update()));\n    this.update();\n  }\n\n  get value() {\n    return this.update();\n  }\n\n  reset() {\n    this.value_ = { factors: new Float64Array(0) };\n    this.curCoordinateSpace = emptyInvalidCoordinateSpace;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    const json: any = {};\n    let nonEmpty = false;\n    const { value } = this;\n    const { factors } = value;\n    const { names, rank } = this.curCoordinateSpace;\n    for (let i = 0; i < rank; ++i) {\n      const factor = factors[i];\n      if (factor === 1) continue;\n      json[names[i]] = factor;\n      nonEmpty = true;\n    }\n    if (nonEmpty) return json;\n    return undefined;\n  }\n\n  restoreState(json: unknown) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const { names, rank } = coordinateSpace;\n    const factors = new Float64Array(rank);\n    factors.fill(-1);\n    if (json !== undefined) {\n      const obj = verifyObject(json);\n      for (let i = 0; i < rank; ++i) {\n        factors[i] = verifyObjectProperty(obj, names[i], (x) =>\n          x === undefined ? 1 : verifyFinitePositiveFloat(x),\n        );\n      }\n    }\n    this.value_ = { factors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n  }\n\n  setFactors(factors: Float64Array) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    if (factors.length !== coordinateSpace.rank) return;\n    this.value_ = { factors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n  }\n\n  private update() {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    let value = this.value_;\n    const { curCoordinateSpace } = this;\n    if (curCoordinateSpace === coordinateSpace) return value;\n    const { ids: oldDimensionIds } = curCoordinateSpace;\n    const { ids: newDimensionIds, rank } = coordinateSpace;\n    const oldFactors = value.factors;\n    const newFactors = new Float64Array(rank);\n    newFactors.fill(1);\n    for (let i = 0; i < rank; ++i) {\n      const id = newDimensionIds[i];\n      const oldIndex = oldDimensionIds.indexOf(id);\n      if (oldIndex === -1) continue;\n      newFactors[i] = oldFactors[oldIndex];\n    }\n    if (arraysEqual(newFactors, oldFactors)) return value;\n    value = this.value_ = { factors: newFactors };\n    this.curCoordinateSpace = coordinateSpace;\n    this.changed.dispatch();\n    return value;\n  }\n\n  assign(other: TrackableRelativeDisplayScales) {\n    this.setFactors(other.value.factors);\n  }\n}\n\nfunction mapPerDimensionValues<\n  T,\n  A extends { length: number; [index: number]: T },\n  C extends { new (n: number): A },\n>(\n  arrayConstructor: C,\n  input: A,\n  oldCoordinateSpace: CoordinateSpace,\n  newCoordinateSpace: CoordinateSpace,\n  defaultValue: (index: number) => T,\n): A {\n  if (oldCoordinateSpace === newCoordinateSpace) return input;\n  const { ids: oldDimensionIds } = oldCoordinateSpace;\n  const { rank: newRank, ids: newDimensionIds } = newCoordinateSpace;\n  const output = new arrayConstructor(newRank);\n  for (let newDim = 0; newDim < newRank; ++newDim) {\n    const id = newDimensionIds[newDim];\n    const oldDim = oldDimensionIds.indexOf(id);\n    output[newDim] = oldDim === -1 ? defaultValue(newDim) : input[oldDim];\n  }\n  return output;\n}\n\nexport class LinkedRelativeDisplayScales extends LinkedBase<TrackableRelativeDisplayScales> {\n  value = makeLinked(\n    new TrackableRelativeDisplayScales(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (target, source) => target.assign(source),\n      difference: (a, b) => {\n        const { factors: fa } = a.value;\n        const coordinateSpace = a.coordinateSpace.value;\n        const fb = b.value.factors;\n        return {\n          coordinateSpace,\n          offsets: vector.subtract(new Float64Array(fa.length), fa, fb),\n        };\n      },\n      add: (\n        target,\n        source,\n        delta: { offsets: Float64Array; coordinateSpace: CoordinateSpace },\n      ) => {\n        const newOffsets = mapPerDimensionValues(\n          Float64Array,\n          delta.offsets,\n          delta.coordinateSpace,\n          target.coordinateSpace.value,\n          () => 0,\n        );\n        target.setFactors(\n          vector.add(\n            new Float64Array(newOffsets.length),\n            newOffsets,\n            source.value.factors,\n          ),\n        );\n      },\n      subtract: (\n        target,\n        source,\n        delta: { offsets: Float64Array; coordinateSpace: CoordinateSpace },\n      ) => {\n        const newOffsets = mapPerDimensionValues(\n          Float64Array,\n          delta.offsets,\n          delta.coordinateSpace,\n          target.coordinateSpace.value,\n          () => 0,\n        );\n        target.setFactors(\n          vector.subtract(\n            new Float64Array(newOffsets.length),\n            source.value.factors,\n            newOffsets,\n          ),\n        );\n      },\n      isValid: () => true,\n    },\n  );\n}\n\nexport interface DisplayDimensionRenderInfo {\n  /**\n   * Number of global dimensions.\n   */\n  globalRank: number;\n\n  /**\n   * Array of length `globalRank` specifying global dimension names.\n   */\n  globalDimensionNames: readonly string[];\n\n  /**\n   * Number of displayed dimensions.  Must be <= 3.\n   */\n  displayRank: number;\n\n  /**\n   * Array of length 3.  The first `displayRank` elements specify the indices of the the global\n   * dimensions that are displayed.  The remaining elements are `-1`.\n   */\n  displayDimensionIndices: Int32Array;\n\n  /**\n   * Array of length 3.  `voxelPhysicalScales[i]` equals\n   * `relativeDisplayScales[d] * coordinateSpace.scales[d]`,\n   * where `d = displayDimensionIndices[i]`, or `1` for `i >= rank`.\n   */\n  voxelPhysicalScales: Float64Array;\n\n  /**\n   * Unit corresponding to each dimension in `displayDimensionIndices`.  `displayDimensionUnits[i]`\n   * is equal to `coordinateSpace.units[displayDimensionIndices[i]]`, or `''` if\n   * `displayDimensionIndices[i] == -1`.\n   */\n  displayDimensionUnits: readonly string[];\n\n  /**\n   * Scale corresponding to each dimension in `displayDimensionIndices`.\n   * `displayDimensionScales[i]` is equal to `coordinateSpace.scales[displayDimensionIndices[i]]`,\n   * or `1` if `displayDimensionIndices[i] == -1`.\n   */\n  displayDimensionScales: Float64Array;\n\n  /**\n   * Physical scale corresponding to the canonical voxel.  Equal to minimum of\n   * `voxelPhysicalScales.slice(0, rank)`, or `1` if `rank == 0`.\n   */\n  canonicalVoxelPhysicalSize: number;\n\n  /**\n   * Array of length 3.  Amount by which the voxel coordinates of each display dimensions must be\n   * multiplied to convert to canonical voxels.  canonicalVoxelFactors[i] = voxelPhysicalScales[d] /\n   * canonicalVoxelPhysicalSize, where d = dimensionIndices[i], or `1` for `i >= rank`.\n   */\n  canonicalVoxelFactors: Float64Array;\n}\n\nfunction getDisplayDimensionRenderInfo(\n  coordinateSpace: CoordinateSpace,\n  displayDimensions: DisplayDimensions,\n  relativeDisplayScales: RelativeDisplayScales,\n): DisplayDimensionRenderInfo {\n  const {\n    rank: globalRank,\n    names: globalDimensionNames,\n    units,\n  } = coordinateSpace;\n  const { displayRank, displayDimensionIndices } = displayDimensions;\n  const canonicalVoxelFactors = new Float64Array(3);\n  const voxelPhysicalScales = new Float64Array(3);\n  let canonicalVoxelPhysicalSize: number;\n  const { factors } = relativeDisplayScales;\n  const displayDimensionUnits = new Array<string>(3);\n  const displayDimensionScales = new Float64Array(3);\n  canonicalVoxelFactors.fill(1);\n  voxelPhysicalScales.fill(1);\n  displayDimensionScales.fill(1);\n  displayDimensionUnits.fill(\"\");\n  if (displayRank === 0) {\n    canonicalVoxelPhysicalSize = 1;\n  } else {\n    canonicalVoxelPhysicalSize = Number.POSITIVE_INFINITY;\n    const { scales } = coordinateSpace;\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const s = (voxelPhysicalScales[i] = factors[dim] * scales[dim]);\n      canonicalVoxelPhysicalSize = Math.min(canonicalVoxelPhysicalSize, s);\n      displayDimensionUnits[i] = units[dim];\n      displayDimensionScales[i] = scales[dim];\n    }\n    for (let i = 0; i < displayRank; ++i) {\n      canonicalVoxelFactors[i] =\n        voxelPhysicalScales[i] / canonicalVoxelPhysicalSize;\n    }\n  }\n  return {\n    globalRank,\n    globalDimensionNames,\n    displayRank,\n    displayDimensionIndices,\n    displayDimensionUnits,\n    displayDimensionScales,\n    canonicalVoxelFactors,\n    voxelPhysicalScales,\n    canonicalVoxelPhysicalSize,\n  };\n}\n\nexport function displayDimensionRenderInfosEqual(\n  a: DisplayDimensionRenderInfo,\n  b: DisplayDimensionRenderInfo,\n) {\n  return (\n    arraysEqual(a.globalDimensionNames, b.globalDimensionNames) &&\n    arraysEqual(a.displayDimensionIndices, b.displayDimensionIndices) &&\n    arraysEqual(a.canonicalVoxelFactors, b.canonicalVoxelFactors) &&\n    arraysEqual(a.voxelPhysicalScales, b.voxelPhysicalScales) &&\n    a.canonicalVoxelPhysicalSize === b.canonicalVoxelPhysicalSize &&\n    arraysEqual(a.displayDimensionUnits, b.displayDimensionUnits) &&\n    arraysEqual(a.displayDimensionScales, b.displayDimensionScales)\n  );\n}\n\nexport function validateDisplayDimensionRenderInfoProperty(\n  obj: { displayDimensionRenderInfo: DisplayDimensionRenderInfo },\n  expected: DisplayDimensionRenderInfo,\n): boolean {\n  const actual = obj.displayDimensionRenderInfo;\n  if (actual === expected) return true;\n  if (displayDimensionRenderInfosEqual(actual, expected)) {\n    obj.displayDimensionRenderInfo = expected;\n    return true;\n  }\n  return false;\n}\n\nexport class WatchableDisplayDimensionRenderInfo extends RefCounted {\n  changed = new NullarySignal();\n  private curRelativeDisplayScales: RelativeDisplayScales;\n  private curDisplayDimensions: DisplayDimensions;\n  private curCoordinateSpace: CoordinateSpace;\n  private value_: DisplayDimensionRenderInfo;\n  get value() {\n    const {\n      relativeDisplayScales: {\n        value: relativeDisplayScales,\n        coordinateSpace: { value: coordinateSpace },\n      },\n      displayDimensions: { value: displayDimensions },\n      curRelativeDisplayScales,\n      curDisplayDimensions,\n      curCoordinateSpace,\n    } = this;\n    let value = this.value_;\n    if (\n      curRelativeDisplayScales !== relativeDisplayScales ||\n      curDisplayDimensions !== displayDimensions ||\n      curCoordinateSpace !== coordinateSpace\n    ) {\n      this.curRelativeDisplayScales = relativeDisplayScales;\n      this.curDisplayDimensions = displayDimensions;\n      this.curCoordinateSpace = coordinateSpace;\n      const newValue = getDisplayDimensionRenderInfo(\n        coordinateSpace,\n        displayDimensions,\n        relativeDisplayScales,\n      );\n      if (!displayDimensionRenderInfosEqual(value, newValue)) {\n        this.value_ = value = newValue;\n        this.changed.dispatch();\n      }\n    }\n    return value;\n  }\n  constructor(\n    public relativeDisplayScales: Owned<TrackableRelativeDisplayScales>,\n    public displayDimensions: Owned<TrackableDisplayDimensions>,\n  ) {\n    super();\n    this.curRelativeDisplayScales = this.relativeDisplayScales.value;\n    this.curDisplayDimensions = this.displayDimensions.value;\n    this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value;\n    this.value_ = getDisplayDimensionRenderInfo(\n      this.curCoordinateSpace,\n      this.curDisplayDimensions,\n      this.curRelativeDisplayScales,\n    );\n\n    this.registerDisposer(relativeDisplayScales);\n    this.registerDisposer(displayDimensions);\n    const maybeUpdateValue = () => {\n      this.value;\n    };\n    this.registerDisposer(relativeDisplayScales.changed.add(maybeUpdateValue));\n    this.registerDisposer(displayDimensions.changed.add(maybeUpdateValue));\n  }\n}\n\nexport interface DisplayDimensions {\n  coordinateSpace: CoordinateSpace;\n  displayRank: number;\n  displayDimensionIndices: Int32Array;\n}\n\nexport class TrackableDisplayDimensions\n  extends RefCounted\n  implements Trackable\n{\n  changed = new NullarySignal();\n  private default_ = true;\n  private value_: DisplayDimensions | undefined = undefined;\n\n  constructor(\n    public coordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  ) {\n    super();\n    this.registerDisposer(\n      this.coordinateSpace.changed.add(this.changed.dispatch),\n    );\n    this.update();\n  }\n\n  get value() {\n    this.update();\n    return this.value_!;\n  }\n\n  private update() {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const value = this.value_;\n    if (value !== undefined && value.coordinateSpace === coordinateSpace) {\n      return;\n    }\n    if (value === undefined || this.default_) {\n      this.setToDefault(coordinateSpace);\n      return;\n    }\n    const newDimensionIndices = new Int32Array(3);\n    const { ids: oldDimensionIds } = value.coordinateSpace;\n    const { ids: newDimensionIds } = coordinateSpace;\n    const oldDimensionIndices = value.displayDimensionIndices;\n    const oldRank = value.displayRank;\n    let newRank = 0;\n    for (let i = 0; i < oldRank; ++i) {\n      const newDim = newDimensionIds.indexOf(\n        oldDimensionIds[oldDimensionIndices[i]],\n      );\n      if (newDim === -1) continue;\n      newDimensionIndices[newRank] = newDim;\n      ++newRank;\n    }\n    newDimensionIndices.fill(-1, newRank);\n    if (newRank === 0) {\n      this.default_ = true;\n      this.setToDefault(coordinateSpace);\n      return;\n    }\n    this.assignValue(coordinateSpace, newRank, newDimensionIndices);\n    this.changed.dispatch();\n  }\n\n  private setToDefault(coordinateSpace: CoordinateSpace) {\n    const displayRank = Math.min(coordinateSpace.rank, 3);\n    const displayDimensionIndices = new Int32Array(3);\n    displayDimensionIndices.fill(-1);\n    for (let i = 0; i < displayRank; ++i) {\n      displayDimensionIndices[i] = i;\n    }\n    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);\n  }\n\n  private assignValue(\n    coordinateSpace: CoordinateSpace,\n    displayRank: number,\n    displayDimensionIndices: Int32Array,\n  ) {\n    this.value_ = {\n      coordinateSpace,\n      displayRank,\n      displayDimensionIndices,\n    };\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.default_ = true;\n    this.value_ = undefined;\n    this.changed.dispatch();\n  }\n\n  restoreState(obj: any) {\n    if (obj === undefined) {\n      this.reset();\n      return;\n    }\n    const displayDimensionNames = dimensionNamesFromJson(obj);\n    if (displayDimensionNames.length > 3) {\n      throw new Error(\"Number of spatial dimensions must be <= 3\");\n    }\n    const {\n      coordinateSpace: { value: coordinateSpace },\n    } = this;\n    const displayDimensionIndices = new Int32Array(3);\n    displayDimensionIndices.fill(-1);\n    const { names } = coordinateSpace;\n    let displayRank = 0;\n    for (const name of displayDimensionNames) {\n      const index = names.indexOf(name);\n      if (index === -1) continue;\n      displayDimensionIndices[displayRank++] = index;\n    }\n    if (displayRank === 0) {\n      this.reset();\n      return;\n    }\n    this.default_ = false;\n    this.assignValue(coordinateSpace, displayRank, displayDimensionIndices);\n  }\n\n  get default() {\n    this.update();\n    return this.default_;\n  }\n\n  set default(value: boolean) {\n    if (this.default_ === value) return;\n    if (value) {\n      this.default_ = true;\n      this.setToDefault(this.coordinateSpace.value);\n    } else {\n      this.default_ = false;\n      this.changed.dispatch();\n    }\n  }\n\n  setDimensionIndices(rank: number, dimensionIndices: Int32Array) {\n    this.default_ = false;\n    this.assignValue(this.coordinateSpace.value, rank, dimensionIndices);\n  }\n\n  toJSON() {\n    if (this.default_) return undefined;\n    const { value } = this;\n    const displayDimensionNames: string[] = [];\n    const {\n      displayRank,\n      displayDimensionIndices,\n      coordinateSpace: { names },\n    } = value;\n    if (displayRank === 0) return undefined;\n    for (let i = 0; i < displayRank; ++i) {\n      displayDimensionNames[i] = names[displayDimensionIndices[i]];\n    }\n    return displayDimensionNames;\n  }\n\n  assign(other: TrackableDisplayDimensions) {\n    if (other.default) {\n      this.default = true;\n    } else {\n      const { displayRank, displayDimensionIndices } = other.value;\n      this.setDimensionIndices(displayRank, displayDimensionIndices);\n    }\n  }\n}\n\nexport class LinkedDisplayDimensions extends SimpleLinkedBase<TrackableDisplayDimensions> {\n  value = makeSimpleLinked(\n    new TrackableDisplayDimensions(this.peer.coordinateSpace),\n    this.peer,\n    this.link,\n    {\n      assign: (target, source) => target.assign(source),\n      isValid: () => true,\n    },\n  );\n}\n\nexport class DisplayPose extends RefCounted {\n  changed = new NullarySignal();\n\n  get displayDimensions(): Borrowed<TrackableDisplayDimensions> {\n    return this.displayDimensionRenderInfo.displayDimensions;\n  }\n\n  get relativeDisplayScales(): Borrowed<TrackableRelativeDisplayScales> {\n    return this.displayDimensionRenderInfo.relativeDisplayScales;\n  }\n\n  constructor(\n    public position: Owned<Position>,\n    public displayDimensionRenderInfo: WatchableDisplayDimensionRenderInfo,\n    public orientation: Owned<OrientationState>,\n  ) {\n    super();\n    this.registerDisposer(position);\n    this.registerDisposer(orientation);\n    this.registerDisposer(displayDimensionRenderInfo);\n    this.registerDisposer(position.changed.add(this.changed.dispatch));\n    this.registerDisposer(orientation.changed.add(this.changed.dispatch));\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(this.changed.dispatch),\n    );\n  }\n\n  get valid() {\n    return this.position.valid;\n  }\n\n  /**\n   * Resets everything.\n   */\n  reset() {\n    this.position.reset();\n    this.orientation.reset();\n    this.displayDimensions.reset();\n  }\n\n  updateDisplayPosition(\n    fun: (pos: vec3) => boolean | void,\n    temp: vec3 = tempVec3,\n  ): boolean {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n      value: voxelCoordinates,\n    } = this.position;\n    const { displayDimensionIndices, displayRank } =\n      this.displayDimensions.value;\n    if (coordinateSpace === undefined) return false;\n    temp.fill(0);\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      temp[i] = voxelCoordinates[dim];\n    }\n    if (fun(temp) !== false) {\n      for (let i = 0; i < displayRank; ++i) {\n        const dim = displayDimensionIndices[i];\n        voxelCoordinates[dim] = temp[i];\n      }\n      this.position.changed.dispatch();\n      return true;\n    }\n    return false;\n  }\n\n  // Transform from view coordinates to global spatial coordinates.\n  toMat4(mat: mat4, zoom: number) {\n    mat4.fromQuat(mat, this.orientation.orientation);\n    const { value: voxelCoordinates } = this.position;\n    const { canonicalVoxelFactors, displayDimensionIndices } =\n      this.displayDimensionRenderInfo.value;\n    for (let i = 0; i < 3; ++i) {\n      const dim = displayDimensionIndices[i];\n      const scale = zoom / canonicalVoxelFactors[i];\n      mat[i] *= scale;\n      mat[4 + i] *= scale;\n      mat[8 + i] *= scale;\n      mat[12 + i] = voxelCoordinates[dim] || 0;\n    }\n  }\n\n  toMat3(mat: mat3, zoom: number) {\n    mat3.fromQuat(mat, this.orientation.orientation);\n    const { canonicalVoxelFactors, displayRank } =\n      this.displayDimensionRenderInfo.value;\n    for (let i = 0; i < displayRank; ++i) {\n      const scale = zoom / canonicalVoxelFactors[i];\n      mat[i] *= scale;\n      mat[3 + i] *= scale;\n      mat[6 + i] *= scale;\n    }\n  }\n\n  /**\n   * Snaps the orientation to the nearest axis-aligned orientation, and\n   * snaps the position to the nearest voxel.\n   */\n  snap() {\n    this.orientation.snap();\n    this.position.snapToVoxel();\n    this.changed.dispatch();\n  }\n\n  translateDimensionRelative(dimensionIndex: number, adjustment: number) {\n    if (!this.valid) {\n      return;\n    }\n    const { position } = this;\n    const { value: voxelCoordinates } = position;\n    const { bounds } = position.coordinateSpace.value;\n    voxelCoordinates[dimensionIndex] = clampAndRoundCoordinateToVoxelCenter(\n      bounds,\n      dimensionIndex,\n      voxelCoordinates[dimensionIndex] + adjustment,\n    );\n    position.changed.dispatch();\n  }\n\n  translateVoxelsRelative(translation: vec3) {\n    if (!this.valid) {\n      return;\n    }\n    const temp = vec3.transformQuat(\n      tempVec3,\n      translation,\n      this.orientation.orientation,\n    );\n    const { position } = this;\n    const { value: voxelCoordinates } = position;\n    const { displayDimensionIndices, displayRank } =\n      this.displayDimensions.value;\n    const { bounds } = position.coordinateSpace.value;\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const adjustment = temp[i];\n      if (adjustment === 0) continue;\n      voxelCoordinates[dim] = clampAndRoundCoordinateToVoxelCenter(\n        bounds,\n        dim,\n        voxelCoordinates[dim] + adjustment,\n      );\n    }\n    this.position.changed.dispatch();\n  }\n\n  rotateRelative(axis: vec3, angle: number) {\n    const temp = quat.create();\n    quat.setAxisAngle(temp, axis, angle);\n    const orientation = this.orientation.orientation;\n    quat.multiply(orientation, orientation, temp);\n    this.orientation.changed.dispatch();\n  }\n\n  rotateAbsolute(axis: vec3, angle: number, fixedPoint: Float32Array) {\n    const {\n      coordinateSpace: { value: coordinateSpace },\n      value: voxelCoordinates,\n    } = this.position;\n    if (coordinateSpace === undefined) return;\n    const {\n      relativeDisplayScales: {\n        value: { factors: relativeDisplayScales },\n      },\n      displayDimensions: {\n        value: { displayDimensionIndices, displayRank },\n      },\n    } = this;\n    const { scales } = coordinateSpace;\n    const temp = quat.create();\n    quat.setAxisAngle(temp, axis, angle);\n    const orientation = this.orientation.orientation;\n\n    // We want the coordinates in the transformed coordinate frame of the fixed point to remain\n    // the same after the rotation.\n\n    // We have the invariants:\n    // oldOrienation * fixedPointLocal + oldPosition == fixedPoint.\n    // newOrientation * fixedPointLocal + newPosition == fixedPoint.\n\n    // Therefore, we compute fixedPointLocal by:\n    // fixedPointLocal == inverse(oldOrientation) * (fixedPoint - oldPosition).\n    const fixedPointLocal = tempVec3;\n    tempVec3.fill(0);\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      const diff = fixedPoint[dim] - voxelCoordinates[dim];\n      fixedPointLocal[i] = diff * scales[dim] * relativeDisplayScales[dim];\n    }\n    const invOrientation = quat.invert(tempQuat, orientation);\n    vec3.transformQuat(fixedPointLocal, fixedPointLocal, invOrientation);\n\n    // We then compute the newPosition by:\n    // newPosition := fixedPoint - newOrientation * fixedPointLocal.\n    quat.multiply(orientation, temp, orientation);\n    vec3.transformQuat(fixedPointLocal, fixedPointLocal, orientation);\n\n    for (let i = 0; i < displayRank; ++i) {\n      const dim = displayDimensionIndices[i];\n      voxelCoordinates[dim] =\n        fixedPoint[dim] -\n        fixedPointLocal[i] / (scales[dim] * relativeDisplayScales[dim]);\n    }\n    this.position.changed.dispatch();\n    this.orientation.changed.dispatch();\n  }\n\n  translateNonDisplayDimension(\n    nonSpatialDimensionIndex: number,\n    adjustment: number,\n  ) {\n    if (!this.valid) return;\n    const { displayDimensionIndices } = this.displayDimensions.value;\n    const { position } = this;\n    const rank = position.coordinateSpace.value.rank;\n    for (let i = 0; i < rank; ++i) {\n      if (displayDimensionIndices.indexOf(i) !== -1) continue;\n      if (nonSpatialDimensionIndex-- === 0) {\n        this.translateDimensionRelative(i, adjustment);\n        return;\n      }\n    }\n  }\n}\n\nexport type TrackableZoomInterface =\n  | TrackableProjectionZoom\n  | TrackableCrossSectionZoom;\n\nexport class LinkedZoomState<\n  T extends TrackableProjectionZoom | TrackableCrossSectionZoom,\n> extends LinkedBase<T> {\n  constructor(\n    peer: Owned<T>,\n    displayDimensionRenderInfo: Owned<WatchableDisplayDimensionRenderInfo>,\n  ) {\n    super(peer);\n    this.value = (() => {\n      const self: T = new (peer.constructor as any)(displayDimensionRenderInfo);\n      const assign = (target: T, source: T) => {\n        target.assign(source);\n      };\n      const difference = (a: T, b: T) => {\n        return (\n          (a.value / b.value) *\n          (a.canonicalVoxelPhysicalSize / b.canonicalVoxelPhysicalSize)\n        );\n      };\n      const add = (target: T, source: T, amount: number) => {\n        target.setPhysicalScale(\n          source.value * amount,\n          source.canonicalVoxelPhysicalSize,\n        );\n      };\n      const subtract = (target: T, source: T, amount: number) => {\n        target.setPhysicalScale(\n          source.value / amount,\n          source.canonicalVoxelPhysicalSize,\n        );\n      };\n      const isValid = (x: T) =>\n        x.coordinateSpaceValue.valid && x.canonicalVoxelPhysicalSize !== 0;\n      makeLinked(\n        self as RefCounted & { changed: NullarySignal },\n        this.peer,\n        this.link,\n        {\n          assign,\n          isValid,\n          difference,\n          add,\n          subtract,\n        },\n      );\n      return self;\n    })();\n  }\n}\n\nexport function linkedStateLegacyJsonView<\n  T extends LinkableState<T> & { readonly legacyJsonView: Trackable },\n>(linked: LinkedBase<T>) {\n  return {\n    changed: linked.changed,\n    toJSON() {\n      return linked.toJSON();\n    },\n    restoreState(obj: unknown) {\n      restoreLinkedFromJson(linked.link, linked.value.legacyJsonView, obj);\n    },\n    reset() {\n      linked.reset();\n    },\n  };\n}\n\nabstract class TrackableZoom\n  extends RefCounted\n  implements Trackable, WatchableValueInterface<number>\n{\n  readonly changed = new NullarySignal();\n  private curCanonicalVoxelPhysicalSize = 0;\n  private value_: number = Number.NaN;\n  protected legacyValue_: number = Number.NaN;\n\n  /**\n   * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection\n   * views, in canonical voxels per viewport height (for orthographic projection).\n   */\n  get value() {\n    this.handleCoordinateSpaceChanged();\n    return this.value_;\n  }\n\n  set value(value: number) {\n    const { canonicalVoxelPhysicalSize } = this;\n    if (\n      Object.is(value, this.value_) &&\n      canonicalVoxelPhysicalSize === this.curCanonicalVoxelPhysicalSize\n    ) {\n      return;\n    }\n    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.legacyValue_ = Number.NaN;\n    this.value_ = value;\n    this.changed.dispatch();\n  }\n\n  get canonicalVoxelPhysicalSize() {\n    return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;\n  }\n\n  get coordinateSpaceValue() {\n    return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace\n      .value;\n  }\n\n  /**\n   * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per\n   * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units\n   * per viewport height (for orthographic projection).\n   */\n  set legacyValue(value: number) {\n    if (Object.is(value, this.legacyValue_)) return;\n    this.value_ = Number.NaN;\n    this.legacyValue_ = value;\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.changed.dispatch();\n  }\n\n  get legacyValue() {\n    return this.legacyValue_;\n  }\n\n  constructor(\n    public displayDimensionRenderInfo: Owned<WatchableDisplayDimensionRenderInfo>,\n  ) {\n    super();\n    this.registerDisposer(displayDimensionRenderInfo);\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(() =>\n        this.handleCoordinateSpaceChanged(),\n      ),\n    );\n    this.registerDisposer(\n      displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.changed.add(\n        () => this.handleCoordinateSpaceChanged(),\n      ),\n    );\n    this.handleCoordinateSpaceChanged();\n  }\n\n  handleCoordinateSpaceChanged() {\n    const { value_ } = this;\n    const {\n      displayDimensionRenderInfo: {\n        value: { canonicalVoxelPhysicalSize },\n        relativeDisplayScales: {\n          coordinateSpace: { value: coordinateSpace },\n        },\n      },\n    } = this;\n    const { curCanonicalVoxelPhysicalSize } = this;\n    if (\n      !Number.isNaN(value_) &&\n      canonicalVoxelPhysicalSize === curCanonicalVoxelPhysicalSize\n    ) {\n      return;\n    }\n    if (!Number.isNaN(value_)) {\n      if (curCanonicalVoxelPhysicalSize !== 0) {\n        this.value_ =\n          value_ * (curCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);\n        this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n        this.changed.dispatch();\n      }\n      return;\n    }\n    if (!coordinateSpace.valid || canonicalVoxelPhysicalSize === 0) {\n      return;\n    }\n    this.curCanonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.value_ = this.getDefaultValue();\n    this.changed.dispatch();\n  }\n\n  protected abstract getDefaultValue(): number;\n\n  toJSON() {\n    const { value } = this;\n    return Number.isNaN(value) ? undefined : value;\n  }\n\n  restoreState(obj: any) {\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.legacyValue_ = Number.NaN;\n    if (obj === undefined) {\n      this.value_ = Number.NaN;\n    } else {\n      this.value_ = verifyFinitePositiveFloat(obj);\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.curCanonicalVoxelPhysicalSize = 0;\n    this.value_ = Number.NaN;\n    this.legacyValue_ = Number.NaN;\n    this.changed.dispatch();\n  }\n\n  get legacyJsonView() {\n    const self = this;\n    return {\n      changed: self.changed,\n      toJSON() {\n        return self.toJSON();\n      },\n      reset() {\n        return self.reset();\n      },\n      restoreState(obj: any) {\n        self.legacyValue = verifyFinitePositiveFloat(obj);\n      },\n    };\n  }\n\n  setPhysicalScale(\n    scaleInCanonicalVoxels: number,\n    canonicalVoxelPhysicalSize: number,\n  ) {\n    const curCanonicalVoxelPhysicalSize = (this.curCanonicalVoxelPhysicalSize =\n      this.canonicalVoxelPhysicalSize);\n    this.value =\n      scaleInCanonicalVoxels *\n      (canonicalVoxelPhysicalSize / curCanonicalVoxelPhysicalSize);\n  }\n\n  assign(source: TrackableZoomInterface) {\n    const { legacyValue } = source;\n    if (!Number.isNaN(legacyValue)) {\n      this.legacyValue = legacyValue;\n    } else {\n      this.setPhysicalScale(source.value, source.canonicalVoxelPhysicalSize);\n    }\n  }\n}\n\nexport class TrackableCrossSectionZoom extends TrackableZoom {\n  protected getDefaultValue() {\n    const { legacyValue_ } = this;\n    if (Number.isNaN(legacyValue_)) {\n      // Default is 1 voxel per viewport pixel.\n      return 1;\n    }\n    const { canonicalVoxelPhysicalSize } = this;\n    return (this.legacyValue_ * 1e-9) / canonicalVoxelPhysicalSize;\n  }\n}\n\nexport class TrackableProjectionZoom extends TrackableZoom {\n  protected getDefaultValue() {\n    const { legacyValue_ } = this;\n    if (!Number.isNaN(legacyValue_)) {\n      this.legacyValue_ = Number.NaN;\n      const { canonicalVoxelPhysicalSize } = this;\n      return (\n        (2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * legacyValue_) /\n        canonicalVoxelPhysicalSize\n      );\n    }\n    const {\n      coordinateSpaceValue: {\n        bounds: { lowerBounds, upperBounds },\n      },\n    } = this;\n    const { canonicalVoxelFactors, displayDimensionIndices } =\n      this.displayDimensionRenderInfo.value;\n    let value = canonicalVoxelFactors.reduce((x, factor, i) => {\n      const dim = displayDimensionIndices[i];\n      const extent = (upperBounds[dim] - lowerBounds[dim]) * factor;\n      return Math.max(x, extent);\n    }, 0);\n    if (!Number.isFinite(value)) {\n      // Default to showing 1024 voxels if there is no bounds information.\n      value = 1024;\n    } else {\n      value = 2 ** Math.ceil(Math.log2(value));\n    }\n    return value;\n  }\n}\n\nexport class TrackableDepthRange\n  extends RefCounted\n  implements WatchableValueInterface<number>\n{\n  changed = new NullarySignal();\n\n  constructor(\n    public readonly defaultValue: number,\n    public displayDimensionRenderInfo: WatchableValueInterface<DisplayDimensionRenderInfo>,\n  ) {\n    super();\n    this.value_ = defaultValue;\n    this.canonicalVoxelPhysicalSize =\n      displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;\n    this.registerDisposer(\n      displayDimensionRenderInfo.changed.add(() => {\n        this.value;\n      }),\n    );\n  }\n\n  private value_: number;\n  canonicalVoxelPhysicalSize: number;\n\n  get value() {\n    let { value_ } = this;\n    if (value_ > 0) {\n      const { canonicalVoxelPhysicalSize } =\n        this.displayDimensionRenderInfo.value;\n      const prevCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;\n      if (canonicalVoxelPhysicalSize !== prevCanonicalVoxelPhysicalSize) {\n        this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n        value_ =\n          this.value_ =\n          value_ =\n            prevCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize;\n        this.changed.dispatch();\n      }\n    }\n    return value_;\n  }\n\n  set value(value: number) {\n    if (value === this.value) return;\n    this.value_ = value;\n    const { canonicalVoxelPhysicalSize } =\n      this.displayDimensionRenderInfo.value;\n    this.canonicalVoxelPhysicalSize = canonicalVoxelPhysicalSize;\n    this.changed.dispatch();\n  }\n\n  toJSON() {\n    const { value } = this;\n    if (value === this.defaultValue) return undefined;\n    return value;\n  }\n\n  reset() {\n    this.value = this.defaultValue;\n  }\n\n  restoreState(obj: unknown) {\n    if (typeof obj !== \"number\" || !Number.isFinite(obj) || obj === 0) {\n      this.value = this.defaultValue;\n    } else {\n      this.value = obj;\n    }\n  }\n\n  setValueAbsolute(value: number, sourceCanonicalVoxelPhysicalSize: number) {\n    if (value > 0) {\n      const { canonicalVoxelPhysicalSize } =\n        this.displayDimensionRenderInfo.value;\n      value =\n        value * (sourceCanonicalVoxelPhysicalSize / canonicalVoxelPhysicalSize);\n    }\n    this.value = value;\n  }\n\n  assign(other: TrackableDepthRange) {\n    this.setValueAbsolute(other.value, other.canonicalVoxelPhysicalSize);\n  }\n}\n\nexport class LinkedDepthRange extends SimpleLinkedBase<TrackableDepthRange> {\n  constructor(\n    peer: Owned<TrackableDepthRange>,\n    displayDimensionRenderInfo: WatchableValueInterface<DisplayDimensionRenderInfo>,\n  ) {\n    super(peer);\n    this.value = makeSimpleLinked(\n      new TrackableDepthRange(peer.defaultValue, displayDimensionRenderInfo),\n      this.peer,\n      this.link,\n      {\n        assign: (target, source) => target.assign(source),\n        isValid: () => true,\n      },\n    );\n  }\n}\n\nexport class NavigationState<\n  Zoom extends TrackableZoomInterface = TrackableZoomInterface,\n> extends RefCounted {\n  changed = new NullarySignal();\n\n  constructor(\n    public pose: Owned<DisplayPose>,\n    public zoomFactor: Owned<Zoom>,\n    public depthRange: Owned<TrackableDepthRange>,\n  ) {\n    super();\n    this.registerDisposer(pose);\n    this.registerDisposer(zoomFactor);\n    this.registerDisposer(depthRange);\n    this.registerDisposer(this.pose.changed.add(this.changed.dispatch));\n    this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch));\n    this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));\n  }\n  get coordinateSpace() {\n    return this.pose.position.coordinateSpace;\n  }\n\n  /**\n   * Resets everything.\n   */\n  reset() {\n    this.pose.reset();\n    this.zoomFactor.reset();\n  }\n\n  get position() {\n    return this.pose.position;\n  }\n  get displayDimensions() {\n    return this.pose.displayDimensions;\n  }\n  get relativeDisplayScales() {\n    return this.pose.relativeDisplayScales;\n  }\n  get displayDimensionRenderInfo() {\n    return this.pose.displayDimensionRenderInfo;\n  }\n  toMat4(mat: mat4) {\n    this.pose.toMat4(mat, this.zoomFactor.value);\n  }\n  toMat3(mat: mat3) {\n    this.pose.toMat3(mat, this.zoomFactor.value);\n  }\n\n  get relativeDepthRange() {\n    let depthRange = this.depthRange.value;\n    if (depthRange > 0) {\n      depthRange /= this.zoomFactor.value;\n    } else {\n      depthRange *= -1;\n    }\n    return depthRange;\n  }\n\n  get valid() {\n    return this.pose.valid && !Number.isNaN(this.zoomFactor.value);\n  }\n\n  zoomBy(factor: number) {\n    this.zoomFactor.value *= factor;\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedArrayConstructor } from \"#src/util/array.js\";\n\n/**\n * If this is updated, DATA_TYPE_BYTES must also be updated.\n */\nexport enum DataType {\n  UINT8 = 0,\n  INT8 = 1,\n  UINT16 = 2,\n  INT16 = 3,\n  UINT32 = 4,\n  INT32 = 5,\n  UINT64 = 6,\n  FLOAT32 = 7,\n}\n\nexport const DATA_TYPE_SIGNED: Record<DataType, boolean | undefined> = {\n  [DataType.UINT8]: false,\n  [DataType.INT8]: true,\n  [DataType.UINT16]: false,\n  [DataType.INT16]: true,\n  [DataType.UINT32]: false,\n  [DataType.INT32]: true,\n  [DataType.UINT64]: false,\n  [DataType.FLOAT32]: undefined,\n};\n\nexport const DATA_TYPE_BYTES: Record<DataType, number> = {\n  [DataType.UINT8]: 1,\n  [DataType.INT8]: 1,\n  [DataType.UINT16]: 2,\n  [DataType.INT16]: 2,\n  [DataType.UINT32]: 4,\n  [DataType.INT32]: 4,\n  [DataType.UINT64]: 8,\n  [DataType.FLOAT32]: 4,\n};\n\nexport const DATA_TYPE_ARRAY_CONSTRUCTOR: Record<\n  DataType,\n  TypedArrayConstructor\n> = {\n  [DataType.UINT8]: Uint8Array,\n  [DataType.INT8]: Int8Array,\n  [DataType.UINT16]: Uint16Array,\n  [DataType.INT16]: Int16Array,\n  [DataType.UINT32]: Uint32Array,\n  [DataType.INT32]: Int32Array,\n  [DataType.UINT64]: BigUint64Array,\n  [DataType.FLOAT32]: Float32Array,\n};\n\nexport function makeDataTypeArrayView<TArrayBuffer extends ArrayBufferLike>(\n  dataType: DataType,\n  buffer: TArrayBuffer,\n  byteOffset = 0,\n  byteLength: number = buffer.byteLength,\n): ArrayBufferView<TArrayBuffer> {\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  return new (DATA_TYPE_ARRAY_CONSTRUCTOR[\n    dataType\n  ] as TypedArrayConstructor<TArrayBuffer>)(\n    buffer,\n    byteOffset,\n    byteLength / bytesPerElement,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Facilities for endianness detection and swapping.\n */\n\nexport enum Endianness {\n  LITTLE = 0,\n  BIG = 1,\n}\n\nexport function determineEndianness() {\n  const a = Uint16Array.of(0x1122);\n  const b = new Uint8Array(a.buffer);\n  return b[0] === 0x11 ? Endianness.BIG : Endianness.LITTLE;\n}\n\n/**\n * The native endianness of the runtime.\n */\nexport const ENDIANNESS = determineEndianness();\n\n/**\n * Swaps the endianness of an array assumed to contain 16-bit values.\n */\nexport function swapEndian16(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 2) {\n    const temp = view[i];\n    view[i] = view[i + 1];\n    view[i + 1] = temp;\n  }\n}\n\n/**\n * Swaps the endianness of an array assumed to contain 32-bit values.\n */\nexport function swapEndian32(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 4) {\n    let temp = view[i];\n    view[i] = view[i + 3];\n    view[i + 3] = temp;\n    temp = view[i + 1];\n    view[i + 1] = view[i + 2];\n    view[i + 2] = temp;\n  }\n}\n\nexport function swapEndian64(array: ArrayBufferView) {\n  const view = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n  for (let i = 0, length = view.length; i < length; i += 8) {\n    let temp = view[i];\n    view[i] = view[i + 7];\n    view[i + 7] = temp;\n    temp = view[i + 1];\n    view[i + 1] = view[i + 6];\n    view[i + 6] = temp;\n    temp = view[i + 2];\n    view[i + 2] = view[i + 5];\n    view[i + 5] = temp;\n    temp = view[i + 3];\n    view[i + 3] = view[i + 4];\n    view[i + 4] = temp;\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 16-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian16(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian16(array);\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 32-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian32(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian32(array);\n  }\n}\n\n/**\n * Converts the endianness of an array assumed to contain 64-bit values from source to target.\n *\n * This does nothing if source === target.\n */\nexport function convertEndian64(\n  array: ArrayBufferView,\n  source: Endianness,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source !== target) {\n    swapEndian64(array);\n  }\n}\n\nexport function convertEndian(\n  array: ArrayBufferView,\n  source: Endianness,\n  elementBytes: number,\n  target: Endianness = ENDIANNESS,\n) {\n  if (source === target || elementBytes === 1) return;\n  switch (elementBytes) {\n    case 2:\n      swapEndian16(array);\n      break;\n    case 4:\n      swapEndian32(array);\n      break;\n    case 8:\n      swapEndian64(array);\n      break;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Basic annotation data structures.\n */\n\nimport type {\n  BoundingBox,\n  CoordinateSpaceTransform,\n  WatchableCoordinateSpaceTransform,\n} from \"#src/coordinate_transform.js\";\nimport { arraysEqual } from \"#src/util/array.js\";\nimport {\n  packColor,\n  parseRGBAColorSpecification,\n  parseRGBColorSpecification,\n  serializeColor,\n  unpackRGB,\n  unpackRGBA,\n} from \"#src/util/color.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { Endianness, ENDIANNESS } from \"#src/util/endian.js\";\nimport {\n  expectArray,\n  parseArray,\n  parseFixedLengthArray,\n  parseUint64,\n  verifyEnumString,\n  verifyFiniteFloat,\n  verifyFiniteNonNegativeFloat,\n  verifyFloat,\n  verifyInt,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n  verifyOptionalString,\n  verifyString,\n} from \"#src/util/json.js\";\nimport { parseDataTypeValue } from \"#src/util/lerp.js\";\nimport { getRandomHexString } from \"#src/util/random.js\";\nimport { NullarySignal, Signal } from \"#src/util/signal.js\";\n\nexport type AnnotationId = string;\n\nexport class AnnotationReference extends RefCounted {\n  changed = new NullarySignal();\n\n  /**\n   * If `undefined`, we are still waiting to look up the result.  If `null`, annotation has been\n   * deleted.\n   */\n  value: Annotation | null | undefined;\n\n  constructor(public id: AnnotationId) {\n    super();\n  }\n}\n\nexport enum AnnotationType {\n  POINT = 0,\n  LINE = 1,\n  AXIS_ALIGNED_BOUNDING_BOX = 2,\n  ELLIPSOID = 3,\n}\n\nexport const annotationTypes = [\n  AnnotationType.POINT,\n  AnnotationType.LINE,\n  AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n  AnnotationType.ELLIPSOID,\n];\n\nexport interface AnnotationPropertySpecBase {\n  identifier: string;\n  description: string | undefined;\n}\n\nexport interface AnnotationColorPropertySpec\n  extends AnnotationPropertySpecBase {\n  type: \"rgb\" | \"rgba\";\n  default: number;\n}\n\nexport interface AnnotationNumericPropertySpec\n  extends AnnotationPropertySpecBase {\n  type: \"float32\" | \"uint32\" | \"int32\" | \"uint16\" | \"int16\" | \"uint8\" | \"int8\";\n  default: number;\n  enumValues?: number[];\n  enumLabels?: string[];\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\nexport function isAnnotationNumericPropertySpec(\n  spec: AnnotationPropertySpec,\n): spec is AnnotationNumericPropertySpec {\n  return spec.type !== \"rgb\" && spec.type !== \"rgba\";\n}\n\nexport const propertyTypeDataType: Record<\n  AnnotationPropertySpec[\"type\"],\n  DataType | undefined\n> = {\n  float32: DataType.FLOAT32,\n  uint32: DataType.UINT32,\n  int32: DataType.INT32,\n  uint16: DataType.UINT16,\n  int16: DataType.INT16,\n  uint8: DataType.UINT8,\n  int8: DataType.INT8,\n  rgb: undefined,\n  rgba: undefined,\n};\n\nexport type AnnotationPropertySpec =\n  | AnnotationColorPropertySpec\n  | AnnotationNumericPropertySpec;\n\nexport interface AnnotationPropertyTypeHandler {\n  serializedBytes(rank: number): number;\n  alignment(rank: number): number;\n  serializeCode(property: string, offset: string, rank: number): string;\n  deserializeCode(property: string, offset: string, rank: number): string;\n  deserializeJson(obj: unknown): number;\n  serializeJson(value: number): any;\n}\n\nexport const annotationPropertyTypeHandlers: {\n  [K in AnnotationPropertySpec[\"type\"]]: AnnotationPropertyTypeHandler;\n} = {\n  rgb: {\n    serializedBytes() {\n      return 3;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return (\n        `dv.setUint16(${offset}, ${property}, true);` +\n        `dv.setUint8(${offset} + 2, ${property} >>> 16);`\n      );\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint16(${offset}, true) | (dv.getUint8(${offset} + 2) << 16);`;\n    },\n    deserializeJson(obj: unknown) {\n      return packColor(parseRGBColorSpecification(obj));\n    },\n    serializeJson(value: number) {\n      return serializeColor(unpackRGB(value));\n    },\n  },\n  rgba: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint32(${offset}, ${property}, true);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint32(${offset}, true);`;\n    },\n    deserializeJson(obj: unknown) {\n      return packColor(parseRGBAColorSpecification(obj));\n    },\n    serializeJson(value: number) {\n      return serializeColor(unpackRGBA(value));\n    },\n  },\n  float32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setFloat32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getFloat32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyFloat(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int32: {\n    serializedBytes() {\n      return 4;\n    },\n    alignment() {\n      return 4;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt32(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt32(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint16: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 2;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint16(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint16(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int16: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 2;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt16(${offset}, ${property}, isLittleEndian);`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt16(${offset}, isLittleEndian);`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  uint8: {\n    serializedBytes() {\n      return 1;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setUint8(${offset}, ${property});`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getUint8(${offset});`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n  int8: {\n    serializedBytes() {\n      return 2;\n    },\n    alignment() {\n      return 1;\n    },\n    serializeCode(property: string, offset: string) {\n      return `dv.setInt8(${offset}, ${property});`;\n    },\n    deserializeCode(property: string, offset: string) {\n      return `${property} = dv.getInt8(${offset});`;\n    },\n    deserializeJson(obj: unknown) {\n      return verifyInt(obj);\n    },\n    serializeJson(value: number) {\n      return value;\n    },\n  },\n};\n\n// Maximum stride value supported by WebGL.\nconst MAX_BUFFER_STRIDE = 255;\n\nexport function getPropertyOffsets(\n  rank: number,\n  firstGroupInitialOffset: number,\n  propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n): {\n  serializedBytes: number;\n  offsets: { group: number; offset: number }[];\n  propertyGroupBytes: number[];\n} {\n  let serializedBytes = 0;\n  const numProperties = propertySpecs.length;\n  const permutation = new Array<number>(numProperties);\n  const propertyGroupBytes: number[] = [];\n  for (let i = 0; i < numProperties; ++i) {\n    permutation[i] = i;\n  }\n  const getAlignment = (i: number) =>\n    annotationPropertyTypeHandlers[propertySpecs[i].type].alignment(rank);\n  permutation.sort((i, j) => getAlignment(j) - getAlignment(i));\n  let propertyGroupIndex = 0;\n  const offsets = new Array<{ group: number; offset: number }>(numProperties);\n  let propertyGroupOffset = firstGroupInitialOffset;\n  const nextPropertyGroup = () => {\n    propertyGroupOffset += (4 - (propertyGroupOffset % 4)) % 4;\n    serializedBytes += propertyGroupOffset;\n    propertyGroupBytes[propertyGroupIndex] = propertyGroupOffset;\n    propertyGroupOffset = 0;\n    ++propertyGroupIndex;\n  };\n  for (let outputIndex = 0; outputIndex < numProperties; ++outputIndex) {\n    const propertyIndex = permutation[outputIndex];\n    const spec = propertySpecs[propertyIndex];\n    const handler = annotationPropertyTypeHandlers[spec.type];\n    const numBytes = handler.serializedBytes(rank);\n    const alignment = handler.alignment(rank);\n    // Check if the property fits in the current property group.\n    const alignmentOffset =\n      (alignment - (propertyGroupOffset % alignment)) % alignment;\n    const newStartOffset = propertyGroupOffset + alignmentOffset;\n    const newEndOffset = newStartOffset + numBytes;\n    const newAlignedEndOffset = newEndOffset + ((4 - (newEndOffset % 4)) % 4);\n    if (newAlignedEndOffset <= MAX_BUFFER_STRIDE) {\n      // Property fits\n      propertyGroupOffset += alignmentOffset;\n    } else {\n      // Property does not fit.\n      nextPropertyGroup();\n    }\n    offsets[propertyIndex] = {\n      offset: propertyGroupOffset,\n      group: propertyGroupIndex,\n    };\n    propertyGroupOffset += numBytes;\n  }\n  nextPropertyGroup();\n  return { serializedBytes, offsets, propertyGroupBytes };\n}\n\nexport class AnnotationPropertySerializer {\n  serializedBytes: number;\n  serialize: (\n    buffer: DataView,\n    offset: number,\n    annotationIndex: number,\n    annotationCount: number,\n    isLittleEndian: boolean,\n    properties: any[],\n  ) => void;\n  deserialize: (\n    buffer: DataView,\n    offset: number,\n    annotationIndex: number,\n    annotationCount: number,\n    isLittleEndian: boolean,\n    properties: any[],\n  ) => void;\n  propertyGroupBytes: number[];\n  constructor(\n    public rank: number,\n    public firstGroupInitialOffset: number,\n    public propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n  ) {\n    if (propertySpecs.length === 0) {\n      this.serializedBytes = firstGroupInitialOffset;\n      this.serialize = this.deserialize = () => {};\n      this.propertyGroupBytes = [firstGroupInitialOffset];\n      return;\n    }\n    const { serializedBytes, offsets, propertyGroupBytes } = getPropertyOffsets(\n      rank,\n      firstGroupInitialOffset,\n      propertySpecs,\n    );\n    this.propertyGroupBytes = propertyGroupBytes;\n    let groupOffsetCode = \"let groupOffset0 = offset;\";\n    for (\n      let groupIndex = 1;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      groupOffsetCode += `let groupOffset${groupIndex} = groupOffset${\n        groupIndex - 1\n      } + ${propertyGroupBytes[groupIndex - 1]}*annotationCount;`;\n    }\n    for (\n      let groupIndex = 0;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      groupOffsetCode += `groupOffset${groupIndex} += ${propertyGroupBytes[groupIndex]}*annotationIndex;`;\n    }\n    let serializeCode = groupOffsetCode;\n    let deserializeCode = groupOffsetCode;\n    const numProperties = propertySpecs.length;\n    for (\n      let propertyIndex = 0;\n      propertyIndex < numProperties;\n      ++propertyIndex\n    ) {\n      const { group, offset } = offsets[propertyIndex];\n      const spec = propertySpecs[propertyIndex];\n      const handler = annotationPropertyTypeHandlers[spec.type];\n      const propId = `properties[${propertyIndex}]`;\n      const offsetExpr = `groupOffset${group} + ${offset}`;\n      serializeCode += handler.serializeCode(propId, offsetExpr, rank);\n      deserializeCode += handler.deserializeCode(propId, offsetExpr, rank);\n    }\n    this.serializedBytes = serializedBytes;\n    this.serialize = new Function(\n      \"dv\",\n      \"offset\",\n      \"annotationIndex\",\n      \"annotationCount\",\n      \"isLittleEndian\",\n      \"properties\",\n      serializeCode,\n    ) as any;\n    this.deserialize = new Function(\n      \"dv\",\n      \"offset\",\n      \"annotationIndex\",\n      \"annotationCount\",\n      \"isLittleEndian\",\n      \"properties\",\n      deserializeCode,\n    ) as any;\n  }\n}\n\nexport function makeAnnotationPropertySerializers(\n  rank: number,\n  propertySpecs: readonly Readonly<AnnotationPropertySpec>[],\n) {\n  const serializers: AnnotationPropertySerializer[] = [];\n  for (const annotationType of annotationTypes) {\n    const handler = annotationTypeHandlers[annotationType];\n    serializers[annotationType] = new AnnotationPropertySerializer(\n      rank,\n      handler.serializedBytes(rank),\n      propertySpecs,\n    );\n  }\n  return serializers;\n}\n\nexport function formatNumericProperty(\n  property: AnnotationNumericPropertySpec,\n  value: number,\n): string {\n  const formattedValue =\n    property.type === \"float32\" ? value.toPrecision(6) : value.toString();\n  const { enumValues, enumLabels } = property;\n  if (enumValues !== undefined) {\n    const enumIndex = enumValues.indexOf(value);\n    if (enumIndex !== -1) {\n      return `${enumLabels![enumIndex]} (${formattedValue})`;\n    }\n  }\n  return formattedValue;\n}\n\nexport function formatAnnotationPropertyValue(\n  property: AnnotationPropertySpec,\n  value: any,\n): string {\n  switch (property.type) {\n    case \"rgb\":\n      return serializeColor(unpackRGB(value));\n    case \"rgba\":\n      return serializeColor(unpackRGBA(value));\n    default:\n      return formatNumericProperty(property, value);\n  }\n}\n\nexport function parseAnnotationPropertyId(obj: unknown) {\n  const s = verifyString(obj);\n  if (s.match(/^[a-z][a-zA-Z0-9_]*$/) === null) {\n    throw new Error(`Invalid property identifier: ${JSON.stringify(obj)}`);\n  }\n  return s;\n}\n\nexport function parseAnnotationPropertyType(obj: unknown) {\n  verifyString(obj);\n  if (\n    !Object.prototype.hasOwnProperty.call(annotationPropertyTypeHandlers, obj)\n  ) {\n    throw new Error(\"Unsupported property type: $JSON.stringify(obj)}\");\n  }\n  return obj as AnnotationPropertySpec[\"type\"];\n}\n\nexport function ensureUniqueAnnotationPropertyIds(\n  properties: AnnotationPropertySpec[],\n) {\n  const ids = new Set<string>();\n  for (const p of properties) {\n    if (ids.has(p.identifier)) {\n      throw new Error(`Duplicate property identifier: ${p.identifier}`);\n    }\n    ids.add(p.identifier);\n  }\n}\n\nfunction parseAnnotationPropertySpec(obj: unknown): AnnotationPropertySpec {\n  verifyObject(obj);\n  const identifier = verifyObjectProperty(obj, \"id\", parseAnnotationPropertyId);\n  const type = verifyObjectProperty(obj, \"type\", parseAnnotationPropertyType);\n  const description = verifyOptionalObjectProperty(\n    obj,\n    \"description\",\n    verifyString,\n  );\n  const defaultValue = verifyOptionalObjectProperty(\n    obj,\n    \"default\",\n    (x) => annotationPropertyTypeHandlers[type].deserializeJson(x),\n    0,\n  );\n  let enumValues: number[] | undefined;\n  let enumLabels: string[] | undefined;\n  switch (type) {\n    case \"rgb\":\n    case \"rgba\":\n      break;\n    default: {\n      const dataType: DataType = DataType[type.toUpperCase() as any] as any;\n      enumValues = verifyOptionalObjectProperty(\n        obj,\n        \"enum_values\",\n        (valuesObj) =>\n          parseArray(\n            valuesObj,\n            (x) => parseDataTypeValue(dataType, x) as number,\n          ),\n      );\n      if (enumValues !== undefined) {\n        enumLabels = verifyObjectProperty(obj, \"enum_labels\", (labelsObj) =>\n          parseFixedLengthArray(\n            new Array<string>(enumValues!.length),\n            labelsObj,\n            verifyString,\n          ),\n        );\n      }\n    }\n  }\n  return {\n    type,\n    identifier,\n    description,\n    default: defaultValue,\n    enumValues,\n    enumLabels,\n  } as AnnotationPropertySpec;\n}\n\nfunction annotationPropertySpecToJson(spec: AnnotationPropertySpec) {\n  const defaultValue = spec.default;\n  const handler = annotationPropertyTypeHandlers[spec.type];\n  const isNumeric = isAnnotationNumericPropertySpec(spec);\n  const enumValues =\n    isNumeric && spec.enumValues\n      ? spec.enumValues.map(handler.serializeJson)\n      : undefined;\n  const enumLabels = isNumeric ? spec.enumLabels : undefined;\n  return {\n    id: spec.identifier,\n    description: spec.description,\n    type: spec.type,\n    default:\n      defaultValue === 0 ? undefined : handler.serializeJson(defaultValue),\n    enum_labels: enumLabels,\n    enum_values: enumValues,\n  };\n}\n\nexport function annotationPropertySpecsToJson(\n  specs: AnnotationPropertySpec[] | undefined,\n) {\n  if (specs === undefined || specs.length === 0) return undefined;\n  return specs.map(annotationPropertySpecToJson);\n}\n\nexport function parseAnnotationPropertySpecs(obj: unknown) {\n  if (obj === undefined) return [];\n  const properties = parseArray(obj, parseAnnotationPropertySpec);\n  ensureUniqueAnnotationPropertyIds(properties);\n  return properties;\n}\n\nexport interface AnnotationBase {\n  /**\n   * If equal to `undefined`, then the description is unknown (possibly still being loaded).  If\n   * equal to `null`, then there is no description.\n   */\n  description?: string | undefined | null;\n\n  id: AnnotationId;\n  type: AnnotationType;\n\n  relatedSegments?: BigUint64Array[];\n  properties: any[];\n}\n\nexport interface Line extends AnnotationBase {\n  pointA: Float32Array;\n  pointB: Float32Array;\n  type: AnnotationType.LINE;\n}\n\nexport interface Point extends AnnotationBase {\n  point: Float32Array;\n  type: AnnotationType.POINT;\n}\n\nexport interface AxisAlignedBoundingBox extends AnnotationBase {\n  pointA: Float32Array;\n  pointB: Float32Array;\n  type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX;\n}\n\nexport interface Ellipsoid extends AnnotationBase {\n  center: Float32Array;\n  radii: Float32Array;\n  type: AnnotationType.ELLIPSOID;\n}\n\nexport type Annotation = Line | Point | AxisAlignedBoundingBox | Ellipsoid;\n\nexport interface AnnotationTypeHandler<T extends Annotation = Annotation> {\n  icon: string;\n  description: string;\n  toJSON: (annotation: T, rank: number) => any;\n  restoreState: (annotation: T, obj: any, rank: number) => void;\n  serializedBytes: (rank: number) => number;\n  serialize: (\n    buffer: DataView,\n    offset: number,\n    isLittleEndian: boolean,\n    rank: number,\n    annotation: T,\n  ) => void;\n  deserialize: (\n    buffer: DataView,\n    offset: number,\n    isLittleEndian: boolean,\n    rank: number,\n    id: string,\n  ) => T;\n  visitGeometry: (\n    annotation: T,\n    callback: (vec: Float32Array, isVector: boolean) => void,\n  ) => void;\n}\n\nfunction serializeFloatVector(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vec: Float32Array,\n) {\n  for (let i = 0; i < rank; ++i) {\n    buffer.setFloat32(offset, vec[i], isLittleEndian);\n    offset += 4;\n  }\n  return offset;\n}\n\nfunction serializeTwoFloatVectors(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vecA: Float32Array,\n  vecB: Float32Array,\n) {\n  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);\n  offset = serializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);\n  return offset;\n}\n\nfunction deserializeFloatVector(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vec: Float32Array,\n) {\n  for (let i = 0; i < rank; ++i) {\n    vec[i] = buffer.getFloat32(offset, isLittleEndian);\n    offset += 4;\n  }\n  return offset;\n}\n\nfunction deserializeTwoFloatVectors(\n  buffer: DataView,\n  offset: number,\n  isLittleEndian: boolean,\n  rank: number,\n  vecA: Float32Array,\n  vecB: Float32Array,\n) {\n  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecA);\n  offset = deserializeFloatVector(buffer, offset, isLittleEndian, rank, vecB);\n  return offset;\n}\n\nexport const annotationTypeHandlers: Record<\n  AnnotationType,\n  AnnotationTypeHandler\n> = {\n  [AnnotationType.LINE]: {\n    icon: \"ꕹ\",\n    description: \"Line\",\n    toJSON(annotation: Line) {\n      return {\n        pointA: Array.from(annotation.pointA),\n        pointB: Array.from(annotation.pointB),\n      };\n    },\n    restoreState(annotation: Line, obj: any, rank: number) {\n      annotation.pointA = verifyObjectProperty(obj, \"pointA\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.pointB = verifyObjectProperty(obj, \"pointB\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes(rank: number) {\n      return 2 * 4 * rank;\n    },\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Line,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.pointA,\n        annotation.pointB,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Line => {\n      const pointA = new Float32Array(rank);\n      const pointB = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        pointA,\n        pointB,\n      );\n      return { type: AnnotationType.LINE, pointA, pointB, id, properties: [] };\n    },\n    visitGeometry(annotation: Line, callback) {\n      callback(annotation.pointA, false);\n      callback(annotation.pointB, false);\n    },\n  },\n  [AnnotationType.POINT]: {\n    icon: \"⚬\",\n    description: \"Point\",\n    toJSON: (annotation: Point) => {\n      return {\n        point: Array.from(annotation.point),\n      };\n    },\n    restoreState: (annotation: Point, obj: any, rank: number) => {\n      annotation.point = verifyObjectProperty(obj, \"point\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes: (rank) => rank * 4,\n    serialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Point,\n    ) => {\n      serializeFloatVector(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.point,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Point => {\n      const point = new Float32Array(rank);\n      deserializeFloatVector(buffer, offset, isLittleEndian, rank, point);\n      return { type: AnnotationType.POINT, point, id, properties: [] };\n    },\n    visitGeometry(annotation: Point, callback) {\n      callback(annotation.point, false);\n    },\n  },\n  [AnnotationType.AXIS_ALIGNED_BOUNDING_BOX]: {\n    icon: \"❑\",\n    description: \"Bounding Box\",\n    toJSON: (annotation: AxisAlignedBoundingBox) => {\n      return {\n        pointA: Array.from(annotation.pointA),\n        pointB: Array.from(annotation.pointB),\n      };\n    },\n    restoreState: (\n      annotation: AxisAlignedBoundingBox,\n      obj: any,\n      rank: number,\n    ) => {\n      annotation.pointA = verifyObjectProperty(obj, \"pointA\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.pointB = verifyObjectProperty(obj, \"pointB\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n    },\n    serializedBytes: (rank) => 2 * 4 * rank,\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: AxisAlignedBoundingBox,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.pointA,\n        annotation.pointB,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): AxisAlignedBoundingBox => {\n      const pointA = new Float32Array(rank);\n      const pointB = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        pointA,\n        pointB,\n      );\n      return {\n        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n        pointA,\n        pointB,\n        id,\n        properties: [],\n      };\n    },\n    visitGeometry(annotation: AxisAlignedBoundingBox, callback) {\n      callback(annotation.pointA, false);\n      callback(annotation.pointB, false);\n    },\n  },\n  [AnnotationType.ELLIPSOID]: {\n    icon: \"◎\",\n    description: \"Ellipsoid\",\n    toJSON: (annotation: Ellipsoid) => {\n      return {\n        center: Array.from(annotation.center),\n        radii: Array.from(annotation.radii),\n      };\n    },\n    restoreState: (annotation: Ellipsoid, obj: any, rank: number) => {\n      annotation.center = verifyObjectProperty(obj, \"center\", (x) =>\n        parseFixedLengthArray(new Float32Array(rank), x, verifyFiniteFloat),\n      );\n      annotation.radii = verifyObjectProperty(obj, \"radii\", (x) =>\n        parseFixedLengthArray(\n          new Float32Array(rank),\n          x,\n          verifyFiniteNonNegativeFloat,\n        ),\n      );\n    },\n    serializedBytes: (rank) => 2 * 4 * rank,\n    serialize(\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      annotation: Ellipsoid,\n    ) {\n      serializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        annotation.center,\n        annotation.radii,\n      );\n    },\n    deserialize: (\n      buffer: DataView,\n      offset: number,\n      isLittleEndian: boolean,\n      rank: number,\n      id: string,\n    ): Ellipsoid => {\n      const center = new Float32Array(rank);\n      const radii = new Float32Array(rank);\n      deserializeTwoFloatVectors(\n        buffer,\n        offset,\n        isLittleEndian,\n        rank,\n        center,\n        radii,\n      );\n      return {\n        type: AnnotationType.ELLIPSOID,\n        center,\n        radii,\n        id,\n        properties: [],\n      };\n    },\n    visitGeometry(annotation: Ellipsoid, callback) {\n      callback(annotation.center, false);\n      callback(annotation.radii, true);\n    },\n  },\n};\n\nexport interface AnnotationSchema {\n  rank: number;\n  relationships: readonly string[];\n  properties: readonly AnnotationPropertySpec[];\n}\n\nexport function annotationToJson(\n  annotation: Annotation,\n  schema: AnnotationSchema,\n) {\n  const result = annotationTypeHandlers[annotation.type].toJSON(\n    annotation,\n    schema.rank,\n  );\n  result.type = AnnotationType[annotation.type].toLowerCase();\n  result.id = annotation.id;\n  result.description = annotation.description || undefined;\n  const { relatedSegments } = annotation;\n  if (relatedSegments?.some((x) => x.length !== 0)) {\n    result.segments = relatedSegments.map((segments) =>\n      Array.from(segments, (x) => x.toString()),\n    );\n  }\n  if (schema.properties.length !== 0) {\n    const propertySpecs = schema.properties;\n    result.props = annotation.properties.map((prop, i) =>\n      annotationPropertyTypeHandlers[propertySpecs[i].type].serializeJson(prop),\n    );\n  }\n  return result;\n}\n\nfunction restoreAnnotation(\n  obj: any,\n  schema: AnnotationSchema,\n  allowMissingId = false,\n): Annotation {\n  verifyObject(obj);\n  const type = verifyObjectProperty(obj, \"type\", (x) =>\n    verifyEnumString(x, AnnotationType),\n  );\n  const id =\n    verifyObjectProperty(\n      obj,\n      \"id\",\n      allowMissingId ? verifyOptionalString : verifyString,\n    ) || makeAnnotationId();\n  const relatedSegments = verifyObjectProperty(obj, \"segments\", (relObj) => {\n    if (relObj === undefined) {\n      return schema.relationships.map(() => []);\n    }\n    const a = expectArray(relObj);\n    if (a.length === 0) {\n      return schema.relationships.map(() => []);\n    }\n    if (schema.relationships.length === 1 && !Array.isArray(a[0])) {\n      return [\n        parseFixedLengthArray(new BigUint64Array(a.length), a, parseUint64),\n      ];\n    }\n    return parseArray(\n      expectArray(relObj, schema.relationships.length),\n      (segments) => {\n        segments = expectArray(segments);\n        return parseFixedLengthArray(\n          new BigUint64Array(segments.length),\n          segments,\n          parseUint64,\n        );\n      },\n    );\n  });\n  const properties = verifyObjectProperty(obj, \"props\", (propsObj) => {\n    const propSpecs = schema.properties;\n    if (propsObj === undefined) return propSpecs.map((x) => x.default);\n    return parseArray(expectArray(propsObj, schema.properties.length), (x, i) =>\n      annotationPropertyTypeHandlers[propSpecs[i].type].deserializeJson(x),\n    );\n  });\n  const result: Annotation = {\n    id,\n    description: verifyObjectProperty(obj, \"description\", verifyOptionalString),\n    relatedSegments,\n    properties,\n    type,\n  } as Annotation;\n  annotationTypeHandlers[type].restoreState(result, obj, schema.rank);\n  return result;\n}\n\nexport interface AnnotationSourceSignals {\n  changed: NullarySignal;\n  childAdded: Signal<(annotation: Annotation) => void>;\n  childUpdated: Signal<(annotation: Annotation) => void>;\n  childCommitted: Signal<(annotationId: string) => void>;\n  childDeleted: Signal<(annotationId: string) => void>;\n}\n\nexport class AnnotationSource\n  extends RefCounted\n  implements AnnotationSourceSignals\n{\n  protected annotationMap = new Map<AnnotationId, Annotation>();\n  changed = new NullarySignal();\n  readonly = false;\n  childAdded = new Signal<(annotation: Annotation) => void>();\n  childUpdated = new Signal<(annotation: Annotation) => void>();\n  childCommitted = new Signal<(annotationId: string) => void>();\n  childDeleted = new Signal<(annotationId: string) => void>();\n\n  public pending = new Set<AnnotationId>();\n\n  protected rank_: number;\n\n  get rank() {\n    return this.rank_;\n  }\n\n  annotationPropertySerializers: AnnotationPropertySerializer[];\n\n  constructor(\n    rank: number,\n    public readonly relationships: readonly string[] = [],\n    public readonly properties: Readonly<AnnotationPropertySpec>[] = [],\n  ) {\n    super();\n    this.rank_ = rank;\n    this.annotationPropertySerializers = makeAnnotationPropertySerializers(\n      rank,\n      properties,\n    );\n  }\n\n  hasNonSerializedProperties() {\n    return true;\n  }\n\n  add(annotation: Annotation, commit = true): AnnotationReference {\n    this.ensureUpdated();\n    if (!annotation.id) {\n      annotation.id = makeAnnotationId();\n    } else if (this.annotationMap.has(annotation.id)) {\n      throw new Error(\n        `Annotation id already exists: ${JSON.stringify(annotation.id)}.`,\n      );\n    }\n    this.annotationMap.set(annotation.id, annotation);\n    if (!commit) {\n      this.pending.add(annotation.id);\n    }\n    this.changed.dispatch();\n    this.childAdded.dispatch(annotation);\n    if (commit) {\n      this.childCommitted.dispatch(annotation.id);\n    }\n    return this.getReference(annotation.id);\n  }\n\n  commit(reference: AnnotationReference): void {\n    this.ensureUpdated();\n    const id = reference.id;\n    this.pending.delete(id);\n    this.changed.dispatch();\n    this.childCommitted.dispatch(id);\n  }\n\n  update(reference: AnnotationReference, annotation: Annotation) {\n    this.ensureUpdated();\n    if (reference.value === null) {\n      throw new Error(\"Annotation already deleted.\");\n    }\n    reference.value = annotation;\n    this.annotationMap.set(annotation.id, annotation);\n    reference.changed.dispatch();\n    this.changed.dispatch();\n    this.childUpdated.dispatch(annotation);\n  }\n\n  [Symbol.iterator]() {\n    this.ensureUpdated();\n    return this.annotationMap.values();\n  }\n\n  get(id: AnnotationId) {\n    this.ensureUpdated();\n    return this.annotationMap.get(id);\n  }\n\n  delete(reference: AnnotationReference) {\n    if (reference.value === null) {\n      return;\n    }\n    reference.value = null;\n    this.annotationMap.delete(reference.id);\n    this.pending.delete(reference.id);\n    reference.changed.dispatch();\n    this.changed.dispatch();\n    this.childDeleted.dispatch(reference.id);\n  }\n\n  getReference(id: AnnotationId): AnnotationReference {\n    let existing = this.references.get(id);\n    if (existing !== undefined) {\n      return existing.addRef();\n    }\n    existing = new AnnotationReference(id);\n    existing.value = this.annotationMap.get(id) || null;\n    this.references.set(id, existing);\n    existing.registerDisposer(() => {\n      this.references.delete(id);\n    });\n    return existing;\n  }\n\n  references = new Map<AnnotationId, Borrowed<AnnotationReference>>();\n\n  protected ensureUpdated() {}\n\n  toJSON() {\n    this.ensureUpdated();\n    const result: any[] = [];\n    const { pending } = this;\n    for (const annotation of this) {\n      if (pending.has(annotation.id)) {\n        // Don't serialize uncommitted annotations.\n        continue;\n      }\n      result.push(annotationToJson(annotation, this));\n    }\n    return result;\n  }\n\n  clear() {\n    this.annotationMap.clear();\n    this.pending.clear();\n    this.changed.dispatch();\n  }\n\n  restoreState(obj: any) {\n    this.ensureUpdated();\n    const { annotationMap } = this;\n    annotationMap.clear();\n    this.pending.clear();\n    if (obj !== undefined) {\n      parseArray(obj, (x) => {\n        const annotation = restoreAnnotation(x, this);\n        annotationMap.set(annotation.id, annotation);\n      });\n    }\n    for (const reference of this.references.values()) {\n      const { id } = reference;\n      const value = annotationMap.get(id);\n      reference.value = value || null;\n      reference.changed.dispatch();\n    }\n    this.changed.dispatch();\n  }\n\n  reset() {\n    this.clear();\n  }\n}\n\nexport class LocalAnnotationSource extends AnnotationSource {\n  private curCoordinateTransform: CoordinateSpaceTransform;\n\n  get rank() {\n    this.ensureUpdated();\n    return this.rank_;\n  }\n\n  constructor(\n    public watchableTransform: WatchableCoordinateSpaceTransform,\n    properties: AnnotationPropertySpec[],\n    relationships: string[],\n  ) {\n    super(watchableTransform.value.sourceRank, relationships, properties);\n    this.curCoordinateTransform = watchableTransform.value;\n    this.registerDisposer(\n      watchableTransform.changed.add(() => this.ensureUpdated()),\n    );\n  }\n\n  ensureUpdated() {\n    const transform = this.watchableTransform.value;\n    const { curCoordinateTransform } = this;\n    if (transform === curCoordinateTransform) return;\n    this.curCoordinateTransform = transform;\n    const sourceRank = transform.sourceRank;\n    const oldSourceRank = curCoordinateTransform.sourceRank;\n    if (\n      oldSourceRank === sourceRank &&\n      (curCoordinateTransform.inputSpace === transform.inputSpace ||\n        arraysEqual(\n          curCoordinateTransform.inputSpace.ids.slice(0, sourceRank),\n          transform.inputSpace.ids.slice(0, sourceRank),\n        ))\n    ) {\n      return;\n    }\n    const { ids: newIds } = transform.inputSpace;\n    const oldIds = curCoordinateTransform.inputSpace.ids;\n    const newToOldDims: number[] = [];\n    for (let newDim = 0; newDim < sourceRank; ++newDim) {\n      let oldDim = oldIds.indexOf(newIds[newDim]);\n      if (oldDim >= oldSourceRank) {\n        oldDim = -1;\n      }\n      newToOldDims.push(oldDim);\n    }\n    const mapVector = (radii: Float32Array) => {\n      const newRadii = new Float32Array(sourceRank);\n      for (let i = 0; i < sourceRank; ++i) {\n        const oldDim = newToOldDims[i];\n        newRadii[i] = oldDim === -1 ? 0 : radii[i];\n      }\n      return newRadii;\n    };\n\n    for (const annotation of this.annotationMap.values()) {\n      switch (annotation.type) {\n        case AnnotationType.POINT:\n          annotation.point = mapVector(annotation.point);\n          break;\n        case AnnotationType.LINE:\n        case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX:\n          annotation.pointA = mapVector(annotation.pointA);\n          annotation.pointB = mapVector(annotation.pointB);\n          break;\n        case AnnotationType.ELLIPSOID:\n          annotation.center = mapVector(annotation.center);\n          annotation.radii = mapVector(annotation.radii);\n          break;\n      }\n    }\n    if (this.rank_ !== sourceRank) {\n      this.rank_ = sourceRank;\n      this.annotationPropertySerializers = makeAnnotationPropertySerializers(\n        this.rank_,\n        this.properties,\n      );\n    }\n    this.changed.dispatch();\n  }\n}\n\nexport const DATA_BOUNDS_DESCRIPTION = \"Data Bounds\";\n\nexport function makeAnnotationId() {\n  return getRandomHexString(160);\n}\n\nexport function makeDataBoundsBoundingBoxAnnotation(\n  box: BoundingBox,\n): AxisAlignedBoundingBox {\n  return {\n    type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n    id: \"data-bounds\",\n    description: DATA_BOUNDS_DESCRIPTION,\n    pointA: new Float32Array(box.lowerBounds),\n    pointB: new Float32Array(box.upperBounds),\n    properties: [],\n  };\n}\n\nexport function makeDataBoundsBoundingBoxAnnotationSet(\n  box: BoundingBox,\n): AnnotationSource {\n  const annotationSource = new AnnotationSource(box.lowerBounds.length);\n  annotationSource.readonly = true;\n  annotationSource.add(makeDataBoundsBoundingBoxAnnotation(box));\n  return annotationSource;\n}\n\nexport interface SerializedAnnotations {\n  data: Uint8Array<ArrayBuffer>;\n  typeToIds: string[][];\n  typeToOffset: number[];\n  typeToIdMaps: Map<string, number>[];\n}\n\nfunction serializeAnnotations(\n  allAnnotations: Annotation[][],\n  propertySerializers: AnnotationPropertySerializer[],\n): SerializedAnnotations {\n  let totalBytes = 0;\n  const typeToOffset: number[] = [];\n  for (const annotationType of annotationTypes) {\n    const propertySerializer = propertySerializers[annotationType];\n    const serializedPropertiesBytes = propertySerializer.serializedBytes;\n    typeToOffset[annotationType] = totalBytes;\n    const annotations: Annotation[] = allAnnotations[annotationType];\n    const count = annotations.length;\n    totalBytes += serializedPropertiesBytes * count;\n  }\n  const typeToIds: string[][] = [];\n  const typeToIdMaps: Map<string, number>[] = [];\n  const data = new ArrayBuffer(totalBytes);\n  const dataView = new DataView(data);\n  const isLittleEndian = ENDIANNESS === Endianness.LITTLE;\n  for (const annotationType of annotationTypes) {\n    const propertySerializer = propertySerializers[annotationType];\n    const { rank } = propertySerializer;\n    const serializeProperties = propertySerializer.serialize;\n    const annotations: Annotation[] = allAnnotations[annotationType];\n    typeToIds[annotationType] = annotations.map((x) => x.id);\n    typeToIdMaps[annotationType] = new Map(\n      annotations.map((x, i) => [x.id, i]),\n    );\n    const handler = annotationTypeHandlers[annotationType];\n    const serialize = handler.serialize;\n    const offset = typeToOffset[annotationType];\n    const geometryDataStride = propertySerializer.propertyGroupBytes[0];\n    for (let i = 0, count = annotations.length; i < count; ++i) {\n      const annotation = annotations[i];\n      serialize(\n        dataView,\n        offset + i * geometryDataStride,\n        isLittleEndian,\n        rank,\n        annotation,\n      );\n      serializeProperties(\n        dataView,\n        offset,\n        i,\n        count,\n        isLittleEndian,\n        annotation.properties,\n      );\n    }\n  }\n  return { data: new Uint8Array(data), typeToIds, typeToOffset, typeToIdMaps };\n}\n\nexport class AnnotationSerializer {\n  annotations: [Point[], Line[], AxisAlignedBoundingBox[], Ellipsoid[]] = [\n    [],\n    [],\n    [],\n    [],\n  ];\n  constructor(public propertySerializers: AnnotationPropertySerializer[]) {}\n  add(annotation: Annotation) {\n    (<Annotation[]>this.annotations[annotation.type]).push(annotation);\n  }\n  serialize(): SerializedAnnotations {\n    return serializeAnnotations(this.annotations, this.propertySerializers);\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { NIFTI2 } from \"nifti-reader-js\";\nimport { isCompressed, NIFTI1, readHeader, readImage } from \"nifti-reader-js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { getCachedDecodedUrl } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { NiftiVolumeInfo } from \"#src/datasource/nifti/base.js\";\nimport {\n  GET_NIFTI_VOLUME_INFO_RPC_ID,\n  VolumeSourceParameters,\n} from \"#src/datasource/nifti/base.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { ReadResponse } from \"#src/kvstore/index.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { DataType } from \"#src/sliceview/volume/base.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport {\n  kOneVec,\n  mat4,\n  quat,\n  translationRotationScaleZReflectionToMat4,\n  vec3,\n} from \"#src/util/geom.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport type { RPCPromise } from \"#src/worker_rpc.js\";\nimport { registerPromiseRPC, registerSharedObject } from \"#src/worker_rpc.js\";\n\nexport class NiftiFileData {\n  uncompressedData: ArrayBuffer;\n  header: NIFTI1 | NIFTI2;\n}\n\nasync function decodeNiftiFile(\n  readResponse: ReadResponse,\n  options: ProgressOptions,\n) {\n  let buffer = await readResponse.response.arrayBuffer();\n  if (isCompressed(buffer)) {\n    buffer = await decodeGzip(buffer, \"gzip\", options.signal);\n  }\n  const data = new NiftiFileData();\n  data.uncompressedData = buffer;\n  const header = readHeader(buffer);\n  if (header === null) {\n    throw new Error(\"Failed to parse NIFTI header.\");\n  }\n  data.header = header;\n  return { data, size: buffer.byteLength };\n}\n\nfunction getNiftiFileData(\n  sharedKvStoreContextCounterpart: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  return getCachedDecodedUrl(\n    sharedKvStoreContextCounterpart,\n    url,\n    decodeNiftiFile,\n    options,\n  );\n}\n\nasync function getNiftiHeaderInfo(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  const data = await getNiftiFileData(sharedKvStoreContext, url, options);\n  return data.header;\n}\n\nfunction convertAffine(affine: number[][]) {\n  return mat4.fromValues(\n    affine[0][0],\n    affine[1][0],\n    affine[2][0],\n    affine[3][0],\n    affine[0][1],\n    affine[1][1],\n    affine[2][1],\n    affine[3][1],\n    affine[0][2],\n    affine[1][2],\n    affine[2][2],\n    affine[3][2],\n    affine[0][3],\n    affine[1][3],\n    affine[2][3],\n    affine[3][3],\n  );\n}\n\nenum NiftiDataType {\n  NONE = 0,\n  BINARY = 1,\n  UINT8 = 2,\n  INT16 = 4,\n  INT32 = 8,\n  FLOAT32 = 16,\n  COMPLEX64 = 32,\n  FLOAT64 = 64,\n  RGB24 = 128,\n  INT8 = 256,\n  UINT16 = 512,\n  UINT32 = 768,\n  INT64 = 1024,\n  UINT64 = 1280,\n  FLOAT128 = 1536,\n  COMPLEX128 = 1792,\n  COMPLEX256 = 2048,\n}\n\nconst DATA_TYPE_CONVERSIONS = new Map([\n  [NiftiDataType.INT8, { dataType: DataType.INT8 }],\n  [NiftiDataType.UINT8, { dataType: DataType.UINT8 }],\n  [NiftiDataType.INT16, { dataType: DataType.INT16 }],\n  [NiftiDataType.UINT16, { dataType: DataType.UINT16 }],\n  [NiftiDataType.INT32, { dataType: DataType.INT32 }],\n  [NiftiDataType.UINT32, { dataType: DataType.UINT32 }],\n  [NiftiDataType.INT64, { dataType: DataType.UINT64 }],\n  [NiftiDataType.UINT64, { dataType: DataType.UINT64 }],\n  [NiftiDataType.FLOAT32, { dataType: DataType.FLOAT32 }],\n]);\n\nregisterPromiseRPC(\n  GET_NIFTI_VOLUME_INFO_RPC_ID,\n  async function (x, progressOptions): RPCPromise<NiftiVolumeInfo> {\n    const sharedKvStoreContext = this.get(\n      x.sharedKvStoreContext,\n    ) as SharedKvStoreContextCounterpart;\n    const header = await getNiftiHeaderInfo(\n      sharedKvStoreContext,\n      x.url,\n      progressOptions,\n    );\n    const dataTypeInfo = DATA_TYPE_CONVERSIONS.get(header.datatypeCode);\n    if (dataTypeInfo === undefined) {\n      throw new Error(\n        \"Unsupported data type: \" +\n          `${NiftiDataType[header.datatypeCode] || header.datatypeCode}.`,\n      );\n    }\n    let spatialInvScale = 1;\n    let spatialUnit = \"\";\n    switch (header.xyzt_units & NIFTI1.SPATIAL_UNITS_MASK) {\n      case NIFTI1.UNITS_METER:\n        spatialInvScale = 1;\n        spatialUnit = \"m\";\n        break;\n      case NIFTI1.UNITS_MM:\n        spatialInvScale = 1e3;\n        spatialUnit = \"m\";\n        break;\n      case NIFTI1.UNITS_MICRON:\n        spatialInvScale = 1e6;\n        spatialUnit = \"m\";\n        break;\n    }\n\n    let timeUnit = \"\";\n    let timeInvScale = 1;\n    switch (header.xyzt_units & NIFTI1.TEMPORAL_UNITS_MASK) {\n      case NIFTI1.UNITS_SEC:\n        timeUnit = \"s\";\n        timeInvScale = 1;\n        break;\n      case NIFTI1.UNITS_MSEC:\n        timeUnit = \"s\";\n        timeInvScale = 1e3;\n        break;\n      case NIFTI1.UNITS_USEC:\n        timeUnit = \"s\";\n        timeInvScale = 1e6;\n        break;\n      case NIFTI1.UNITS_HZ:\n        timeUnit = \"Hz\";\n        timeInvScale = 1;\n        break;\n      case NIFTI1.UNITS_RADS:\n        timeUnit = \"rad/s\";\n        timeInvScale = 1;\n        break;\n    }\n    let units: string[] = [\n      spatialUnit,\n      spatialUnit,\n      spatialUnit,\n      timeUnit,\n      \"\",\n      \"\",\n      \"\",\n    ];\n    let sourceScales = Float64Array.of(\n      header.pixDims[1] / spatialInvScale,\n      header.pixDims[2] / spatialInvScale,\n      header.pixDims[3] / spatialInvScale,\n      header.pixDims[4] / timeInvScale,\n      header.pixDims[5],\n      header.pixDims[6],\n      header.pixDims[7],\n    );\n    let viewScales = Float64Array.of(\n      1 / spatialInvScale,\n      1 / spatialInvScale,\n      1 / spatialInvScale,\n      1 / timeInvScale,\n      1,\n      1,\n      1,\n    );\n    let sourceNames = [\"i\", \"j\", \"k\", \"m\", \"c^\", \"c1^\", \"c2^\"];\n    let viewNames = [\"x\", \"y\", \"z\", \"t\", \"c^\", \"c1^\", \"c2^\"];\n    const rank = header.dims[0];\n    sourceNames = sourceNames.slice(0, rank);\n    viewNames = viewNames.slice(0, rank);\n    units = units.slice(0, rank);\n    sourceScales = sourceScales.slice(0, rank);\n    viewScales = viewScales.slice(0, rank);\n    const { quatern_b, quatern_c, quatern_d } = header;\n    const quatern_a = Math.sqrt(\n      1.0 -\n        quatern_b * quatern_b -\n        quatern_c * quatern_c -\n        quatern_d * quatern_d,\n    );\n    const qfac = header.pixDims[0] === -1 ? -1 : 1;\n    const qoffset = vec3.fromValues(\n      header.qoffset_x,\n      header.qoffset_y,\n      header.qoffset_z,\n    );\n    // https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/qsform.html\n    const method3Transform = convertAffine(header.affine);\n    method3Transform;\n    const method2Transform = translationRotationScaleZReflectionToMat4(\n      mat4.create(),\n      qoffset,\n      quat.fromValues(quatern_b, quatern_c, quatern_d, quatern_a),\n      kOneVec,\n      qfac,\n    );\n    const transform = matrix.createIdentity(Float64Array, rank + 1);\n    const copyRank = Math.min(3, rank);\n    for (let row = 0; row < copyRank; ++row) {\n      for (let col = 0; col < copyRank; ++col) {\n        transform[col * (rank + 1) + row] = method2Transform[col * 4 + row];\n      }\n      transform[rank * (rank + 1) + row] = method2Transform[12 + row];\n    }\n    const info: NiftiVolumeInfo = {\n      rank,\n      sourceNames,\n      viewNames,\n      units,\n      sourceScales,\n      viewScales,\n      description: header.description,\n      transform,\n      dataType: dataTypeInfo.dataType,\n      volumeSize: Uint32Array.from(header.dims.slice(1, 1 + rank)),\n    };\n    return { value: info };\n  },\n);\n\n@registerSharedObject()\nexport class NiftiVolumeChunkSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(VolumeChunkSource),\n  VolumeSourceParameters,\n) {\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n    const data = await getNiftiFileData(\n      this.sharedKvStoreContext,\n      this.parameters.url,\n      { signal },\n    );\n    const imageBuffer = readImage(data.header, data.uncompressedData);\n    await decodeRawChunk(\n      chunk,\n      signal,\n      imageBuffer,\n      data.header.littleEndian ? Endianness.LITTLE : Endianness.BIG,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Chunk,\n  ChunkSource,\n  withChunkManager,\n  WithParameters,\n} from \"#src/chunk_manager/backend.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { computeVertexNormals } from \"#src/mesh/backend.js\";\nimport type {\n  SingleMeshData,\n  SingleMeshInfo,\n  SingleMeshSourceParameters,\n  VertexAttributeInfo,\n} from \"#src/single_mesh/base.js\";\nimport {\n  GET_SINGLE_MESH_INFO_RPC_ID,\n  SINGLE_MESH_CHUNK_KEY,\n  SINGLE_MESH_LAYER_RPC_ID,\n  SingleMeshSourceParametersWithInfo,\n} from \"#src/single_mesh/base.js\";\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport { stableStringify } from \"#src/util/json.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC, RPCPromise } from \"#src/worker_rpc.js\";\nimport {\n  registerPromiseRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst SINGLE_MESH_CHUNK_PRIORITY = 50;\n\n/**\n * Chunk that contains the single mesh.\n */\nexport class SingleMeshChunk extends Chunk {\n  data: SingleMeshData | null = null;\n  freeSystemMemory() {\n    this.data = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const { vertexPositions, indices, vertexNormals, vertexAttributes } =\n      this.data!;\n    msg.vertexPositions = vertexPositions;\n    msg.indices = indices;\n    msg.vertexNormals = vertexNormals;\n    msg.vertexAttributes = vertexAttributes;\n    const transferSet = new Set<ArrayBuffer>();\n    transferSet.add(vertexPositions!.buffer);\n    transferSet.add(indices!.buffer);\n    transferSet.add(vertexNormals!.buffer);\n    for (const data of vertexAttributes!) {\n      transferSet.add(data.buffer);\n    }\n    transfers.push(...transferSet);\n    this.data = null;\n  }\n  downloadSucceeded() {\n    const { vertexPositions, indices, vertexNormals, vertexAttributes } =\n      this.data!;\n    let totalBytes = (this.gpuMemoryBytes =\n      vertexPositions.byteLength +\n      indices.byteLength +\n      vertexNormals!.byteLength);\n    for (const data of vertexAttributes) {\n      totalBytes += data.byteLength;\n    }\n    this.systemMemoryBytes = this.gpuMemoryBytes = totalBytes;\n    super.downloadSucceeded();\n  }\n}\n\nexport interface SingleMesh extends SingleMeshData {\n  info: SingleMeshInfo;\n}\n\nexport interface SingleMeshVertexAttributes {\n  numVertices: number;\n  attributeInfo: VertexAttributeInfo[];\n  attributes: Float32Array[];\n}\n\ninterface SingleMeshFactory {\n  description?: string;\n  getMesh: (\n    sharedKvStoreContext: SharedKvStoreContextCounterpart,\n    url: string,\n    options: Partial<ProgressOptions>,\n  ) => Promise<SingleMesh>;\n}\n\nconst singleMeshFactories = new Map<string, SingleMeshFactory>();\nexport function registerSingleMeshFactory(\n  name: string,\n  factory: SingleMeshFactory,\n) {\n  singleMeshFactories.set(name, factory);\n}\n\nconst protocolPattern = /^(?:([a-zA-Z-+_]+):\\/\\/)?(.*)$/;\n\nfunction getDataSource<T>(\n  factories: Map<string, T>,\n  url: string,\n): [T, string, string] {\n  const m = url.match(protocolPattern);\n  if (m === null || m[1] === undefined) {\n    throw new Error(\n      `Data source URL must have the form \"<protocol>://<path>\".`,\n    );\n  }\n  const dataSource = m[1];\n  const factory = factories.get(dataSource);\n  if (factory === undefined) {\n    throw new Error(`Unsupported data source: ${JSON.stringify(dataSource)}.`);\n  }\n  return [factory, m[2], dataSource];\n}\n\nexport function getMesh(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  const [factory, path] = getDataSource(singleMeshFactories, url);\n  return factory.getMesh(sharedKvStoreContext, path, options);\n}\n\nexport function getMinMax(array: TypedNumberArray): [number, number] {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const value of array) {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  }\n  return [min, max];\n}\n\nexport function getCombinedMesh(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  parameters: SingleMeshSourceParameters,\n  options: Partial<ProgressOptions>,\n) {\n  return getMesh(sharedKvStoreContext, parameters.meshSourceUrl, options);\n}\n\n@registerSharedObject()\nexport class SingleMeshSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(ChunkSource),\n  SingleMeshSourceParametersWithInfo,\n) {\n  getChunk() {\n    const key = SINGLE_MESH_CHUNK_KEY;\n    let chunk = <SingleMeshChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(SingleMeshChunk);\n      chunk.initialize(key);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  async download(chunk: SingleMeshChunk, signal: AbortSignal) {\n    const data = await getCombinedMesh(\n      this.sharedKvStoreContext,\n      this.parameters,\n      {\n        signal,\n      },\n    );\n    if (stableStringify(data.info) !== stableStringify(this.parameters.info)) {\n      throw new Error(\"Mesh info has changed.\");\n    }\n    if (data.vertexNormals === undefined) {\n      data.vertexNormals = computeVertexNormals(\n        data.vertexPositions,\n        data.indices,\n      );\n    }\n    chunk.data = data;\n  }\n}\n\nconst SingleMeshLayerBase = withSharedVisibility(\n  withChunkManager(SharedObjectCounterpart),\n);\n@registerSharedObject(SINGLE_MESH_LAYER_RPC_ID)\nexport class SingleMeshLayer extends SingleMeshLayerBase {\n  source: SingleMeshSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<SingleMeshSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    const chunk = source.getChunk();\n    chunkManager.requestChunk(\n      chunk,\n      priorityTier,\n      basePriority + SINGLE_MESH_CHUNK_PRIORITY,\n    );\n  }\n}\n\nregisterPromiseRPC(\n  GET_SINGLE_MESH_INFO_RPC_ID,\n  async function (x, progressOptions): RPCPromise<SingleMeshInfo> {\n    const sharedKvStoreContext = this.get(\n      x.sharedKvStoreContext,\n    ) as SharedKvStoreContextCounterpart;\n    const parameters = <SingleMeshSourceParameters>x.parameters;\n    const mesh = await getCombinedMesh(\n      sharedKvStoreContext,\n      parameters,\n      progressOptions,\n    );\n    return { value: mesh.info };\n  },\n);\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CodecArrayInfo,\n  CodecArrayLayoutInfo,\n  CodecChainSpec,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport {\n  parseCodecChainSpec,\n  registerCodec,\n} from \"#src/datasource/zarr/codec/resolve.js\";\nimport { parseChunkShape } from \"#src/datasource/zarr/metadata/parse.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport {\n  verifyEnumString,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n} from \"#src/util/json.js\";\n\nexport enum ShardIndexLocation {\n  START,\n  END,\n}\n\nexport interface IndexConfiguration {\n  indexCodecs: CodecChainSpec;\n  indexLocation: ShardIndexLocation;\n}\n\nexport interface Configuration extends IndexConfiguration {\n  subChunkCodecs: CodecChainSpec;\n  subChunkShape: number[];\n  subChunkGridShape: number[];\n}\n\nregisterCodec({\n  name: \"sharding_indexed\",\n  kind: CodecKind.arrayToBytes,\n  resolve(configuration: unknown, decodedArrayInfo: CodecArrayInfo) {\n    verifyObject(configuration);\n    const subChunkShape = verifyObjectProperty(\n      configuration,\n      \"chunk_shape\",\n      (value) => parseChunkShape(value, decodedArrayInfo.chunkShape.length),\n    );\n    const indexLocation = verifyOptionalObjectProperty(\n      configuration,\n      \"index_location\",\n      (x) => verifyEnumString(x, ShardIndexLocation, /^[a-z]+$/),\n      ShardIndexLocation.END,\n    );\n    const subChunkGridShape = Array.from(\n      decodedArrayInfo.chunkShape,\n      (outerSize, i) => {\n        const innerSize = subChunkShape[i];\n        if (outerSize % innerSize !== 0) {\n          throw new Error(\n            `sub-chunk shape of ${JSON.stringify(\n              innerSize,\n            )} does not evenly divide outer chunk shape of ${JSON.stringify(\n              decodedArrayInfo.chunkShape,\n            )}`,\n          );\n        }\n        return outerSize / innerSize;\n      },\n    );\n    const indexShape = Array.from(subChunkGridShape);\n    indexShape.push(2);\n    const indexCodecs = verifyObjectProperty(\n      configuration,\n      \"index_codecs\",\n      (value) =>\n        parseCodecChainSpec(value, {\n          dataType: DataType.UINT64,\n          chunkShape: indexShape,\n        }),\n    );\n    if (\n      indexCodecs.encodedSize[indexCodecs.encodedSize.length - 1] === undefined\n    ) {\n      throw new Error(\"index_codecs must specify fixed-size encoding\");\n    }\n    const subChunkCodecs = verifyObjectProperty(\n      configuration,\n      \"codecs\",\n      (value) =>\n        parseCodecChainSpec(value, {\n          dataType: decodedArrayInfo.dataType,\n          chunkShape: subChunkShape,\n        }),\n    );\n    return {\n      configuration: {\n        indexCodecs,\n        subChunkCodecs,\n        subChunkShape,\n        subChunkGridShape,\n        indexLocation,\n      },\n      shardingInfo: { subChunkShape, subChunkGridShape, subChunkCodecs },\n    };\n  },\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n  ): CodecArrayLayoutInfo {\n    decodedArrayInfo;\n    return configuration.subChunkCodecs.layoutInfo[0];\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CodecArrayInfo,\n  CodecArrayLayoutInfo,\n  CodecChainSpec,\n  CodecSpec,\n  ShardingInfo,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { parseNameAndConfiguration } from \"#src/datasource/zarr/metadata/parse_util.js\";\nimport { parseArray } from \"#src/util/json.js\";\n\nfunction getCodecResolver(obj: unknown): {\n  resolver: CodecResolver;\n  configuration: unknown;\n} {\n  const { name: resolver, configuration } = parseNameAndConfiguration(\n    obj,\n    (name) => {\n      const resolver = codecRegistry.get(name);\n      if (resolver === undefined) {\n        throw new Error(`Unknown codec: ${JSON.stringify(name)}`);\n      }\n      return resolver;\n    },\n    (configuration) => configuration,\n  );\n  return { resolver, configuration };\n}\n\nexport interface CodecResolver {\n  name: string;\n  kind: CodecKind;\n}\n\nexport interface ArrayToArrayCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.arrayToArray;\n  resolve(\n    configuration: unknown,\n    decodedArrayInfo: CodecArrayInfo,\n  ): {\n    configuration: Configuration;\n    encodedArrayInfo: CodecArrayInfo;\n  };\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encodedLayout: CodecArrayLayoutInfo,\n  ): CodecArrayLayoutInfo;\n}\n\nexport interface ArrayToBytesCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.arrayToBytes;\n  resolve(\n    configuration: unknown,\n    decodedArrayInfo: CodecArrayInfo,\n  ): {\n    configuration: Configuration;\n    shardingInfo?: ShardingInfo;\n    encodedSize?: number;\n  };\n  getDecodedArrayLayoutInfo(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n  ): CodecArrayLayoutInfo;\n}\n\nexport interface BytesToBytesCodecResolver<Configuration>\n  extends CodecResolver {\n  kind: CodecKind.bytesToBytes;\n  resolve(\n    configuration: unknown,\n    decodedSize: number | undefined,\n  ): {\n    configuration: Configuration;\n    encodedSize?: number;\n  };\n}\n\nconst codecRegistry = new Map<string, CodecResolver>();\n\nexport function registerCodec<Configuration>(\n  resolver:\n    | ArrayToArrayCodecResolver<Configuration>\n    | ArrayToBytesCodecResolver<Configuration>\n    | BytesToBytesCodecResolver<Configuration>,\n) {\n  codecRegistry.set(resolver.name, resolver);\n}\n\nexport function parseCodecChainSpec(\n  obj: unknown,\n  decodedArrayInfo: CodecArrayInfo,\n): CodecChainSpec {\n  const arrayToArray: CodecSpec<CodecKind.arrayToArray>[] = [];\n  const arrayInfo: CodecArrayInfo[] = [];\n  const layoutInfo: CodecArrayLayoutInfo[] = [];\n  const encodedSize: (number | undefined)[] = [];\n\n  arrayInfo.push(decodedArrayInfo);\n\n  const codecSpecs = parseArray(obj, getCodecResolver);\n  const numCodecs = codecSpecs.length;\n  let i = 0;\n\n  for (; i < numCodecs; ++i) {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    if (resolver.kind !== CodecKind.arrayToArray) {\n      break;\n    }\n    const arrayResolver = resolver as ArrayToArrayCodecResolver<unknown>;\n    const { configuration, encodedArrayInfo } = arrayResolver.resolve(\n      initialConfiguration,\n      decodedArrayInfo,\n    );\n    arrayInfo.push(encodedArrayInfo);\n    decodedArrayInfo = encodedArrayInfo;\n    arrayToArray.push({\n      kind: CodecKind.arrayToArray,\n      name: resolver.name,\n      configuration,\n    });\n  }\n\n  if (\n    i === numCodecs ||\n    codecSpecs[i].resolver.kind !== CodecKind.arrayToBytes\n  ) {\n    throw new Error(\"Missing array -> bytes codec\");\n  }\n\n  const {\n    codecSpec: arrayToBytes,\n    layoutInfo: finalLayoutInfo,\n    encodedSize: initialEncodedSize,\n    shardingInfo,\n  } = (() => {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    const arrayToBytesResolver = resolver as ArrayToBytesCodecResolver<unknown>;\n    const { configuration, shardingInfo, encodedSize } =\n      arrayToBytesResolver.resolve(initialConfiguration, decodedArrayInfo);\n    if (shardingInfo !== undefined) {\n      if (i + 1 !== numCodecs) {\n        throw new Error(\n          \"bytes -> bytes codecs not supported following sharding codec\",\n        );\n      }\n    }\n    const layoutInfo = arrayToBytesResolver.getDecodedArrayLayoutInfo(\n      configuration,\n      decodedArrayInfo,\n    );\n    const codecSpec: CodecSpec<CodecKind.arrayToBytes> = {\n      name: resolver.name,\n      kind: CodecKind.arrayToBytes,\n      configuration,\n    };\n    return { codecSpec, layoutInfo, encodedSize, shardingInfo };\n  })();\n\n  layoutInfo[i] = finalLayoutInfo;\n  encodedSize.push(initialEncodedSize);\n  const curEncodedSize = initialEncodedSize;\n\n  const bytesToBytes: CodecSpec<CodecKind.bytesToBytes>[] = [];\n\n  ++i;\n\n  while (i < numCodecs) {\n    const { resolver, configuration: initialConfiguration } = codecSpecs[i];\n    if (resolver.kind !== CodecKind.bytesToBytes) {\n      throw new Error(\n        `Expected bytes -> bytes codec, but received ${JSON.stringify(\n          resolver.name,\n        )} of kind ${CodecKind[resolver.kind]}`,\n      );\n    }\n    const bytesResolver = resolver as BytesToBytesCodecResolver<unknown>;\n    const { configuration, encodedSize: newEncodedSize } =\n      bytesResolver.resolve(initialConfiguration, curEncodedSize);\n    bytesToBytes.push({\n      name: resolver.name,\n      kind: resolver.kind,\n      configuration,\n    });\n    encodedSize.push(newEncodedSize);\n    ++i;\n  }\n\n  for (let j = arrayToArray.length - 1; j >= 0; --j) {\n    layoutInfo[j] = (\n      codecSpecs[j].resolver as ArrayToArrayCodecResolver<unknown>\n    ).getDecodedArrayLayoutInfo(\n      arrayToArray[j].configuration,\n      arrayInfo[j],\n      layoutInfo[j + 1],\n    );\n  }\n\n  return {\n    [CodecKind.arrayToArray]: arrayToArray,\n    [CodecKind.arrayToBytes]: arrayToBytes,\n    [CodecKind.bytesToBytes]: bytesToBytes,\n    arrayInfo,\n    layoutInfo,\n    shardingInfo,\n    encodedSize,\n  };\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buf as crc32cbuf } from \"crc-32/crc32c.js\";\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { decodeLeb128, decodeLeb128Bigint } from \"#src/util/leb128.js\";\n\nexport enum CompressionMethod {\n  UNCOMPRESSED = 0,\n  ZSTD = 1,\n}\n\nexport async function decodeEnvelope(\n  buffer: ArrayBuffer,\n  expectedMagic: number,\n  maxVersion: number,\n  signal: AbortSignal,\n): Promise<{\n  reader: Reader;\n  version: number;\n}> {\n  if (buffer.byteLength < 4 + 8 + 4 + 2) {\n    throw new Error(\"Unexpected EOF\");\n  }\n  const dv = new DataView(buffer);\n  const magic = dv.getUint32(0, /*littleEndian=*/ false);\n  if (magic !== expectedMagic) {\n    throw new Error(\n      `Expected magic value 0x${expectedMagic.toString(16)} but received 0x${magic.toString(16)}`,\n    );\n  }\n  const length = dv.getBigUint64(4, /*littleEndian=*/ true);\n  if (length != BigInt(buffer.byteLength)) {\n    throw new Error(\n      `Expected length ${buffer.byteLength} but received: ${length}`,\n    );\n  }\n\n  const checksum = dv.getUint32(buffer.byteLength - 4, /*littleEndian=*/ true);\n  const actualChecksum =\n    crc32cbuf(new Uint8Array(buffer, 0, buffer.byteLength - 4)) >>> 0;\n  if (checksum != actualChecksum) {\n    throw new Error(\n      `Expected CRC32c checksum of ${checksum}, but received ${actualChecksum}`,\n    );\n  }\n\n  // Technically this is a varint, but all currentl-supported values are 1 byte.\n  const version = dv.getUint8(12);\n  if (version > maxVersion) {\n    throw new Error(\n      `Expected version to be <= ${maxVersion}, but received: ${version}`,\n    );\n  }\n\n  const compressionFormat = dv.getUint8(13);\n  let content = new Uint8Array(buffer, 14, buffer.byteLength - 14 - 4);\n  switch (compressionFormat) {\n    case CompressionMethod.UNCOMPRESSED:\n      // uncompressed\n      break;\n    case CompressionMethod.ZSTD:\n      // zstd\n      content = await requestAsyncComputation(\n        decodeZstd,\n        signal,\n        [buffer],\n        content,\n      );\n      break;\n    default:\n      throw new Error(`Unknown compression format ${compressionFormat}`);\n  }\n  return {\n    reader: {\n      offset: 0,\n      data: new DataView(\n        content.buffer,\n        content.byteOffset,\n        content.byteLength,\n      ),\n    },\n    version,\n  };\n}\n\nexport interface Reader {\n  offset: number;\n  data: DataView<ArrayBuffer>;\n}\n\nexport function readBytes(\n  reader: Reader,\n  count: number,\n): Uint8Array<ArrayBuffer> {\n  const { offset, data } = reader;\n  if (offset + count > data.byteLength) {\n    throw new Error(`Unexpected EOF`);\n  }\n  reader.offset += count;\n  return new Uint8Array(data.buffer, data.byteOffset + offset, count);\n}\n\nexport function readLeb128(reader: Reader): number {\n  const { value, offset } = decodeLeb128(reader.data, reader.offset);\n  reader.offset = offset;\n  return value;\n}\n\nexport function readLeb128Bigint(reader: Reader): bigint {\n  const { value, offset } = decodeLeb128Bigint(reader.data, reader.offset);\n  reader.offset = offset;\n  return value;\n}\n\nexport function readLeb128Bounded(reader: Reader, maxValue: number): number {\n  const value = readLeb128(reader);\n  if (value > maxValue) {\n    throw new Error(`Expected value <= ${maxValue}, but received: ${value}`);\n  }\n  return value;\n}\n\nexport function readUint8(reader: Reader): number {\n  const { offset, data } = reader;\n  if (offset + 1 > data.byteLength) {\n    throw new Error(`Unexpected EOF`);\n  }\n  reader.offset += 1;\n  return data.getUint8(offset);\n}\n\nexport function readInt32le(reader: Reader): number {\n  const { offset, data } = reader;\n  if (offset + 4 > data.byteLength) {\n    throw new Error(`Unexpected EOF`);\n  }\n  reader.offset += 4;\n  return data.getInt32(offset, /*littleEndian=*/ true);\n}\n\nexport function readUint64le(reader: Reader): bigint {\n  const { offset, data } = reader;\n  if (offset + 8 > data.byteLength) {\n    throw new Error(`Unexpected EOF`);\n  }\n  reader.offset += 8;\n  return data.getBigUint64(offset, /*littleEndian=*/ true);\n}\n\nexport function ensureEof(reader: Reader) {\n  if (reader.offset !== reader.data.byteLength) {\n    throw new Error(`Expected EOF at byte ${reader.offset}`);\n  }\n}\n\nexport type ArrayReader<T, Options> = (\n  reader: Reader,\n  count: number,\n  options: Options,\n) => T[];\n\nexport function readArrayOf<T, Options>(\n  readElement: (reader: Reader, options: Options) => T,\n): ArrayReader<T, Options> {\n  return (reader, count, options) => {\n    const values: T[] = [];\n    for (let i = 0; i < count; ++i) {\n      values[i] = readElement(reader, options);\n    }\n    return values;\n  };\n}\n\ntype StructOfArrays<T> = {\n  [Property in keyof T]: ArrayLike<T[Property]>;\n} & Record<keyof T, ArrayLike<unknown>>;\n\ntype StructOfArrayReaders<T, Options> = Record<\n  string,\n  ArrayReader<unknown, Options>\n> & {\n  [Property in keyof T]: ArrayReader<T[Property], Options>;\n};\n\nexport function toArrayOfStructs<T>(\n  count: number,\n  arrays: StructOfArrays<T>,\n): T[] {\n  const keys = Object.keys(arrays) as (keyof T)[];\n  const structs: T[] = [];\n  for (let i = 0; i < count; ++i) {\n    const value = Object.fromEntries(\n      keys.map((key) => [key, arrays[key][i]]),\n    ) as T;\n    structs[i] = value;\n  }\n  return structs;\n}\n\nexport function readStructOfArrays<T, Options extends object = object>(\n  members: StructOfArrayReaders<T, Options>,\n  validate?: (value: T, options: Options) => void,\n): ArrayReader<T, Options> {\n  return (reader, count, options) => {\n    const arrays = Object.fromEntries(\n      Object.entries(members).map(([key, read]) => [\n        key,\n        read(reader, count, options),\n      ]),\n    ) as StructOfArrays<T>;\n    const structs = toArrayOfStructs<T>(count, arrays);\n    if (validate !== undefined) {\n      for (let i = 0; i < count; ++i) {\n        validate?.(structs[i], options);\n      }\n    }\n    return structs;\n  };\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Derived from https://github.com/greggman/unzipit/blob/4d94c9b77f7815062ff4460311e8b3ce4f7d5deb/src/unzipit.js\n *\n * Includes only parsing of raw entries.\n *\n * @license\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Josh Wolfe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * MIT License\n *\n * Copyright (c) 2019 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { buf as crc32buf } from \"crc-32\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nexport interface ZipEntry {\n  versionMadeBy: number;\n  versionNeededToExtract: number;\n  generalPurposeBitFlag: number;\n  compressionMethod: number;\n  lastModFileTime: number;\n  lastModFileDate: number;\n  crc32: number;\n  compressedSize: number;\n  uncompressedSize: number;\n  nameBytes: Uint8Array<ArrayBuffer>;\n  commentBytes: Uint8Array<ArrayBuffer>;\n  internalFileAttributes: number;\n  externalFileAttributes: number;\n  relativeOffsetOfLocalHeader: number;\n  fileName: string;\n}\n\nexport interface ZipMetadata {\n  entries: ZipEntry[];\n  commentBytes: Uint8Array<ArrayBuffer>;\n  // Estimated size in bytes of metadata.\n  sizeEstimate: number;\n}\n\nexport const EOCDR_WITHOUT_COMMENT_SIZE = 22;\nexport const MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nexport interface Reader {\n  (\n    offset: number,\n    length: number,\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<Uint8Array<ArrayBuffer>>;\n}\n\nfunction lastReadCachingReader(base: Reader) {\n  let lastReadOffset: number = 0;\n  let lastReadBuffer: Uint8Array<ArrayBuffer> | undefined;\n\n  return async function lastReadCachingRead(\n    offset: number,\n    length: number,\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<Uint8Array<ArrayBuffer>> {\n    if (lastReadBuffer !== undefined) {\n      if (\n        offset > lastReadOffset &&\n        offset + length <= lastReadOffset + lastReadBuffer.length\n      ) {\n        return lastReadBuffer.subarray(\n          offset - lastReadOffset,\n          offset + length - lastReadOffset,\n        );\n      }\n    }\n\n    const newBuffer = await base(offset, length, progressOptions);\n    lastReadOffset = offset;\n    lastReadBuffer = newBuffer;\n    return newBuffer;\n  };\n}\n\nexport function parseEndOfCentralDirectoryRecord(data: Uint8Array):\n  | {\n      eocdrOffset: number;\n      diskNumber: number;\n      entryCount: number;\n      centralDirectorySize: number;\n      centralDirectoryOffset: number;\n    }\n  | undefined {\n  const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  const size = data.length;\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    // 0 - End of central directory signature\n    if (dv.getUint32(i, /*littleEndian=*/ true) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 20 - Comment length\n    const commentLength = dv.getUint16(i + 20, /*littleEndian=*/ true);\n    const expectedCommentLength = size - i - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      continue;\n    }\n\n    // 4 - Number of this disk\n    const diskNumber = dv.getUint16(i + 4, /*littleEndian=*/ true);\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = dv.getUint16(i + 10, /*littleEndian=*/ true);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = dv.getUint32(i + 12, /*littleEndian=*/ true);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = dv.getUint32(i + 16, /*littleEndian=*/ true);\n\n    return {\n      eocdrOffset: i,\n      diskNumber,\n      entryCount,\n      centralDirectorySize,\n      centralDirectoryOffset,\n    };\n  }\n\n  return undefined;\n}\n\nasync function findEndOfCentralDirectory(\n  reader: Reader,\n  totalLength: number,\n  options: Partial<ProgressOptions>,\n) {\n  const size = Math.min(\n    EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE,\n    totalLength,\n  );\n  const readStart = totalLength - size;\n  const data = await reader(readStart, size, options);\n  const record = parseEndOfCentralDirectoryRecord(data);\n  if (record === undefined) {\n    throw new Error(\n      \"End of central directory record signature not found; either not a zip file or file is truncated.\",\n    );\n  }\n  const {\n    eocdrOffset,\n    diskNumber,\n    entryCount,\n    centralDirectorySize,\n    centralDirectoryOffset,\n  } = record;\n  if (diskNumber !== 0) {\n    throw new Error(\n      `Multi-volume zip files are not supported. This is volume: ${diskNumber}`,\n    );\n  }\n\n  // 22 - Comment\n  // the encoding is always cp437.\n  const commentBytes = data.slice(eocdrOffset + 22, data.length);\n\n  if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n    return await readZip64CentralDirectory(\n      reader,\n      eocdrOffset,\n      commentBytes,\n      options,\n    );\n  } else {\n    return await readEntries(\n      reader,\n      centralDirectoryOffset,\n      centralDirectorySize,\n      entryCount,\n      commentBytes,\n      options,\n    );\n  }\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(\n  reader: Reader,\n  offset: number,\n  commentBytes: Uint8Array<ArrayBuffer>,\n  progressOptions: Partial<ProgressOptions>,\n) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await reader(zip64EocdlOffset, 20, progressOptions);\n\n  const eocdlDv = new DataView(\n    eocdl.buffer,\n    eocdl.byteOffset,\n    eocdl.byteLength,\n  );\n\n  // 0 - zip64 end of central dir locator signature\n  if (\n    eocdlDv.getUint32(0, /*littleEndian=*/ true) !==\n    END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE\n  ) {\n    throw new Error(\"invalid zip64 end of central directory locator signature\");\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = eocdlDv.getBigUint64(8, /*littleEndian=*/ true);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await reader(\n    Number(zip64EocdrOffset),\n    56,\n    progressOptions,\n  );\n\n  const zip64EocdrDv = new DataView(\n    zip64Eocdr.buffer,\n    zip64Eocdr.byteOffset,\n    zip64Eocdr.byteLength,\n  );\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (\n    zip64EocdrDv.getUint32(0, /*littleEndian=*/ true) !== ZIP64_EOCDR_SIGNATURE\n  ) {\n    throw new Error(\"invalid zip64 end of central directory record signature\");\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = zip64EocdrDv.getBigUint64(32, /*littleEndian=*/ true);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = zip64EocdrDv.getBigUint64(\n    40,\n    /*littleEndian=*/ true,\n  );\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = zip64EocdrDv.getBigUint64(\n    48,\n    /*littleEndian=*/ true,\n  );\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(\n    reader,\n    Number(centralDirectoryOffset),\n    Number(centralDirectorySize),\n    Number(entryCount),\n    commentBytes,\n    progressOptions,\n  );\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(\n  reader: Reader,\n  centralDirectoryOffset: number,\n  centralDirectorySize: number,\n  rawEntryCount: number,\n  commentBytes: Uint8Array<ArrayBuffer>,\n  progressOptions: Partial<ProgressOptions>,\n): Promise<ZipMetadata> {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await reader(\n    centralDirectoryOffset,\n    centralDirectorySize,\n    progressOptions,\n  );\n  const rawEntries = [];\n\n  const dv = new DataView(\n    allEntriesBuffer.buffer,\n    allEntriesBuffer.byteOffset,\n    allEntriesBuffer.byteLength,\n  );\n\n  const textDecoder = new TextDecoder();\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    // 0 - Central directory file header signature\n    const signature = dv.getUint32(readEntryCursor + 0, /*littleEndian=*/ true);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(\n        `invalid central directory file header signature: 0x${signature.toString(16)}`,\n      );\n    }\n    // 4 - Version made by\n    const versionMadeBy = dv.getUint16(\n      readEntryCursor + 4,\n      /*littleEndian=*/ true,\n    );\n    // 6 - Version needed to extract (minimum)\n    const versionNeededToExtract = dv.getUint16(\n      readEntryCursor + 6,\n      /*littleEndian=*/ true,\n    );\n    // 8 - General purpose bit flag\n    const generalPurposeBitFlag = dv.getUint16(\n      readEntryCursor + 8,\n      /*littleEndian=*/ true,\n    );\n    // 10 - Compression method\n    const compressionMethod = dv.getUint16(\n      readEntryCursor + 10,\n      /*littleEndian=*/ true,\n    );\n    // 12 - File last modification time\n    const lastModFileTime = dv.getUint16(\n      readEntryCursor + 12,\n      /*littleEndian=*/ true,\n    );\n    // 14 - File last modification date\n    const lastModFileDate = dv.getUint16(\n      readEntryCursor + 14,\n      /*littleEndian=*/ true,\n    );\n    // 16 - CRC-32\n    const crc32 = dv.getUint32(readEntryCursor + 16, /*littleEndian=*/ true);\n    // 20 - Compressed size\n    let compressedSize = dv.getUint32(\n      readEntryCursor + 20,\n      /*littleEndian=*/ true,\n    );\n    // 24 - Uncompressed size\n    let uncompressedSize = dv.getUint32(\n      readEntryCursor + 24,\n      /*littleEndian=*/ true,\n    );\n    // 28 - File name length (n)\n    const fileNameLength = dv.getUint16(\n      readEntryCursor + 28,\n      /*littleEndian=*/ true,\n    );\n    // 30 - Extra field length (m)\n    const extraFieldLength = dv.getUint16(\n      readEntryCursor + 30,\n      /*littleEndian=*/ true,\n    );\n    // 32 - File comment length (k)\n    const fileCommentLength = dv.getUint16(\n      readEntryCursor + 32,\n      /*littleEndian=*/ true,\n    );\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    const internalFileAttributes = dv.getUint16(\n      readEntryCursor + 36,\n      /*littleEndian=*/ true,\n    );\n    // 38 - External file attributes\n    const externalFileAttributes = dv.getUint32(\n      readEntryCursor + 38,\n      /*littleEndian=*/ true,\n    );\n    // 42 - Relative offset of local file header\n    let relativeOffsetOfLocalHeader = dv.getUint32(\n      readEntryCursor + 42,\n      /*littleEndian=*/ true,\n    );\n\n    if (generalPurposeBitFlag & 0x40) {\n      throw new Error(\"strong encryption is not supported\");\n    }\n\n    readEntryCursor += 46;\n\n    // 46 - File name\n    let nameBytes = allEntriesBuffer.subarray(\n      readEntryCursor,\n      (readEntryCursor += fileNameLength),\n    );\n\n    let isUTF8 = (generalPurposeBitFlag & 0x800) !== 0;\n\n    // 46+n - Extra field\n    const extraFields = [];\n    for (let i = 0; i < extraFieldLength - 3; ) {\n      const headerId = dv.getUint16(\n        readEntryCursor + i + 0,\n        /*littleEndian=*/ true,\n      );\n      const dataSize = dv.getUint16(\n        readEntryCursor + i + 2,\n        /*littleEndian=*/ true,\n      );\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldLength) {\n        throw new Error(\"extra field length exceeds extra field buffer size\");\n      }\n      extraFields.push({\n        id: headerId,\n        offset: readEntryCursor + dataStart,\n        length: dataSize,\n      });\n      i = dataEnd;\n    }\n    readEntryCursor += extraFieldLength;\n\n    // 46+n+m - File comment\n    const commentBytes = allEntriesBuffer.slice(\n      readEntryCursor,\n      (readEntryCursor += fileCommentLength),\n    );\n\n    if (\n      uncompressedSize === 0xffffffff ||\n      compressedSize === 0xffffffff ||\n      relativeOffsetOfLocalHeader === 0xffffffff\n    ) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = extraFields.find((e) => e.id === 0x0001);\n      if (zip64ExtraField === undefined) {\n        throw new Error(\"expected zip64 extended information extra field\");\n      }\n      const { offset: zip64EiefBufferOffset, length: zip64EiefBufferLength } =\n        zip64ExtraField;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBufferLength) {\n          throw new Error(\n            \"zip64 extended information extra field does not include uncompressed size\",\n          );\n        }\n        uncompressedSize = Number(\n          dv.getBigUint64(\n            zip64EiefBufferOffset + index,\n            /*littleEndian=*/ true,\n          ),\n        );\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBufferLength) {\n          throw new Error(\n            \"zip64 extended information extra field does not include compressed size\",\n          );\n        }\n        compressedSize = Number(\n          dv.getBigUint64(\n            zip64EiefBufferOffset + index,\n            /*littleEndian=*/ true,\n          ),\n        );\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBufferLength) {\n          throw new Error(\n            \"zip64 extended information extra field does not include relative header offset\",\n          );\n        }\n        relativeOffsetOfLocalHeader = Number(\n          dv.getBigUint64(\n            zip64EiefBufferOffset + index,\n            /*littleEndian=*/ true,\n          ),\n        );\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = extraFields.find(\n      (e) =>\n        e.id === 0x7075 &&\n        e.length >= 6 && // too short to be meaningful\n        allEntriesBuffer[e.offset] === 1 && // Version       1 byte      version of this extra field, currently 1\n        dv.getInt32(e.offset + 1, /*littleEndian=*/ true) ===\n          crc32buf(nameBytes),\n    ); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n    // > If the CRC check fails, this UTF-8 Path Extra Field should be\n    // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n      nameBytes = allEntriesBuffer.slice(\n        nameField.offset + 5,\n        nameField.offset + nameField.length,\n      );\n      isUTF8 = true;\n    }\n\n    // validate file size\n    if (compressionMethod === 0) {\n      let expectedCompressedSize = uncompressedSize;\n      if ((generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (compressedSize !== expectedCompressedSize) {\n        throw new Error(\n          `compressed/uncompressed size mismatch for stored file: ${compressedSize} != ${expectedCompressedSize}`,\n        );\n      }\n    }\n\n    // Just decode as UTF-8 regardless of `isUTF8`, because the non-UTF8\n    // encoding is difficult/impossible to determine correctly.\n    let fileName = textDecoder.decode(nameBytes);\n    fileName = fileName.replaceAll(\"\\\\\", \"/\");\n    isUTF8;\n\n    const rawEntry: ZipEntry = {\n      versionMadeBy,\n      versionNeededToExtract,\n      generalPurposeBitFlag,\n      compressionMethod,\n      lastModFileTime,\n      lastModFileDate,\n      crc32,\n      compressedSize,\n      uncompressedSize,\n      nameBytes,\n      commentBytes,\n      internalFileAttributes,\n      externalFileAttributes,\n      relativeOffsetOfLocalHeader,\n      fileName,\n    };\n    rawEntries.push(rawEntry);\n  }\n  return {\n    commentBytes,\n    entries: rawEntries,\n    // Estimate that the JavaScript representation consumes twice the memory of\n    // the encoded representation.\n    sizeEstimate: commentBytes.length + allEntriesBuffer.length * 2,\n  };\n}\n\nexport async function readEntryDataHeader(\n  reader: Reader,\n  rawEntry: ZipEntry,\n  options: Partial<ProgressOptions>,\n) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error(\"encrypted entries not supported\");\n  }\n  const data = await reader(rawEntry.relativeOffsetOfLocalHeader, 30, options);\n  const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = dv.getUint32(0, /*littleEndian=*/ true);\n  if (signature !== 0x04034b50) {\n    throw new Error(\n      `invalid local file header signature: 0x${signature.toString(16)}`,\n    );\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = dv.getUint16(26, /*littleEndian=*/ true);\n  // 28 - Extra field length (m)\n  const extraFieldLength = dv.getUint16(28, /*littleEndian=*/ true);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd =\n    rawEntry.relativeOffsetOfLocalHeader +\n    data.length +\n    fileNameLength +\n    extraFieldLength;\n\n  return localFileHeaderEnd;\n}\n\nexport async function readZipMetadata(\n  reader: Reader,\n  totalLength: number,\n  options: Partial<ProgressOptions>,\n): Promise<ZipMetadata> {\n  return await findEndOfCentralDirectory(\n    lastReadCachingReader(reader),\n    totalLength,\n    options,\n  );\n}\n\nexport enum ZipCompressionMethod {\n  STORE = 0,\n  DEFLATE = 8,\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { promiseWithResolversAndAbortCallback } from \"#src/util/abort.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport type {\n  ProgressListener,\n  ProgressOptions,\n  ProgressSpanId,\n} from \"#src/util/progress_listener.js\";\nimport { ProgressSpan } from \"#src/util/progress_listener.js\";\n\nexport type RPCHandler = (this: RPC, x: any) => void;\n\nexport type RpcId = number;\n\nconst IS_WORKER = !(typeof Window !== \"undefined\" && self instanceof Window);\n\nconst DEBUG = false;\n\nconst DEBUG_MESSAGES = false;\n\nconst PROMISE_RESPONSE_ID = \"rpc.promise.response\";\nconst PROMISE_CANCEL_ID = \"rpc.promise.cancel\";\nconst PROMISE_PROGRESS_ADD_SPAN_ID = \"rpc.promise.addProgressSpan\";\nconst PROMISE_PROGRESS_REMOVE_SPAN_ID = \"rpc.promise.removeProgressSpan\";\nconst READY_ID = \"rpc.ready\";\n\nconst handlers = new Map<string, RPCHandler>();\n\nexport function registerRPC(key: string, handler: RPCHandler) {\n  handlers.set(key, handler);\n}\n\nexport type RPCPromise<T> = Promise<{ value: T; transfers?: any[] }>;\n\nclass ProxyProgressListener implements ProgressListener {\n  constructor(\n    private rpc: RPC,\n    private id: number,\n  ) {}\n\n  addSpan(span: ProgressSpan) {\n    this.rpc.invoke(PROMISE_PROGRESS_ADD_SPAN_ID, {\n      id: this.id,\n      span: {\n        id: span.id,\n        message: span.message,\n        startTime: span.startTime,\n      },\n    });\n  }\n  removeSpan(spanId: ProgressSpanId) {\n    this.rpc.invoke(PROMISE_PROGRESS_REMOVE_SPAN_ID, {\n      id: this.id,\n      spanId,\n    });\n  }\n}\n\nexport function registerPromiseRPC<T>(\n  key: string,\n  handler: (\n    this: RPC,\n    x: any,\n    progressOptions: Partial<ProgressOptions>,\n  ) => RPCPromise<T>,\n) {\n  registerRPC(key, function (this: RPC, x: any) {\n    const id = <number>x.id;\n    const abortController = new AbortController();\n    let progressListener: ProgressListener | undefined;\n    if (x.progressListener === true) {\n      progressListener = new ProxyProgressListener(this, id);\n    }\n    const promise = handler.call(this, x, {\n      signal: abortController.signal,\n      progressListener,\n    }) as RPCPromise<T>;\n    this.set(id, { promise, abortController });\n    promise.then(\n      ({ value, transfers }) => {\n        this.delete(id);\n        this.invoke(PROMISE_RESPONSE_ID, { id: id, value: value }, transfers);\n      },\n      (error) => {\n        this.delete(id);\n        this.invoke(PROMISE_RESPONSE_ID, {\n          id: id,\n          error: error,\n        });\n      },\n    );\n  });\n}\n\nregisterRPC(PROMISE_CANCEL_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const request = this.get(id);\n  if (request !== undefined) {\n    const { abortController } = request;\n    abortController.abort();\n  }\n});\n\nregisterRPC(PROMISE_RESPONSE_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const { resolve, reject } = this.get(id);\n  this.delete(id);\n  if (Object.prototype.hasOwnProperty.call(x, \"value\")) {\n    resolve(x.value);\n  } else {\n    reject(x.error);\n  }\n});\n\nregisterRPC(PROMISE_PROGRESS_ADD_SPAN_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const { progressListener } = this.get(id);\n  new ProgressSpan(progressListener, x.span);\n});\n\nregisterRPC(PROMISE_PROGRESS_REMOVE_SPAN_ID, function (this: RPC, x: any) {\n  const id = <number>x.id;\n  const { progressListener } = this.get(id);\n  progressListener.removeSpan(x.spanId);\n});\n\nregisterRPC(READY_ID, function (this: RPC, x: any) {\n  x;\n  this.onPeerReady();\n});\n\ninterface RPCTarget {\n  postMessage(message?: any, ports?: any): void;\n  onmessage: ((ev: MessageEvent) => any) | null;\n}\n\nconst INITIAL_RPC_ID = IS_WORKER ? -1 : 0;\n\nexport class RPC {\n  private objects = new Map<RpcId, any>();\n  private nextId: RpcId = INITIAL_RPC_ID;\n  private queue: { data: any; transfers?: any[] }[] | undefined;\n  constructor(\n    public target: RPCTarget,\n    waitUntilReady: boolean,\n  ) {\n    if (waitUntilReady) {\n      this.queue = [];\n    }\n    target.onmessage = (e) => {\n      const data = e.data;\n      if (DEBUG_MESSAGES) {\n        console.log(\"Received message\", data);\n      }\n      const handler = handlers.get(data.functionName);\n      if (handler === undefined) {\n        throw new Error(`Missing RPC function: ${data.functionName}`);\n      }\n      handlers.get(data.functionName)!.call(this, data);\n    };\n  }\n\n  sendReady() {\n    this.invoke(READY_ID, {});\n  }\n\n  onPeerReady() {\n    const { queue } = this;\n    if (queue === undefined) return;\n    this.queue = undefined;\n    for (const { data, transfers } of queue) {\n      this.target.postMessage(data, transfers);\n    }\n  }\n\n  get numObjects() {\n    return this.objects.size;\n  }\n\n  set(id: RpcId, value: any) {\n    this.objects.set(id, value);\n  }\n\n  delete(id: RpcId) {\n    this.objects.delete(id);\n  }\n  get(id: RpcId) {\n    return this.objects.get(id);\n  }\n  getRef<T extends SharedObject>(x: { id: RpcId; gen: number }): T {\n    const rpcId = x.id;\n    const obj = <T>this.get(rpcId);\n    obj.referencedGeneration = x.gen;\n    obj.addRef();\n    return obj;\n  }\n\n  getOptionalRef<T extends SharedObject>(x: {\n    id: RpcId;\n    gen: number;\n  }): T | undefined {\n    if (x === undefined) return undefined;\n    const rpcId = x.id;\n    const obj = this.get(rpcId) as T;\n    obj.referencedGeneration = x.gen;\n    obj.addRef();\n    return obj;\n  }\n\n  invoke(name: string, x: any, transfers?: any[]) {\n    x.functionName = name;\n    if (DEBUG_MESSAGES) {\n      console.trace(\"Sending message\", x);\n    }\n    const { queue } = this;\n    if (queue !== undefined) {\n      queue.push({ data: x, transfers });\n      return;\n    }\n    this.target.postMessage(x, transfers);\n  }\n\n  promiseInvoke<T>(\n    name: string,\n    x: any,\n    options?: {\n      signal?: AbortSignal;\n      progressListener?: ProgressListener;\n      transfers?: any[];\n    },\n  ): Promise<T> {\n    let signal: AbortSignal | undefined;\n    let progressListener: ProgressListener | undefined;\n    let transfers: any[] | undefined;\n    if (options !== undefined) {\n      ({ signal, progressListener, transfers } = options);\n    }\n    if (signal?.aborted) {\n      return Promise.reject(signal.reason);\n    }\n    if (progressListener !== undefined) {\n      x.progressListener = true;\n    }\n    const id = (x.id = this.newId());\n    this.invoke(name, x, transfers);\n    const { promise, resolve, reject } =\n      signal === undefined\n        ? Promise.withResolvers<T>()\n        : promiseWithResolversAndAbortCallback<T>(signal, () => {\n            this.invoke(PROMISE_CANCEL_ID, { id: id });\n          });\n    this.set(id, { resolve, reject, progressListener });\n    return promise;\n  }\n\n  newId() {\n    return IS_WORKER ? this.nextId-- : this.nextId++;\n  }\n}\n\nexport class SharedObject extends RefCounted {\n  rpc: RPC | null = null;\n  rpcId: RpcId | null = null;\n  isOwner: boolean | undefined;\n  unreferencedGeneration: number;\n  referencedGeneration: number;\n\n  initializeSharedObject(rpc: RPC, rpcId = rpc.newId()) {\n    this.rpc = rpc;\n    this.rpcId = rpcId;\n    this.isOwner = false;\n    rpc.set(rpcId, this);\n  }\n\n  initializeCounterpart(rpc: RPC, options: any = {}) {\n    this.initializeSharedObject(rpc);\n    this.unreferencedGeneration = 0;\n    this.referencedGeneration = 0;\n    this.isOwner = true;\n    options.id = this.rpcId;\n    options.type = this.RPC_TYPE_ID;\n    rpc.invoke(\"SharedObject.new\", options);\n  }\n\n  dispose() {\n    super.dispose();\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   */\n  addCounterpartRef() {\n    return { id: this.rpcId, gen: ++this.referencedGeneration };\n  }\n\n  protected refCountReachedZero() {\n    if (this.isOwner === true) {\n      if (this.referencedGeneration === this.unreferencedGeneration) {\n        this.ownerDispose();\n      }\n    } else if (this.isOwner === false) {\n      this.rpc!.invoke(\"SharedObject.refCountReachedZero\", {\n        id: this.rpcId,\n        gen: this.referencedGeneration,\n      });\n    } else {\n      super.refCountReachedZero();\n    }\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   */\n  protected ownerDispose() {\n    if (DEBUG) {\n      console.log(`[${IS_WORKER}] #rpc object = ${this.rpc!.numObjects}`);\n    }\n    const { rpc, rpcId } = this;\n    super.refCountReachedZero();\n    rpc!.delete(rpcId!);\n    rpc!.invoke(\"SharedObject.dispose\", { id: rpcId });\n  }\n\n  /**\n   * Precondition: this.isOwner === true.\n   *\n   * This should be called when the counterpart's refCount is decremented and reaches zero.\n   */\n  counterpartRefCountReachedZero(generation: number) {\n    this.unreferencedGeneration = generation;\n    if (this.refCount === 0 && generation === this.referencedGeneration) {\n      this.ownerDispose();\n    }\n  }\n\n  /**\n   * Should be set to a constant specifying the SharedObject type identifier on the prototype of\n   * final derived owner classes.  It is not used on counterpart (non-owner) classes.\n   */\n  declare RPC_TYPE_ID: string;\n}\n\nexport function initializeSharedObjectCounterpart(\n  obj: SharedObject,\n  rpc?: RPC,\n  options: any = {},\n) {\n  if (rpc != null) {\n    obj.initializeSharedObject(rpc, options.id);\n  }\n}\n\n/**\n * Base class for defining a SharedObject type that will never be owned.\n */\nexport class SharedObjectCounterpart extends SharedObject {\n  constructor(rpc?: RPC, options: any = {}) {\n    super();\n    initializeSharedObjectCounterpart(this, rpc, options);\n  }\n}\n\nexport interface SharedObjectConstructor {\n  new (rpc: RPC, options: any): SharedObjectCounterpart;\n}\n\nregisterRPC(\"SharedObject.dispose\", function (x) {\n  const obj = <SharedObject>this.get(x.id);\n  if (obj.refCount !== 0) {\n    throw new Error(\n      \"Attempted to dispose object with non-zero reference count.\",\n    );\n  }\n  if (DEBUG) {\n    console.log(`[${IS_WORKER}] #rpc objects: ${this.numObjects}`);\n  }\n  obj.disposed();\n  this.delete(obj.rpcId!);\n  obj.rpcId = null;\n  obj.rpc = null;\n});\n\nregisterRPC(\"SharedObject.refCountReachedZero\", function (x) {\n  const obj = <SharedObject>this.get(x.id);\n  const generation = <number>x.gen;\n  obj.counterpartRefCountReachedZero(generation);\n});\n\nconst sharedObjectConstructors = new Map<string, SharedObjectConstructor>();\n\n/**\n * Register a class as a SharedObject owner type under the specified identifier.\n *\n * This is intended to be used as a decorator.\n */\nexport function registerSharedObjectOwner(identifier: string) {\n  return (constructorFunction: { prototype: { RPC_TYPE_ID: string } }) => {\n    constructorFunction.prototype.RPC_TYPE_ID = identifier;\n  };\n}\n\n/**\n * Register a class as a SharedObject counterpart type under the specified identifier.\n *\n * This is intended to be used as a decorator.\n *\n * Also register the type as a SharedObject owner, which is useful if this type is also used as a\n * SharedObject owner.\n */\nexport function registerSharedObject(identifier?: string) {\n  return (constructorFunction: SharedObjectConstructor) => {\n    if (identifier !== undefined) {\n      constructorFunction.prototype.RPC_TYPE_ID = identifier;\n    } else {\n      identifier = constructorFunction.prototype.RPC_TYPE_ID;\n      if (identifier === undefined) {\n        throw new Error(\"RPC_TYPE_ID should have already been defined\");\n      }\n    }\n    sharedObjectConstructors.set(identifier, constructorFunction);\n  };\n}\n\nregisterRPC(\"SharedObject.new\", function (x) {\n  const rpc = <RPC>this;\n  const typeName = <string>x.type;\n  const constructorFunction = sharedObjectConstructors.get(typeName)!;\n  const obj = new constructorFunction(rpc, x);\n  // Counterpart objects start with a reference count of zero.\n  --obj.refCount;\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Facility for sharing arbitrary values that support structural cloning between threads.\n */\n\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst CHANGED_RPC_METHOD_ID = \"SharedWatchableValue.changed\";\n\n@registerSharedObject(\"SharedWatchableValue\")\nexport class SharedWatchableValue<T>\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<T>\n{\n  base: WatchableValueInterface<T>;\n\n  /**\n   * The value is being updated to reflect a remote change.\n   * @internal\n   */\n  updatingValue_ = false;\n\n  constructor(rpc?: RPC, options: any = {}) {\n    super(rpc, options);\n    if (rpc !== undefined) {\n      this.base = new WatchableValue<T>(options.value);\n      this.setupChangedHandler();\n    }\n  }\n\n  initializeCounterpart(rpc: RPC, options: any = {}) {\n    options.value = this.value;\n    super.initializeCounterpart(rpc, options);\n  }\n\n  private setupChangedHandler() {\n    this.registerDisposer(\n      this.base.changed.add(() => {\n        if (this.updatingValue_) {\n          this.updatingValue_ = false;\n        } else {\n          const { rpc } = this;\n          if (rpc !== null) {\n            rpc.invoke(CHANGED_RPC_METHOD_ID, {\n              id: this.rpcId,\n              value: this.value,\n            });\n          }\n        }\n      }),\n    );\n  }\n\n  static makeFromExisting<T>(rpc: RPC, base: WatchableValueInterface<T>) {\n    const obj = new SharedWatchableValue<T>();\n    obj.base = base;\n    obj.setupChangedHandler();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  static make<T>(rpc: RPC, value: T) {\n    return SharedWatchableValue.makeFromExisting(\n      rpc,\n      new WatchableValue<T>(value),\n    );\n  }\n\n  get value() {\n    return this.base.value;\n  }\n\n  set value(value: T) {\n    this.base.value = value;\n  }\n\n  get changed() {\n    return this.base.changed;\n  }\n}\n\nregisterRPC(CHANGED_RPC_METHOD_ID, function (x) {\n  const obj = <SharedWatchableValue<any>>this.get(x.id);\n  obj.updatingValue_ = true;\n  obj.base.value = x.value;\n  obj.updatingValue_ = false;\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ComparisonFunction<T> {\n  (a: T, b: T): boolean;\n}\n\nexport interface PairingHeapOperationsConstructor<T> {\n  new (compare: ComparisonFunction<T>): PairingHeapOperations<T>;\n}\n\nexport interface PairingHeapOperations<T> {\n  meld: (a: T | null, b: T | null) => T | null;\n  compare: ComparisonFunction<T>;\n  removeMin: (root: T) => T | null;\n  remove: (root: T, node: T) => T | null;\n  entries: (root: T | null) => Iterator<T>;\n  removedEntries: (root: T | null) => Iterator<T>;\n}\n\nexport type Node<\n  T,\n  Child extends string | symbol,\n  Next extends string | symbol,\n  Prev extends string | symbol,\n> = Record<Child | Next | Prev, T | null>;\n\n/**\n * Pairing heap.\n *\n * The root node is the minimum element according to comparator.\n *\n * @final\n */\nexport default function makePairingHeapOperations<\n  T extends Node<T, Child, Next, Prev>,\n  Child extends string | symbol,\n  Next extends string | symbol,\n  Prev extends string | symbol,\n>(options: {\n  // Returns true iff a < b.\n  compare: (a: T, b: T) => boolean;\n  child: Child;\n  next: Next;\n  prev: Prev;\n}): PairingHeapOperations<T> {\n  const { child: CHILD, next: NEXT, prev: PREV, compare } = options;\n\n  function combineChildren(node: T) {\n    let cur = node[CHILD] as T | null;\n    if (cur === null) {\n      return null;\n    }\n    // While in this function, we will use the nextProperty to create a\n    // singly-linked list of pairwise-merged nodes that still need to be\n    // merged together.\n    let head: T | null = null;\n    while (true) {\n      const curNext: T | null = cur[NEXT] as T | null;\n      let next: T | null, m: T;\n      if (curNext === null) {\n        next = null;\n        m = cur;\n      } else {\n        next = curNext[NEXT] as T | null;\n        m = meld(cur, curNext)!;\n      }\n      (m[NEXT] as T | null) = head;\n      head = m;\n      if (next === null) {\n        break;\n      }\n      cur = next;\n    }\n\n    let root = head;\n    head = head[NEXT] as T | null;\n    while (true) {\n      if (head === null) {\n        break;\n      }\n      const next: T | null = head[NEXT] as T | null;\n      root = meld(root, head)!;\n      head = next;\n    }\n    (root[PREV] as T | null) = null;\n    (root[NEXT] as T | null) = null;\n    return root;\n  }\n\n  function meld(a: T | null, b: T | null) {\n    if (b === null) {\n      return a;\n    }\n    if (a === null) {\n      return b;\n    }\n    if (compare(b, a)) {\n      const temp = a;\n      a = b;\n      b = temp;\n    }\n    const aChild = a[CHILD] as T | null;\n    (b[NEXT] as T | null) = aChild;\n    (b[PREV] as T | null) = a;\n    if (aChild !== null) {\n      (aChild[PREV] as T | null) = b;\n    }\n    (a[CHILD] as T | null) = b;\n    return a;\n  }\n\n  function removeMin(root: T) {\n    const newRoot = combineChildren(root);\n    (root[NEXT] as T | null) = null;\n    (root[PREV] as T | null) = null;\n    (root[CHILD] as T | null) = null;\n    return newRoot;\n  }\n\n  function remove(root: T, node: T) {\n    if (root === node) {\n      return removeMin(root);\n    }\n    const prev = node[PREV] as T;\n    const next = node[NEXT] as T;\n    if ((prev[CHILD] as T | null) === node) {\n      (prev[CHILD] as T | null) = next;\n    } else {\n      (prev[NEXT] as T | null) = next;\n    }\n    if (next !== null) {\n      (next[PREV] as T | null) = prev;\n    }\n    const newRoot = meld(root, combineChildren(node));\n    (node[NEXT] as T | null) = null;\n    (node[PREV] as T | null) = null;\n    (node[CHILD] as T | null) = null;\n    return newRoot;\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.\n   */\n  function* entries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root[CHILD] as T | null;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child[NEXT] as T | null;\n        yield* entries(child);\n        child = next;\n      }\n    }\n  }\n\n  /**\n   * Returns a new iterator over the entries in the heap.  The entries\n   * will be removed as they are iterated.\n   */\n  function* removedEntries(root: T): IterableIterator<T> {\n    if (root !== null) {\n      let child = root[CHILD] as T | null;\n      (root[CHILD] as T | null) = null;\n      (root[NEXT] as T | null) = null;\n      (root[PREV] as T | null) = null;\n      yield root;\n      while (child !== null) {\n        const next: T | null = child[NEXT] as T | null;\n        (child[CHILD] as T | null) = null;\n        (child[NEXT] as T | null) = null;\n        (child[PREV] as T | null) = null;\n        yield* entries(child);\n        child = next;\n      }\n    }\n  }\n\n  return {\n    compare,\n    meld,\n    removeMin,\n    remove,\n    entries,\n    removedEntries,\n  };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { throttle } from \"lodash-es\";\nimport type {\n  ChunkSourceParametersConstructor,\n  LayerChunkProgressInfo,\n} from \"#src/chunk_manager/base.js\";\nimport {\n  CHUNK_LAYER_STATISTICS_RPC_ID,\n  CHUNK_MANAGER_RPC_ID,\n  CHUNK_QUEUE_MANAGER_RPC_ID,\n  CHUNK_SOURCE_INVALIDATE_RPC_ID,\n  ChunkDownloadStatistics,\n  ChunkMemoryStatistics,\n  ChunkPriorityTier,\n  ChunkState,\n  getChunkDownloadStatisticIndex,\n  getChunkStateStatisticIndex,\n  numChunkMemoryStatistics,\n  numChunkStatistics,\n  REQUEST_CHUNK_STATISTICS_RPC_ID,\n} from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport type { Borrowed, Disposable } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport type { LinkedListOperations } from \"#src/util/linked_list.js\";\nimport makeLinkedListOperations from \"#src/util/linked_list.js\";\nimport { StringMemoize } from \"#src/util/memoize.js\";\nimport type {\n  ComparisonFunction,\n  PairingHeapOperations,\n} from \"#src/util/pairing_heap.js\";\nimport makePairingHeapOperations from \"#src/util/pairing_heap.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  initializeSharedObjectCounterpart,\n  registerPromiseRPC,\n  registerRPC,\n  registerSharedObject,\n  registerSharedObjectOwner,\n  SharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst DEBUG_CHUNK_UPDATES = false;\n\nexport interface ChunkStateListener {\n  (chunk: Chunk, oldState: ChunkState): void;\n}\n\nlet nextMarkGeneration = 0;\nexport function getNextMarkGeneration() {\n  return ++nextMarkGeneration;\n}\n\nexport class Chunk implements Disposable {\n  // Node properties used for eviction/promotion heaps and LRU linked lists.\n  child0: Chunk | null = null;\n  next0: Chunk | null = null;\n  prev0: Chunk | null = null;\n  child1: Chunk | null = null;\n  next1: Chunk | null = null;\n  prev1: Chunk | null = null;\n\n  source: ChunkSource | null = null;\n\n  key: string | null = null;\n\n  private state_ = ChunkState.NEW;\n\n  error: any = null;\n\n  // Used by layers for marking chunks for various purposes.\n  markGeneration = -1;\n\n  /**\n   * Specifies existing priority within priority tier.  Only meaningful if priorityTier in\n   * CHUNK_ORDERED_PRIORITY_TIERS.  Higher numbers mean higher priority.\n   */\n  priority = 0;\n\n  /**\n   * Specifies updated priority within priority tier, not yet reflected in priority queue state.\n   * Only meaningful if newPriorityTier in CHUNK_ORDERED_PRIORITY_TIERS.\n   */\n  newPriority = 0;\n\n  priorityTier = ChunkPriorityTier.RECENT;\n\n  /**\n   * Specifies updated priority tier, not yet reflected in priority queue state.\n   */\n  newPriorityTier = ChunkPriorityTier.RECENT;\n\n  private systemMemoryBytes_ = 0;\n  private gpuMemoryBytes_ = 0;\n  private downloadSlots_ = 1;\n  isComputational = false;\n\n  /**\n   * Specifies lowest numeric state required by any request, if `prioritTier !==\n   * ChunkPriorityTier.RECENT`, then this must be one of `GPU_MEMORY`, `SYSTEM_MEMORY`, or\n   * `SYSTEM_MEMORY_WORKER`.\n   */\n  requestedState = ChunkState.NEW;\n\n  newRequestedState = ChunkState.NEW;\n\n  /**\n   * Abort controller used to cancel the pending download.  Set to undefined except when state !==\n   * DOWNLOADING.  This should not be accessed by code outside this module.\n   */\n  downloadAbortController: AbortController | undefined = undefined;\n\n  initialize(key: string) {\n    this.key = key;\n    this.priority = Number.NEGATIVE_INFINITY;\n    this.priorityTier = ChunkPriorityTier.RECENT;\n    this.newPriority = Number.NEGATIVE_INFINITY;\n    this.newPriorityTier = ChunkPriorityTier.RECENT;\n    this.error = null;\n    this.state = ChunkState.NEW;\n    this.requestedState = ChunkState.NEW;\n    this.newRequestedState = ChunkState.NEW;\n  }\n\n  /**\n   * Sets this.priority{Tier,} to this.newPriority{Tier,}, and resets this.newPriorityTier to\n   * ChunkPriorityTier.RECENT.\n   *\n   * This does not actually update any queues to reflect this change.\n   */\n  updatePriorityProperties() {\n    this.priorityTier = this.newPriorityTier;\n    this.priority = this.newPriority;\n    this.newPriorityTier = ChunkPriorityTier.RECENT;\n    this.newPriority = Number.NEGATIVE_INFINITY;\n    this.requestedState = this.newRequestedState;\n    this.newRequestedState = ChunkState.NEW;\n  }\n\n  dispose() {\n    this.source = null;\n    this.error = null;\n  }\n\n  get chunkManager() {\n    return (<ChunkSource>this.source).chunkManager;\n  }\n\n  get queueManager() {\n    return (<ChunkSource>this.source).chunkManager.queueManager;\n  }\n\n  downloadFailed(error: any) {\n    this.error = error;\n    this.queueManager.updateChunkState(this, ChunkState.FAILED);\n  }\n\n  downloadSucceeded() {\n    if (this.requestedState === ChunkState.SYSTEM_MEMORY) {\n      this.queueManager.moveChunkToFrontend(this);\n      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY);\n    } else {\n      this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);\n    }\n  }\n\n  freeSystemMemory() {}\n\n  serialize(msg: any, _transfers: any[]) {\n    msg.id = this.key;\n    msg.source = (<ChunkSource>this.source).rpcId;\n    msg.new = true;\n  }\n\n  toString() {\n    return this.key;\n  }\n\n  set state(newState: ChunkState) {\n    if (newState === this.state_) {\n      return;\n    }\n    const oldState = this.state_;\n    this.state_ = newState;\n    this.source!.chunkStateChanged(this, oldState);\n  }\n\n  get state() {\n    return this.state_;\n  }\n\n  set systemMemoryBytes(bytes: number) {\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.systemMemoryBytes_ = bytes;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  get systemMemoryBytes() {\n    return this.systemMemoryBytes_;\n  }\n\n  set gpuMemoryBytes(bytes: number) {\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.gpuMemoryBytes_ = bytes;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  get gpuMemoryBytes() {\n    return this.gpuMemoryBytes_;\n  }\n\n  get downloadSlots() {\n    return this.downloadSlots_;\n  }\n\n  set downloadSlots(count: number) {\n    if (count === this.downloadSlots_) return;\n    updateChunkStatistics(this, -1);\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, false);\n    this.downloadSlots_ = count;\n    this.chunkManager.queueManager.adjustCapacitiesForChunk(this, true);\n    updateChunkStatistics(this, 1);\n    this.chunkManager.queueManager.scheduleUpdate();\n  }\n\n  registerListener(listener: ChunkStateListener) {\n    if (!this.source) {\n      return false;\n    }\n    return this.source.registerChunkListener(this.key!, listener);\n  }\n\n  unregisterListener(listener: ChunkStateListener) {\n    if (!this.source) {\n      return false;\n    }\n    return this.source.unregisterChunkListener(this.key!, listener);\n  }\n\n  static priorityLess(a: Chunk, b: Chunk) {\n    return a.priority < b.priority;\n  }\n\n  static priorityGreater(a: Chunk, b: Chunk) {\n    return a.priority > b.priority;\n  }\n}\n\nexport interface ChunkConstructor<T extends Chunk> {\n  new (): T;\n}\n\nconst numSourceQueueLevels = 2;\n\n/**\n * Base class inherited by both ChunkSource, for implementing the backend part of chunk sources that\n * also have a frontend-part, as well as other chunk sources, such as the GenericFileSource, that\n * has only a backend part.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class ChunkSourceBase extends SharedObject {\n  private listeners_ = new Map<string, ChunkStateListener[]>();\n  chunks: Map<string, Chunk> = new Map<string, Chunk>();\n  freeChunks: Chunk[] = new Array<Chunk>();\n  statistics = new Float64Array(numChunkStatistics);\n\n  /**\n   * sourceQueueLevel must be greater than the sourceQueueLevel of any ChunkSource whose download\n   * method depends on chunks from this source.  A normal ChunkSource with no other dependencies\n   * should have a level of 0.\n   */\n  sourceQueueLevel = 0;\n\n  constructor(public chunkManager: Borrowed<ChunkManager>) {\n    super();\n    chunkManager.queueManager.sources.add(this);\n  }\n\n  disposed() {\n    this.chunkManager.queueManager.sources.delete(this);\n    super.disposed();\n  }\n\n  getNewChunk_<T extends Chunk>(chunkType: ChunkConstructor<T>): T {\n    const freeChunks = this.freeChunks;\n    const freeChunksLength = freeChunks.length;\n    if (freeChunksLength > 0) {\n      const chunk = <T>freeChunks[freeChunksLength - 1];\n      freeChunks.length = freeChunksLength - 1;\n      chunk.source = this;\n      return chunk;\n    }\n    const chunk = new chunkType();\n    chunk.source = this;\n    return chunk;\n  }\n\n  /**\n   * Adds the specified chunk to the chunk cache.\n   *\n   * If the chunk cache was previously empty, also call this.addRef() to increment the reference\n   * count.\n   */\n  addChunk(chunk: Chunk) {\n    const { chunks } = this;\n    if (chunks.size === 0) {\n      this.addRef();\n    }\n    chunks.set(chunk.key!, chunk);\n    updateChunkStatistics(chunk, 1);\n  }\n\n  /**\n   * Remove the specified chunk from the chunk cache.\n   *\n   * If the chunk cache becomes empty, also call this.dispose() to decrement the reference count.\n   */\n  removeChunk(chunk: Chunk) {\n    const { chunks, freeChunks } = this;\n    chunks.delete(chunk.key!);\n    chunk.dispose();\n    freeChunks[freeChunks.length] = chunk;\n    if (chunks.size === 0) {\n      this.dispose();\n    }\n  }\n\n  registerChunkListener(key: string, listener: ChunkStateListener) {\n    if (!this.listeners_.has(key)) {\n      this.listeners_.set(key, [listener]);\n    } else {\n      this.listeners_.get(key)!.push(listener);\n    }\n    return true;\n  }\n\n  unregisterChunkListener(key: string, listener: ChunkStateListener) {\n    if (!this.listeners_.has(key)) {\n      return false;\n    }\n    const keyListeners = this.listeners_.get(key)!;\n    const idx = keyListeners.indexOf(listener);\n    if (idx < 0) {\n      return false;\n    }\n    keyListeners.splice(idx, 1);\n    if (keyListeners.length === 0) {\n      this.listeners_.delete(key);\n    }\n    return true;\n  }\n\n  chunkStateChanged(chunk: Chunk, oldState: ChunkState) {\n    const { key } = chunk;\n    if (key === null) return;\n    const listeners = this.listeners_.get(key);\n    if (listeners === undefined) return;\n    for (const listener of listeners.slice()) {\n      listener(chunk, oldState);\n    }\n  }\n}\n\nfunction updateChunkStatistics(chunk: Chunk, sign: number) {\n  const { statistics } = chunk.source!;\n  const { systemMemoryBytes, gpuMemoryBytes } = chunk;\n  const index = getChunkStateStatisticIndex(chunk.state, chunk.priorityTier);\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.numChunks\n  ] += sign;\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.systemMemoryBytes\n  ] += sign * systemMemoryBytes;\n  statistics[\n    index * numChunkMemoryStatistics + ChunkMemoryStatistics.gpuMemoryBytes\n  ] += sign * gpuMemoryBytes;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface ChunkSourceBase {\n  /**\n   * Begin downloading the specified the chunk.  The returned promise should resolve when the\n   * downloaded data has been successfully decoded and stored in the chunk, or rejected if the\n   * download or decoding fails.\n   *\n   * Note: This method must be defined by subclasses.\n   *\n   * @param chunk Chunk to download.\n   * @param signal Used to abort download.\n   *\n   * TODO(jbms): Move this back to the class definition above and declare this abstract once mixins\n   * are compatible with abstract classes.\n   */\n  download(chunk: Chunk, signal: AbortSignal): Promise<void>;\n}\n\nexport class ChunkSource extends ChunkSourceBase {\n  constructor(rpc: RPC, options: any) {\n    // No need to add a reference, since the owner counterpart will hold a reference to the owner\n    // counterpart of chunkManager.\n    const chunkManager = <ChunkManager>rpc.get(options.chunkManager);\n    super(chunkManager);\n    initializeSharedObjectCounterpart(this, rpc, options);\n  }\n}\n\nfunction startChunkDownload(chunk: Chunk) {\n  const downloadAbortController = (chunk.downloadAbortController =\n    new AbortController());\n  const startTime = Date.now();\n  chunk.source!.download(chunk, downloadAbortController.signal).then(\n    () => {\n      if (chunk.downloadAbortController === downloadAbortController) {\n        chunk.downloadAbortController = undefined;\n        const endTime = Date.now();\n        const { statistics } = chunk.source!;\n        statistics[\n          getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalTime)\n        ] += endTime - startTime;\n        ++statistics[\n          getChunkDownloadStatisticIndex(ChunkDownloadStatistics.totalChunks)\n        ];\n        chunk.downloadSucceeded();\n      }\n    },\n    (error: any) => {\n      if (chunk.downloadAbortController === downloadAbortController) {\n        chunk.downloadAbortController = undefined;\n        chunk.downloadFailed(error);\n        console.log(`Error retrieving chunk ${chunk}: ${error}`);\n      }\n    },\n  );\n}\n\nfunction cancelChunkDownload(chunk: Chunk) {\n  const controller = chunk.downloadAbortController!;\n  chunk.downloadAbortController = undefined;\n  controller.abort(new DOMException(\"chunk download cancelled\", \"AbortError\"));\n}\n\nclass ChunkPriorityQueue {\n  /**\n   * Heap roots for VISIBLE and PREFETCH priority tiers.\n   */\n  private heapRoots: (Chunk | null)[] = [null, null];\n\n  /**\n   * Head node for RECENT linked list.\n   */\n  private recentHead = new Chunk();\n  constructor(\n    private heapOperations: PairingHeapOperations<Chunk>,\n    private linkedListOperations: LinkedListOperations<Chunk>,\n  ) {\n    linkedListOperations.initializeHead(this.recentHead);\n  }\n\n  add(chunk: Chunk) {\n    const priorityTier = chunk.priorityTier;\n    if (priorityTier === ChunkPriorityTier.RECENT) {\n      this.linkedListOperations.insertAfter(this.recentHead, chunk);\n    } else {\n      const { heapRoots } = this;\n      heapRoots[priorityTier] = this.heapOperations.meld(\n        heapRoots[priorityTier],\n        chunk,\n      );\n    }\n  }\n\n  *candidates(): Iterator<Chunk> {\n    if (this.heapOperations.compare === Chunk.priorityLess) {\n      // Start with least-recently used RECENT chunk.\n      const { linkedListOperations, recentHead } = this;\n      while (true) {\n        const chunk = linkedListOperations.back(recentHead);\n        if (chunk == null) {\n          break;\n        }\n        yield chunk;\n      }\n      const { heapRoots } = this;\n      for (\n        let tier = ChunkPriorityTier.LAST_ORDERED_TIER;\n        tier >= ChunkPriorityTier.FIRST_ORDERED_TIER;\n        --tier\n      ) {\n        while (true) {\n          const root = heapRoots[tier];\n          if (root == null) {\n            break;\n          }\n          yield root;\n        }\n      }\n    } else {\n      const heapRoots = this.heapRoots;\n      for (\n        let tier = ChunkPriorityTier.FIRST_ORDERED_TIER;\n        tier <= ChunkPriorityTier.LAST_ORDERED_TIER;\n        ++tier\n      ) {\n        while (true) {\n          const root = heapRoots[tier];\n          if (root == null) {\n            break;\n          }\n          yield root;\n        }\n      }\n      const { linkedListOperations, recentHead } = this;\n      while (true) {\n        const chunk = linkedListOperations.front(recentHead);\n        if (chunk == null) {\n          break;\n        }\n        yield chunk;\n      }\n    }\n  }\n\n  /**\n   * Deletes a chunk from this priority queue.\n   * @param chunk The chunk to delete from the priority queue.\n   */\n  delete(chunk: Chunk) {\n    const priorityTier = chunk.priorityTier;\n    if (priorityTier === ChunkPriorityTier.RECENT) {\n      this.linkedListOperations.pop(chunk);\n    } else {\n      const heapRoots = this.heapRoots;\n      heapRoots[priorityTier] = this.heapOperations.remove(\n        <Chunk>heapRoots[priorityTier],\n        chunk,\n      );\n    }\n  }\n}\n\nconst linkedList0 = makeLinkedListOperations({ next: \"next0\", prev: \"prev0\" });\nconst linkedList1 = makeLinkedListOperations({ next: \"next1\", prev: \"prev1\" });\n\nfunction makeChunkPriorityQueue0(compare: ComparisonFunction<Chunk>) {\n  return new ChunkPriorityQueue(\n    makePairingHeapOperations({\n      compare,\n      child: \"child0\",\n      next: \"next0\",\n      prev: \"prev0\",\n    }),\n    linkedList0,\n  );\n}\n\nfunction makeChunkPriorityQueue1(compare: ComparisonFunction<Chunk>) {\n  return new ChunkPriorityQueue(\n    makePairingHeapOperations({\n      compare,\n      child: \"child1\",\n      next: \"next1\",\n      prev: \"prev1\",\n    }),\n    linkedList1,\n  );\n}\n\nfunction tryToFreeCapacity(\n  size: number,\n  capacity: AvailableCapacity,\n  priorityTier: ChunkPriorityTier,\n  priority: number,\n  evictionCandidates: Iterator<Chunk>,\n  evict: (chunk: Chunk) => void,\n) {\n  while (capacity.availableItems < 1 || capacity.availableSize < size) {\n    const evictionCandidate = evictionCandidates.next().value;\n    if (evictionCandidate === undefined) {\n      // No eviction candidates available, promotions are done.\n      return false;\n    }\n    const evictionTier = evictionCandidate.priorityTier;\n    if (\n      evictionTier < priorityTier ||\n      (evictionTier === priorityTier && evictionCandidate.priority >= priority)\n    ) {\n      // Lowest priority eviction candidate has priority >= highest\n      // priority promotion candidate.  No more promotions are\n      // possible.\n      return false;\n    }\n    evict(evictionCandidate);\n  }\n  return true;\n}\n\nclass AvailableCapacity extends RefCounted {\n  currentSize = 0;\n  currentItems = 0;\n\n  capacityChanged = new NullarySignal();\n\n  constructor(\n    public itemLimit: Borrowed<SharedWatchableValue<number>>,\n    public sizeLimit: Borrowed<SharedWatchableValue<number>>,\n  ) {\n    super();\n    this.registerDisposer(itemLimit.changed.add(this.capacityChanged.dispatch));\n    this.registerDisposer(sizeLimit.changed.add(this.capacityChanged.dispatch));\n  }\n\n  /**\n   * Adjust available capacity by the specified amounts.\n   */\n  adjust(items: number, size: number) {\n    this.currentItems -= items;\n    this.currentSize -= size;\n  }\n\n  get availableSize() {\n    return this.sizeLimit.value - this.currentSize;\n  }\n  get availableItems() {\n    return this.itemLimit.value - this.currentItems;\n  }\n\n  toString() {\n    return (\n      `bytes=${this.currentSize}/${this.sizeLimit.value},` +\n      `items=${this.currentItems}/${this.itemLimit.value}`\n    );\n  }\n}\n\n@registerSharedObject(CHUNK_QUEUE_MANAGER_RPC_ID)\nexport class ChunkQueueManager extends SharedObjectCounterpart {\n  gpuMemoryCapacity: AvailableCapacity;\n  systemMemoryCapacity: AvailableCapacity;\n\n  /**\n   * Download capacity for each sourceQueueLevel.\n   */\n  downloadCapacity: AvailableCapacity[];\n  computeCapacity: AvailableCapacity;\n\n  enablePrefetch: SharedWatchableValue<boolean>;\n\n  /**\n   * Set of chunk sources associated with this queue manager.\n   */\n  sources = new Set<Borrowed<ChunkSource>>();\n\n  /**\n   * Contains all chunks in QUEUED state pending download, for each sourceQueueLevel.\n   */\n  private queuedDownloadPromotionQueue = [\n    makeChunkPriorityQueue1(Chunk.priorityGreater),\n    makeChunkPriorityQueue1(Chunk.priorityGreater),\n  ];\n\n  /**\n   * Contains all chunks in QUEUED state pending compute.\n   */\n  private queuedComputePromotionQueue = makeChunkPriorityQueue1(\n    Chunk.priorityGreater,\n  );\n\n  /**\n   * Contains all chunks in DOWNLOADING state, for each sourceQueueLevel.\n   */\n  private downloadEvictionQueue = [\n    makeChunkPriorityQueue1(Chunk.priorityLess),\n    makeChunkPriorityQueue1(Chunk.priorityLess),\n  ];\n\n  /**\n   * Contains all chunks in COMPUTING state.\n   */\n  private computeEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);\n\n  /**\n   * Contains all chunks that take up memory (DOWNLOADING, SYSTEM_MEMORY,\n   * GPU_MEMORY).\n   */\n  private systemMemoryEvictionQueue = makeChunkPriorityQueue0(\n    Chunk.priorityLess,\n  );\n\n  /**\n   * Contains all chunks in SYSTEM_MEMORY state not in RECENT priority tier.\n   */\n  private gpuMemoryPromotionQueue = makeChunkPriorityQueue1(\n    Chunk.priorityGreater,\n  );\n\n  /**\n   * Contains all chunks in GPU_MEMORY state.\n   */\n  private gpuMemoryEvictionQueue = makeChunkPriorityQueue1(Chunk.priorityLess);\n\n  // Should be `number|null`, but marked `any` to work around @types/node being pulled in.\n  private updatePending: any = null;\n\n  gpuMemoryChanged = new NullarySignal();\n\n  private numQueued = 0;\n  private numFailed = 0;\n  private gpuMemoryGeneration = 0;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const getCapacity = (capacity: any) => {\n      const result = this.registerDisposer(\n        new AvailableCapacity(\n          rpc.get(capacity.itemLimit),\n          rpc.get(capacity.sizeLimit),\n        ),\n      );\n      result.capacityChanged.add(() => this.scheduleUpdate());\n      return result;\n    };\n    this.gpuMemoryCapacity = getCapacity(options.gpuMemoryCapacity);\n    this.systemMemoryCapacity = getCapacity(options.systemMemoryCapacity);\n    this.enablePrefetch = rpc.get(options.enablePrefetch);\n    this.downloadCapacity = [\n      getCapacity(options.downloadCapacity),\n      getCapacity(options.downloadCapacity),\n    ];\n    this.computeCapacity = getCapacity(options.computeCapacity);\n  }\n\n  scheduleUpdate() {\n    if (this.updatePending === null) {\n      this.updatePending = setTimeout(this.process.bind(this), 0);\n    }\n  }\n\n  *chunkQueuesForChunk(chunk: Chunk) {\n    switch (chunk.state) {\n      case ChunkState.QUEUED:\n        if (chunk.isComputational) {\n          yield this.queuedComputePromotionQueue;\n        } else {\n          yield this.queuedDownloadPromotionQueue[\n            chunk.source!.sourceQueueLevel\n          ];\n        }\n        break;\n\n      case ChunkState.DOWNLOADING:\n        if (chunk.isComputational) {\n          yield this.computeEvictionQueue;\n        } else {\n          yield this.downloadEvictionQueue[chunk.source!.sourceQueueLevel];\n          yield this.systemMemoryEvictionQueue;\n        }\n        break;\n\n      case ChunkState.SYSTEM_MEMORY_WORKER:\n      case ChunkState.SYSTEM_MEMORY:\n        yield this.systemMemoryEvictionQueue;\n        if (chunk.requestedState === ChunkState.GPU_MEMORY) {\n          yield this.gpuMemoryPromotionQueue;\n        }\n        break;\n\n      case ChunkState.GPU_MEMORY:\n        yield this.systemMemoryEvictionQueue;\n        yield this.gpuMemoryEvictionQueue;\n        break;\n    }\n  }\n\n  adjustCapacitiesForChunk(chunk: Chunk, add: boolean) {\n    const factor = add ? -1 : 1;\n    switch (chunk.state) {\n      case ChunkState.FAILED:\n        this.numFailed -= factor;\n        break;\n\n      case ChunkState.QUEUED:\n        this.numQueued -= factor;\n        break;\n\n      case ChunkState.DOWNLOADING:\n        (chunk.isComputational\n          ? this.computeCapacity\n          : this.downloadCapacity[chunk.source!.sourceQueueLevel]\n        ).adjust(\n          factor * chunk.downloadSlots,\n          factor * chunk.systemMemoryBytes,\n        );\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        break;\n\n      case ChunkState.SYSTEM_MEMORY:\n      case ChunkState.SYSTEM_MEMORY_WORKER:\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        break;\n\n      case ChunkState.GPU_MEMORY:\n        this.systemMemoryCapacity.adjust(\n          factor,\n          factor * chunk.systemMemoryBytes,\n        );\n        this.gpuMemoryCapacity.adjust(factor, factor * chunk.gpuMemoryBytes);\n        break;\n    }\n  }\n\n  private removeChunkFromQueues_(chunk: Chunk) {\n    updateChunkStatistics(chunk, -1);\n    for (const queue of this.chunkQueuesForChunk(chunk)) {\n      queue.delete(chunk);\n    }\n  }\n\n  // var freedChunks = 0;\n  private addChunkToQueues_(chunk: Chunk) {\n    if (\n      chunk.state === ChunkState.QUEUED &&\n      chunk.priorityTier === ChunkPriorityTier.RECENT\n    ) {\n      // Delete this chunk.\n      const { source } = chunk;\n      source!.removeChunk(chunk);\n      this.adjustCapacitiesForChunk(chunk, false);\n      return false;\n    }\n    updateChunkStatistics(chunk, 1);\n    for (const queue of this.chunkQueuesForChunk(chunk)) {\n      queue.add(chunk);\n    }\n    return true;\n  }\n\n  performChunkPriorityUpdate(chunk: Chunk) {\n    if (\n      chunk.priorityTier === chunk.newPriorityTier &&\n      chunk.priority === chunk.newPriority\n    ) {\n      chunk.newPriorityTier = ChunkPriorityTier.RECENT;\n      chunk.newPriority = Number.NEGATIVE_INFINITY;\n      return;\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `${chunk}: changed priority ${chunk.priorityTier}:` +\n          `${chunk.priority} -> ${chunk.newPriorityTier}:${chunk.newPriority}`,\n      );\n    }\n    this.removeChunkFromQueues_(chunk);\n    chunk.updatePriorityProperties();\n    if (chunk.state === ChunkState.NEW) {\n      chunk.state = ChunkState.QUEUED;\n      this.adjustCapacitiesForChunk(chunk, true);\n    }\n    this.addChunkToQueues_(chunk);\n  }\n\n  updateChunkState(chunk: Chunk, newState: ChunkState) {\n    if (newState === chunk.state) {\n      return;\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `${chunk}: changed state ${ChunkState[chunk.state]} -> ${\n          ChunkState[newState]\n        }`,\n      );\n    }\n    this.adjustCapacitiesForChunk(chunk, false);\n    this.removeChunkFromQueues_(chunk);\n    chunk.state = newState;\n    this.adjustCapacitiesForChunk(chunk, true);\n    this.addChunkToQueues_(chunk);\n    this.scheduleUpdate();\n  }\n\n  markRecentlyUsed(chunk: Chunk) {\n    this.removeChunkFromQueues_(chunk);\n    this.addChunkToQueues_(chunk);\n  }\n\n  private processGPUPromotions_() {\n    const queueManager = this;\n    function evictFromGPUMemory(chunk: Chunk) {\n      queueManager.freeChunkGPUMemory(chunk);\n      chunk.source!.chunkManager.queueManager.updateChunkState(\n        chunk,\n        ChunkState.SYSTEM_MEMORY,\n      );\n    }\n    const promotionCandidates = this.gpuMemoryPromotionQueue.candidates();\n    const evictionCandidates = this.gpuMemoryEvictionQueue.candidates();\n    const capacity = this.gpuMemoryCapacity;\n    while (true) {\n      const promotionCandidate = promotionCandidates.next().value;\n      if (promotionCandidate === undefined) {\n        break;\n      }\n      const priorityTier = promotionCandidate.priorityTier;\n      const priority = promotionCandidate.priority;\n      if (\n        !tryToFreeCapacity(\n          promotionCandidate.gpuMemoryBytes,\n          capacity,\n          priorityTier,\n          priority,\n          evictionCandidates,\n          evictFromGPUMemory,\n        )\n      ) {\n        break;\n      }\n      this.copyChunkToGPU(promotionCandidate);\n      this.updateChunkState(promotionCandidate, ChunkState.GPU_MEMORY);\n    }\n  }\n\n  freeChunkGPUMemory(chunk: Chunk) {\n    ++this.gpuMemoryGeneration;\n    this.rpc!.invoke(\"Chunk.update\", {\n      id: chunk.key,\n      state: ChunkState.SYSTEM_MEMORY,\n      source: chunk.source!.rpcId,\n    });\n  }\n\n  freeChunkSystemMemory(chunk: Chunk) {\n    if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER) {\n      chunk.freeSystemMemory();\n    } else {\n      this.rpc!.invoke(\"Chunk.update\", {\n        id: chunk.key,\n        state: ChunkState.EXPIRED,\n        source: chunk.source!.rpcId,\n      });\n    }\n  }\n\n  retrieveChunkData(chunk: Chunk) {\n    return this.rpc!.promiseInvoke<TypedNumberArray>(\"Chunk.retrieve\", {\n      key: chunk.key!,\n      source: chunk.source!.rpcId,\n    });\n  }\n\n  copyChunkToGPU(chunk: Chunk) {\n    ++this.gpuMemoryGeneration;\n    const rpc = this.rpc!;\n    if (chunk.state === ChunkState.SYSTEM_MEMORY) {\n      rpc.invoke(\"Chunk.update\", {\n        id: chunk.key,\n        source: chunk.source!.rpcId,\n        state: ChunkState.GPU_MEMORY,\n      });\n    } else {\n      const msg: any = {};\n      const transfers: any[] = [];\n      chunk.serialize(msg, transfers);\n      msg.state = ChunkState.GPU_MEMORY;\n      rpc.invoke(\"Chunk.update\", msg, transfers);\n    }\n  }\n\n  moveChunkToFrontend(chunk: Chunk) {\n    const rpc = this.rpc!;\n    const msg: any = {};\n    const transfers: any[] = [];\n    chunk.serialize(msg, transfers);\n    msg.state = ChunkState.SYSTEM_MEMORY;\n    rpc.invoke(\"Chunk.update\", msg, transfers);\n  }\n\n  private processQueuePromotions_() {\n    const evict = (chunk: Chunk) => {\n      switch (chunk.state) {\n        case ChunkState.DOWNLOADING:\n          cancelChunkDownload(chunk);\n          break;\n        case ChunkState.GPU_MEMORY:\n          this.freeChunkGPUMemory(chunk);\n        // fallthrough\n        case ChunkState.SYSTEM_MEMORY_WORKER:\n        case ChunkState.SYSTEM_MEMORY:\n          this.freeChunkSystemMemory(chunk);\n          break;\n      }\n      // Note: After calling this, chunk may no longer be valid.\n      this.updateChunkState(chunk, ChunkState.QUEUED);\n    };\n\n    const promotionLambda = (\n      promotionCandidates: Iterator<Chunk>,\n      evictionCandidates: Iterator<Chunk>,\n      capacity: AvailableCapacity,\n    ) => {\n      const systemMemoryEvictionCandidates =\n        this.systemMemoryEvictionQueue.candidates();\n      const systemMemoryCapacity = this.systemMemoryCapacity;\n      while (true) {\n        const promotionCandidateResult = promotionCandidates.next();\n        if (promotionCandidateResult.done) {\n          return;\n        }\n        const promotionCandidate = promotionCandidateResult.value;\n        const size = 0; /* unknown size, since it hasn't been downloaded yet. */\n        const priorityTier = promotionCandidate.priorityTier;\n        const priority = promotionCandidate.priority;\n        // console.log(\"Download capacity: \" + downloadCapacity);\n        if (\n          !tryToFreeCapacity(\n            size,\n            capacity,\n            priorityTier,\n            priority,\n            evictionCandidates,\n            evict,\n          )\n        ) {\n          return;\n        }\n        if (\n          !tryToFreeCapacity(\n            size,\n            systemMemoryCapacity,\n            priorityTier,\n            priority,\n            systemMemoryEvictionCandidates,\n            evict,\n          )\n        ) {\n          return;\n        }\n        this.updateChunkState(promotionCandidate, ChunkState.DOWNLOADING);\n        startChunkDownload(promotionCandidate);\n      }\n    };\n\n    for (\n      let sourceQueueLevel = 0;\n      sourceQueueLevel < numSourceQueueLevels;\n      ++sourceQueueLevel\n    ) {\n      promotionLambda(\n        this.queuedDownloadPromotionQueue[sourceQueueLevel].candidates(),\n        this.downloadEvictionQueue[sourceQueueLevel].candidates(),\n        this.downloadCapacity[sourceQueueLevel],\n      );\n    }\n    promotionLambda(\n      this.queuedComputePromotionQueue.candidates(),\n      this.computeEvictionQueue.candidates(),\n      this.computeCapacity,\n    );\n  }\n\n  process() {\n    if (!this.updatePending) {\n      return;\n    }\n    this.updatePending = null;\n    const gpuMemoryGeneration = this.gpuMemoryGeneration;\n    this.processGPUPromotions_();\n    this.processQueuePromotions_();\n    this.logStatistics();\n    if (this.gpuMemoryGeneration !== gpuMemoryGeneration) {\n      this.gpuMemoryChanged.dispatch();\n    }\n  }\n\n  logStatistics() {\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `[Chunk status] QUEUED: ${this.numQueued}, FAILED: ` +\n          `${this.numFailed}, DOWNLOAD: ${this.downloadCapacity}, ` +\n          `MEM: ${this.systemMemoryCapacity}, GPU: ${this.gpuMemoryCapacity}`,\n      );\n    }\n  }\n\n  invalidateSourceCache(source: ChunkSource) {\n    for (const chunk of source.chunks.values()) {\n      switch (chunk.state) {\n        case ChunkState.DOWNLOADING:\n          cancelChunkDownload(chunk);\n          break;\n        case ChunkState.SYSTEM_MEMORY_WORKER:\n          chunk.freeSystemMemory();\n          break;\n      }\n      // Note: After calling this, chunk may no longer be valid.\n      this.updateChunkState(chunk, ChunkState.QUEUED);\n    }\n    this.rpc!.invoke(\"Chunk.update\", { source: source.rpcId });\n    this.scheduleUpdate();\n  }\n}\n\nexport class ChunkRenderLayerBackend\n  extends SharedObjectCounterpart\n  implements LayerChunkProgressInfo\n{\n  chunkManagerGeneration = -1;\n\n  numVisibleChunksNeeded = 0;\n  numVisibleChunksAvailable = 0;\n  numPrefetchChunksNeeded = 0;\n  numPrefetchChunksAvailable = 0;\n}\n\nconst LAYER_CHUNK_STATISTICS_INTERVAL = 200;\n\n@registerSharedObject(CHUNK_MANAGER_RPC_ID)\nexport class ChunkManager extends SharedObjectCounterpart {\n  queueManager: ChunkQueueManager;\n\n  /**\n   * Array of chunks within each existing priority tier.\n   */\n  private existingTierChunks: Chunk[][] = [];\n\n  /**\n   * Array of chunks whose new priorities have not yet been reflected in the\n   * queue states.\n   */\n  private newTierChunks: Chunk[] = [];\n\n  // Should be `number|null`, but marked `any` to workaround `@types/node` being pulled in.\n  private updatePending: any = null;\n\n  recomputeChunkPriorities = new NullarySignal();\n\n  /**\n   * Dispatched immediately after recomputeChunkPriorities is dispatched.\n   * This signal should be used for handlers that depend on the result of another handler.\n   */\n  recomputeChunkPrioritiesLate = new NullarySignal();\n\n  memoize = new StringMemoize();\n\n  layers: ChunkRenderLayerBackend[] = [];\n\n  private sendLayerChunkStatistics = this.registerCancellable(\n    throttle(() => {\n      this.rpc!.invoke(CHUNK_LAYER_STATISTICS_RPC_ID, {\n        id: this.rpcId,\n        layers: this.layers.map((layer) => ({\n          id: layer.rpcId,\n          numVisibleChunksAvailable: layer.numVisibleChunksAvailable,\n          numVisibleChunksNeeded: layer.numVisibleChunksNeeded,\n          numPrefetchChunksAvailable: layer.numPrefetchChunksAvailable,\n          numPrefetchChunksNeeded: layer.numPrefetchChunksNeeded,\n        })),\n      });\n    }, LAYER_CHUNK_STATISTICS_INTERVAL),\n  );\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.queueManager = (<ChunkQueueManager>(\n      rpc.get(options.chunkQueueManager)\n    )).addRef();\n\n    // Update chunk priorities periodically after GPU memory changes to ensure layer chunk\n    // statistics are updated.\n    this.registerDisposer(\n      this.queueManager.gpuMemoryChanged.add(\n        this.registerCancellable(\n          throttle(\n            () => this.scheduleUpdateChunkPriorities(),\n            LAYER_CHUNK_STATISTICS_INTERVAL,\n            { leading: false, trailing: true },\n          ),\n        ),\n      ),\n    );\n\n    for (\n      let tier = ChunkPriorityTier.FIRST_TIER;\n      tier <= ChunkPriorityTier.LAST_TIER;\n      ++tier\n    ) {\n      if (tier === ChunkPriorityTier.RECENT) {\n        continue;\n      }\n      this.existingTierChunks[tier] = [];\n    }\n  }\n\n  scheduleUpdateChunkPriorities() {\n    if (this.updatePending === null) {\n      this.updatePending = setTimeout(\n        this.recomputeChunkPriorities_.bind(this),\n        0,\n      );\n    }\n  }\n\n  registerLayer(layer: ChunkRenderLayerBackend) {\n    const generation = this.recomputeChunkPriorities.count;\n    if (layer.chunkManagerGeneration !== generation) {\n      layer.chunkManagerGeneration = generation;\n      this.layers.push(layer);\n      layer.numVisibleChunksAvailable = 0;\n      layer.numVisibleChunksNeeded = 0;\n      layer.numPrefetchChunksAvailable = 0;\n      layer.numPrefetchChunksNeeded = 0;\n    }\n  }\n\n  private recomputeChunkPriorities_() {\n    this.updatePending = null;\n    this.layers.length = 0;\n    this.recomputeChunkPriorities.dispatch();\n    this.recomputeChunkPrioritiesLate.dispatch();\n    this.updateQueueState([\n      ChunkPriorityTier.VISIBLE,\n      ChunkPriorityTier.PREFETCH,\n    ]);\n    this.sendLayerChunkStatistics();\n  }\n\n  /**\n   * @param chunk\n   * @param tier New priority tier.  Must not equal ChunkPriorityTier.RECENT.\n   * @param priority Priority within tier.\n   * @param requestedState Indicates requested chunk state.\n   */\n  requestChunk(\n    chunk: Chunk,\n    tier: ChunkPriorityTier,\n    priority: number,\n    requestedState: ChunkState = ChunkState.GPU_MEMORY,\n  ) {\n    if (Number.isNaN(priority)) {\n      return;\n    }\n    if (tier === ChunkPriorityTier.RECENT) {\n      throw new Error(\"Not going to request a chunk with the RECENT tier\");\n    }\n    chunk.newRequestedState = Math.min(chunk.newRequestedState, requestedState);\n    if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {\n      this.newTierChunks.push(chunk);\n    }\n    const newPriorityTier = chunk.newPriorityTier;\n    if (\n      tier < newPriorityTier ||\n      (tier === newPriorityTier && priority > chunk.newPriority)\n    ) {\n      chunk.newPriorityTier = tier;\n      chunk.newPriority = priority;\n    }\n  }\n\n  /**\n   * Update queue state to reflect updated contents of the specified priority tiers.  Existing\n   * chunks within those tiers not present in this.newTierChunks will be moved to the RECENT tier\n   * (and removed if in the QUEUED state).\n   */\n  updateQueueState(tiers: ChunkPriorityTier[]) {\n    const existingTierChunks = this.existingTierChunks;\n    const queueManager = this.queueManager;\n    for (const tier of tiers) {\n      const chunks = existingTierChunks[tier];\n      if (DEBUG_CHUNK_UPDATES) {\n        console.log(\n          `existingTierChunks[${ChunkPriorityTier[tier]}].length=${chunks.length}`,\n        );\n      }\n      for (const chunk of chunks) {\n        if (chunk.newPriorityTier === ChunkPriorityTier.RECENT) {\n          // Downgrade the priority of this chunk.\n          queueManager.performChunkPriorityUpdate(chunk);\n        }\n      }\n      chunks.length = 0;\n    }\n    const newTierChunks = this.newTierChunks;\n    for (const chunk of newTierChunks) {\n      queueManager.performChunkPriorityUpdate(chunk);\n      existingTierChunks[chunk.priorityTier].push(chunk);\n    }\n    if (DEBUG_CHUNK_UPDATES) {\n      console.log(\n        `updateQueueState: newTierChunks.length = ${newTierChunks.length}`,\n      );\n    }\n    newTierChunks.length = 0;\n    this.queueManager.scheduleUpdate();\n  }\n}\n\n/**\n * Mixin for adding a `parameters` member to a ChunkSource, and for registering the shared object\n * type based on the `RPC_ID` member of the Parameters class.\n */\nexport function WithParameters<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  @registerSharedObjectOwner(parametersConstructor.RPC_ID)\n  class C extends Base {\n    parameters: Parameters;\n    constructor(...args: any[]) {\n      super(...args);\n      const options = args[1];\n      this.parameters = options.parameters;\n    }\n  }\n  return C;\n}\n\n/**\n * Interface that represents shared objects that request chunks from a ChunkManager.\n */\nexport interface ChunkRequester extends SharedObject {\n  chunkManager: ChunkManager;\n}\n\n/**\n * Mixin that adds a chunkManager property initialized from the RPC-supplied options.\n *\n * The resultant class implements `ChunkRequester`.\n */\nexport function withChunkManager<\n  T extends { new (...args: any[]): SharedObject },\n>(Base: T) {\n  return class extends Base implements ChunkRequester {\n    chunkManager: ChunkManager;\n    constructor(...args: any[]) {\n      super(...args);\n      const rpc: RPC = args[0];\n      const options = args[1];\n      // We don't increment the reference count, because our owner owns a reference to the\n      // ChunkManager.\n      this.chunkManager = <ChunkManager>rpc.get(options.chunkManager);\n    }\n  };\n}\n\nregisterRPC(CHUNK_SOURCE_INVALIDATE_RPC_ID, function (x) {\n  const source = <ChunkSource>this.get(x.id);\n  source.chunkManager.queueManager.invalidateSourceCache(source);\n});\n\nregisterPromiseRPC(\n  REQUEST_CHUNK_STATISTICS_RPC_ID,\n  function (x: { queue: number }) {\n    const queue = this.get(x.queue) as ChunkQueueManager;\n    const results = new Map<number, Float64Array>();\n    for (const source of queue.sources) {\n      results.set(source.rpcId!, source.statistics);\n    }\n    return Promise.resolve({ value: results });\n  },\n);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Generic facility for providing authentication/authorization credentials.\n */\n\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport type { AsyncMemoizeWithProgress } from \"#src/util/memoize.js\";\nimport { asyncMemoizeWithProgress, StringMemoize } from \"#src/util/memoize.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\n/**\n * Wraps an arbitrary JSON credentials object with a generation number.\n *\n * The generation number is used for tracking whether the credentials have been updated/renewed.\n */\nexport interface CredentialsWithGeneration<T> {\n  generation: number;\n  credentials: T;\n}\n\nexport abstract class CredentialsProvider<Credentials> extends RefCounted {\n  /**\n   * Request valid credentials.  If `invalidCredentials` is specified, it indicates that the\n   * specified credentials are invalid.\n   *\n   * This method can be conveniently defined using the `makeCredentialsGetter` function.\n   */\n  abstract get: (\n    invalidCredentials?: CredentialsWithGeneration<Credentials>,\n    options?: Partial<ProgressOptions>,\n  ) => Promise<CredentialsWithGeneration<Credentials>>;\n}\n\nexport function makeCachedCredentialsGetter<Credentials>(\n  getUncached: (\n    invalidCredentials: CredentialsWithGeneration<Credentials> | undefined,\n    options: ProgressOptions,\n  ) => Promise<CredentialsWithGeneration<Credentials>>,\n) {\n  let cachedCredentials: CredentialsWithGeneration<Credentials> | undefined;\n  let pendingCredentials:\n    | AsyncMemoizeWithProgress<CredentialsWithGeneration<Credentials>>\n    | undefined;\n  return async (\n    invalidCredentials?: CredentialsWithGeneration<Credentials>,\n    options?: Partial<ProgressOptions>,\n  ) => {\n    // Check if a new credential request needs to be made.\n    if (\n      pendingCredentials === undefined ||\n      (invalidCredentials !== undefined &&\n        cachedCredentials?.generation === invalidCredentials.generation)\n    ) {\n      cachedCredentials = undefined;\n      pendingCredentials = asyncMemoizeWithProgress(async (progressOptions) => {\n        cachedCredentials = await getUncached(\n          invalidCredentials,\n          progressOptions,\n        );\n        return cachedCredentials;\n      });\n    }\n    return pendingCredentials(options ?? {});\n  };\n}\n\nexport function makeCredentialsGetter<Credentials>(\n  getWithoutGeneration: (options: ProgressOptions) => Promise<Credentials>,\n) {\n  let generation = 0;\n  return makeCachedCredentialsGetter<Credentials>(\n    (_invalidCredentials, options) =>\n      getWithoutGeneration(options).then((credentials) => ({\n        generation: ++generation,\n        credentials,\n      })),\n  );\n}\n\n/**\n * Interface for obtaining a CredentialsProvider based on a string key.\n */\nexport interface CredentialsManager {\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>>;\n}\n\nexport type ProviderGetter<Credentials> = (\n  parameters: any,\n  credentialsManager: CredentialsManager,\n) => Owned<CredentialsProvider<Credentials>>;\n\n/**\n * CredentialsManager that supports registration.\n */\nexport class MapBasedCredentialsManager implements CredentialsManager {\n  providers = new Map<string, ProviderGetter<any>>();\n  topLevelManager: CredentialsManager = this;\n  register<Credentials>(\n    key: string,\n    providerGetter: ProviderGetter<Credentials>,\n  ) {\n    this.providers.set(key, providerGetter);\n  }\n\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>> {\n    const getter = this.providers.get(key);\n    if (getter === undefined) {\n      throw new Error(\n        `No registered credentials provider: ${JSON.stringify(key)}`,\n      );\n    }\n    return getter(parameters, this.topLevelManager);\n  }\n}\n\n/**\n * CredentialsManager that wraps another and caches the CredentialsProvider objects.\n */\nexport class CachingCredentialsManager<Base extends CredentialsManager>\n  extends RefCounted\n  implements CredentialsManager\n{\n  memoize = new StringMemoize();\n\n  constructor(public base: Base) {\n    super();\n  }\n\n  getCredentialsProvider<Credentials>(\n    key: string,\n    parameters?: any,\n  ): Owned<CredentialsProvider<Credentials>> {\n    return this.memoize.get({ key, parameters }, () =>\n      this.registerDisposer(\n        this.base.getCredentialsProvider<Credentials>(key, parameters).addRef(),\n      ),\n    );\n  }\n}\n\nexport class CachingMapBasedCredentialsManager extends CachingCredentialsManager<MapBasedCredentialsManager> {\n  constructor() {\n    super(new MapBasedCredentialsManager());\n    this.base.topLevelManager = this;\n  }\n\n  register<Credentials>(\n    key: string,\n    providerGetter: ProviderGetter<Credentials>,\n  ) {\n    this.base.register(key, providerGetter);\n  }\n}\n\nexport type MaybeOptionalCredentialsProvider<T> = T extends undefined\n  ? undefined\n  : CredentialsProvider<Exclude<T, undefined>>;\n\nexport class AnonymousFirstCredentialsProvider<\n  T,\n> extends CredentialsProvider<T> {\n  private anonymous = true;\n  constructor(\n    private baseProvider: CredentialsProvider<T>,\n    private anonymousCredentials: T,\n  ) {\n    super();\n  }\n\n  get = makeCachedCredentialsGetter(\n    (\n      invalidCredentials: CredentialsWithGeneration<T> | undefined,\n      options: ProgressOptions,\n    ) => {\n      if (this.anonymous && invalidCredentials === undefined) {\n        return Promise.resolve({\n          generation: -10,\n          credentials: this.anonymousCredentials,\n        });\n      }\n      this.anonymous = false;\n      return this.baseProvider.get(invalidCredentials, options);\n    },\n  );\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Defines a CredentialsProvider that forwards requests to a SharedCredentialsProvider on\n * another thread.\n */\n\nimport type {\n  CredentialsManager,\n  CredentialsWithGeneration,\n  MaybeOptionalCredentialsProvider,\n} from \"#src/credentials_provider/index.js\";\nimport {\n  CachingCredentialsManager,\n  makeCachedCredentialsGetter,\n  CredentialsProvider,\n} from \"#src/credentials_provider/index.js\";\nimport {\n  CREDENTIALS_MANAGER_GET_RPC_ID,\n  CREDENTIALS_MANAGER_RPC_ID,\n  CREDENTIALS_PROVIDER_GET_RPC_ID,\n  CREDENTIALS_PROVIDER_RPC_ID,\n} from \"#src/credentials_provider/shared_common.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(CREDENTIALS_PROVIDER_RPC_ID)\nexport class SharedCredentialsProviderCounterpart<Credentials>\n  extends SharedObjectCounterpart\n  implements CredentialsProvider<Credentials>\n{\n  get = makeCachedCredentialsGetter(\n    (\n      invalidCredentials: CredentialsWithGeneration<Credentials> | undefined,\n      options: ProgressOptions,\n    ): Promise<CredentialsWithGeneration<Credentials>> =>\n      this.rpc!.promiseInvoke(\n        CREDENTIALS_PROVIDER_GET_RPC_ID,\n        { providerId: this.rpcId, invalidCredentials: invalidCredentials },\n        { signal: options.signal, progressListener: options.progressListener },\n      ),\n  );\n}\n\nexport function WithSharedCredentialsProviderCounterpart<Credentials>() {\n  return <TBase extends { new (...args: any[]): SharedObjectCounterpart }>(\n    Base: TBase,\n  ) =>\n    class extends Base {\n      credentialsProvider: MaybeOptionalCredentialsProvider<Credentials>;\n      constructor(...args: any[]) {\n        super(...args);\n        const options = args[1];\n        this.credentialsProvider = this.rpc!.getOptionalRef<\n          SharedCredentialsProviderCounterpart<Exclude<Credentials, undefined>>\n        >(options.credentialsProvider) as any;\n      }\n    };\n}\n\nclass ProxyCredentialsProvider<\n  Credentials,\n> extends CredentialsProvider<Credentials> {\n  constructor(\n    public rpc: RPC,\n    public managerId: number,\n    public key: string,\n    public parameters?: any,\n  ) {\n    super();\n  }\n  get = makeCachedCredentialsGetter(\n    (\n      invalidCredentials: CredentialsWithGeneration<Credentials> | undefined,\n      options: ProgressOptions,\n    ): Promise<CredentialsWithGeneration<Credentials>> =>\n      this.rpc.promiseInvoke(\n        CREDENTIALS_MANAGER_GET_RPC_ID,\n        {\n          managerId: this.managerId,\n          key: this.key,\n          parameters: this.parameters,\n          invalidCredentials: invalidCredentials,\n        },\n        { signal: options.signal, progressListener: options.progressListener },\n      ),\n  );\n}\n\n@registerSharedObject(CREDENTIALS_MANAGER_RPC_ID)\nexport class SharedCredentialsManagerCounterpart\n  extends SharedObjectCounterpart\n  implements CredentialsManager\n{\n  private impl: CachingCredentialsManager<CredentialsManager> =\n    new CachingCredentialsManager(this.makeBaseCredentialsManager());\n\n  private makeBaseCredentialsManager(): CredentialsManager {\n    return {\n      getCredentialsProvider: <Credentials>(key: string, parameters?: any) =>\n        new ProxyCredentialsProvider<Credentials>(\n          this.rpc!,\n          this.rpcId!,\n          key,\n          parameters,\n        ),\n    };\n  }\n\n  getCredentialsProvider<Credentials>(key: string, parameters?: any) {\n    return this.impl.getCredentialsProvider<Credentials>(key, parameters);\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/credentials_provider/shared_counterpart.js\";\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport type { SharedCredentialsManagerCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport { KvStoreContext } from \"#src/kvstore/context.js\";\nimport {\n  frontendBackendIsomorphicKvStoreProviderRegistry,\n  KvStoreProviderRegistry,\n} from \"#src/kvstore/register.js\";\nimport { SHARED_KVSTORE_CONTEXT_RPC_ID } from \"#src/kvstore/shared_common.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(SHARED_KVSTORE_CONTEXT_RPC_ID)\nexport class SharedKvStoreContextCounterpart extends SharedObjectCounterpart {\n  kvStoreContext: KvStoreContext;\n\n  chunkManager: ChunkManager;\n  credentialsManager: SharedCredentialsManagerCounterpart;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.chunkManager = rpc.get(options.chunkManager) as ChunkManager;\n    this.credentialsManager = rpc.get(\n      options.credentialsManager,\n    ) as SharedCredentialsManagerCounterpart;\n    this.kvStoreContext = new KvStoreContext();\n    frontendBackendIsomorphicKvStoreProviderRegistry.applyToContext(this);\n    backendOnlyKvStoreProviderRegistry.applyToContext(this);\n  }\n}\n\nexport const backendOnlyKvStoreProviderRegistry =\n  new KvStoreProviderRegistry<SharedKvStoreContextCounterpart>();\n\nexport function WithSharedKvStoreContextCounterpart<\n  TBase extends { new (...args: any[]): SharedObjectCounterpart },\n>(Base: TBase) {\n  return class extends Base {\n    sharedKvStoreContext: SharedKvStoreContextCounterpart;\n    constructor(...args: any[]) {\n      super(...args);\n      const options = args[1];\n      this.sharedKvStoreContext = this.rpc!.get(options.sharedKvStoreContext);\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ChunkRenderLayerBackend } from \"#src/chunk_manager/backend.js\";\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport {\n  PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID,\n  PROJECTION_PARAMETERS_RPC_ID,\n  RENDERED_VIEW_ADD_LAYER_RPC_ID,\n  RENDERED_VIEW_REMOVE_LAYER_RPC_ID,\n} from \"#src/render_layer_common.js\";\nimport type {\n  WatchableValueChangeInterface,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nexport interface RenderedViewBackend {\n  visibility: WatchableValueInterface<number>;\n  projectionParameters: WatchableValueInterface<ProjectionParameters>;\n}\n\nexport class RenderLayerBackendAttachment<\n  ViewBackend extends RenderedViewBackend = RenderedViewBackend,\n  AttachmentState = unknown,\n> extends RefCounted {\n  state: AttachmentState | undefined = undefined;\n  constructor(public view: ViewBackend) {\n    super();\n  }\n}\n\nexport class RenderLayerBackend<\n  ViewBackend extends RenderedViewBackend = RenderedViewBackend,\n  AttachmentState = unknown,\n> extends ChunkRenderLayerBackend {\n  attachments = new Map<ViewBackend, RenderLayerBackendAttachment>();\n  attach(\n    attachment: RenderLayerBackendAttachment<ViewBackend, AttachmentState>,\n  ) {\n    attachment;\n  }\n}\n\nregisterRPC(RENDERED_VIEW_ADD_LAYER_RPC_ID, function (x) {\n  const view: RenderedViewBackend = this.get(x.view);\n  const layer: RenderLayerBackend = this.get(x.layer);\n  const attachment = new RenderLayerBackendAttachment(view);\n  layer.attachments.set(view, attachment);\n  layer.attach(attachment);\n});\n\nregisterRPC(RENDERED_VIEW_REMOVE_LAYER_RPC_ID, function (x) {\n  const view: RenderedViewBackend = this.get(x.view);\n  const layer: RenderLayerBackend = this.get(x.layer);\n  const attachment = layer.attachments.get(view)!;\n  layer.attachments.delete(view);\n  attachment.dispose();\n});\n\n@registerSharedObject(PROJECTION_PARAMETERS_RPC_ID)\nexport class SharedProjectionParametersBackend<\n    T extends ProjectionParameters = ProjectionParameters,\n  >\n  extends SharedObjectCounterpart\n  implements WatchableValueChangeInterface<T>\n{\n  value: T;\n  oldValue: T;\n  changed = new Signal<(oldValue: T, newValue: T) => void>();\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.value = options.value;\n    this.oldValue = Object.assign({}, this.value);\n  }\n}\n\nregisterRPC(PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID, function (x) {\n  const obj: SharedProjectionParametersBackend = this.get(x.id);\n  const { value, oldValue } = obj;\n  Object.assign(oldValue, value);\n  Object.assign(value, x.value);\n  obj.changed.dispatch(oldValue, value);\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface WritableArrayLike<T> {\n  length: number;\n  [n: number]: T;\n}\n\n/**\n * Partitions array[start:end] such that all elements for which predicate\n * returns true are before the elements for which predicate returns false.\n *\n * predicate will be called exactly once for each element in array[start:end],\n * in order.\n *\n * @returns {number} The index of the first element for which predicate returns\n * false, or end if there is no such element.\n */\nexport function partitionArray<T>(\n  array: T[],\n  start: number,\n  end: number,\n  predicate: (x: T) => boolean,\n): number {\n  while (start < end) {\n    const x = array[start];\n    if (predicate(x)) {\n      ++start;\n      continue;\n    }\n    --end;\n    array[start] = array[end];\n    array[end] = x;\n  }\n  return end;\n}\n\nexport function filterArrayInplace<T>(\n  array: T[],\n  predicate: (x: T, index: number, array: T[]) => boolean,\n) {\n  const length = array.length;\n  let outIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    if (predicate(array[i], i, array)) {\n      array[outIndex] = array[i];\n      ++outIndex;\n    }\n  }\n  array.length = outIndex;\n}\n\nexport type TypedNumberArrayConstructor<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> = (\n  | typeof Int8Array<TArrayBuffer>\n  | typeof Uint8Array<TArrayBuffer>\n  | typeof Int16Array<TArrayBuffer>\n  | typeof Uint16Array<TArrayBuffer>\n  | typeof Int32Array<TArrayBuffer>\n  | typeof Uint32Array<TArrayBuffer>\n  | typeof Float32Array<TArrayBuffer>\n  | typeof Float64Array<TArrayBuffer>\n) &\n  (TArrayBuffer extends ArrayBuffer\n    ? { new (count: number): TypedNumberArray<ArrayBuffer> }\n    : Record<string, never>);\n\nexport type TypedBigIntArrayConstructor<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> = (typeof BigUint64Array<TArrayBuffer> | typeof BigInt64Array<TArrayBuffer>) &\n  (TArrayBuffer extends ArrayBuffer\n    ? { new (count: number): TypedBigIntArray<ArrayBuffer> }\n    : Record<string, never>);\n\nexport type TypedArrayConstructor<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> =\n  | TypedNumberArrayConstructor<TArrayBuffer>\n  | TypedBigIntArrayConstructor<TArrayBuffer>;\n\nexport type TypedNumberArray<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> =\n  | Int8Array<TArrayBuffer>\n  | Uint8Array<TArrayBuffer>\n  | Int16Array<TArrayBuffer>\n  | Uint16Array<TArrayBuffer>\n  | Int32Array<TArrayBuffer>\n  | Uint32Array<TArrayBuffer>\n  | Float32Array<TArrayBuffer>\n  | Float64Array<TArrayBuffer>;\n\nexport type TypedBigIntArray<\n  TArrayBuffer extends ArrayBufferLike = ArrayBufferLike,\n> = BigInt64Array<TArrayBuffer> | BigUint64Array<TArrayBuffer>;\n\nexport type TypedArray<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> =\n  TypedNumberArray<TArrayBuffer> | TypedBigIntArray<TArrayBuffer>;\n\n/**\n * Returns an array of size newSize that starts with the contents of array.\n * Either returns array if it has the correct size, or a new array with zero\n * padding at the end.\n */\nexport function maybePadArray<\n  TArrayBuffer extends ArrayBufferLike,\n  T extends TypedNumberArray<TArrayBuffer>,\n>(array: T, newSize: number): T {\n  if (array.length === newSize) {\n    return array;\n  }\n  const newArray = new (<any>array.constructor)(newSize);\n  newArray.set(array);\n  return newArray;\n}\n\nexport function getFortranOrderStrides(\n  size: ArrayLike<number>,\n  baseStride = 1,\n) {\n  const length = size.length;\n  const strides = new Array<number>(length);\n  let stride = (strides[0] = baseStride);\n  for (let i = 1; i < length; ++i) {\n    stride *= size[i - 1];\n    strides[i] = stride;\n  }\n  return strides;\n}\n\n/**\n * Converts an array of shape [majorSize, minorSize] to\n * [minorSize, majorSize].\n */\nexport function transposeArray2d<T extends TypedNumberArray>(\n  array: T,\n  majorSize: number,\n  minorSize: number,\n): T {\n  const transpose = new (<any>array.constructor)(array.length);\n  for (let i = 0; i < majorSize * minorSize; i += minorSize) {\n    for (let j = 0; j < minorSize; j++) {\n      const index: number = i / minorSize;\n      transpose[j * majorSize + index] = array[i + j];\n    }\n  }\n  return transpose;\n}\n\nexport function tile2dArray<T extends TypedNumberArray>(\n  array: T,\n  majorDimension: number,\n  minorTiles: number,\n  majorTiles: number,\n) {\n  const minorDimension = array.length / majorDimension;\n  const length = array.length * minorTiles * majorTiles;\n  const result: T = new (<any>array.constructor)(length);\n  const minorTileStride = array.length * majorTiles;\n  const majorTileStride = majorDimension;\n  const minorStride = majorDimension * majorTiles;\n  for (let minor = 0; minor < minorDimension; ++minor) {\n    for (let major = 0; major < majorDimension; ++major) {\n      const inputValue = array[minor * majorDimension + major];\n      const baseOffset = minor * minorStride + major;\n      for (let minorTile = 0; minorTile < minorTiles; ++minorTile) {\n        for (let majorTile = 0; majorTile < majorTiles; ++majorTile) {\n          result[\n            minorTile * minorTileStride +\n              majorTile * majorTileStride +\n              baseOffset\n          ] = inputValue;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nexport function binarySearch<Hay, Needle>(\n  haystack: ArrayLike<Hay>,\n  needle: Needle,\n  compare: (a: Needle, b: Hay) => number,\n  low = 0,\n  high = haystack.length,\n): number {\n  while (low < high) {\n    const mid = (low + high - 1) >> 1;\n    const compareResult = compare(needle, haystack[mid]);\n    if (compareResult > 0) {\n      low = mid + 1;\n    } else if (compareResult < 0) {\n      high = mid;\n    } else {\n      return mid;\n    }\n  }\n  return ~low;\n}\n\n/**\n * Returns the index of the element in `haystack` that is closest to `needle`, according to\n * `compare`.  If there are multiple elements that are equally close, the index of the first such\n * element encountered is returned.  If `haystack` is empty, returns -1.\n */\nexport function findClosestMatchInSortedArray<T>(\n  haystack: ArrayLike<T>,\n  needle: T,\n  compare: (a: T, b: T) => number,\n  low = 0,\n  high = haystack.length,\n): number {\n  let bestIndex = -1;\n  let bestDistance = Infinity;\n  while (low < high) {\n    const mid = (low + high - 1) >> 1;\n    const compareResult = compare(needle, haystack[mid]);\n    if (compareResult > 0) {\n      low = mid + 1;\n    } else if (compareResult < 0) {\n      high = mid;\n    } else {\n      return mid;\n    }\n    const distance = Math.abs(compareResult);\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      bestIndex = mid;\n    }\n  }\n  return bestIndex;\n}\n\n/**\n * Returns the first index in `[begin, end)` for which `predicate` is `true`, or returns `end` if no\n * such index exists.\n *\n * For any index `i` in `(begin, end)`, it must be the case that `predicate(i) >= predicate(i - 1)`.\n */\nexport function binarySearchLowerBound(\n  begin: number,\n  end: number,\n  predicate: (index: number) => boolean,\n): number {\n  let count = end - begin;\n  while (count > 0) {\n    const step = Math.floor(count / 2);\n    const i = begin + step;\n    if (predicate(i)) {\n      count = step;\n    } else {\n      begin = i + 1;\n      count -= step + 1;\n    }\n  }\n  return begin;\n}\n\n/**\n * Returns an array of indices into `input` that equal (under `===`) `value`.\n */\nexport function findMatchingIndices<T>(input: T[], value: T) {\n  const out: number[] = [];\n  for (let i = 0, length = input.length; i < length; ++i) {\n    if (input[i] === value) {\n      out.push(i);\n    }\n  }\n  return out;\n}\n\n/**\n * Returns an array of the indices in `[0, ..., max)` not in `indices`.\n */\nexport function getIndicesComplement(indices: number[], max: number) {\n  const mask: boolean[] = [];\n  mask.length = max;\n  for (const i of indices) {\n    mask[i] = true;\n  }\n  return findMatchingIndices(mask, undefined);\n}\n\nexport function arraysEqual<T>(a: ArrayLike<T>, b: ArrayLike<T>) {\n  const length = a.length;\n  if (b.length !== length) return false;\n  for (let i = 0; i < length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function arraysEqualWithPredicate<T>(\n  a: ArrayLike<T>,\n  b: ArrayLike<T>,\n  elementsEqual: (a: T, b: T) => boolean = (a, b) => a === b,\n) {\n  const length = a.length;\n  if (b.length !== length) return false;\n  for (let i = 0; i < length; ++i) {\n    if (!elementsEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function getInsertPermutation(\n  n: number,\n  sourceIndex: number,\n  targetIndex: number,\n) {\n  const newToOld: number[] = [];\n  if (targetIndex === sourceIndex) {\n    for (let i = 0; i < n; ++i) {\n      newToOld[i] = i;\n    }\n    return newToOld;\n  }\n  newToOld[targetIndex] = sourceIndex;\n  for (let oldDim = 0, newDim = 0; oldDim < n; ) {\n    if (oldDim === sourceIndex) {\n      ++oldDim;\n      continue;\n    }\n    if (newDim === targetIndex) {\n      ++newDim;\n    }\n    newToOld[newDim++] = oldDim++;\n  }\n  return newToOld;\n}\n\nexport function scatterUpdate<\n  T,\n  Dest extends { [index: number]: T },\n  Source extends { readonly [index: number]: T },\n>(dest: Dest, source: Source, indices: ArrayLike<number>): Dest {\n  for (\n    let sourceIndex = 0, length = indices.length;\n    sourceIndex < length;\n    ++sourceIndex\n  ) {\n    const destIndex = indices[sourceIndex];\n    if (destIndex === -1) continue;\n    dest[destIndex] = source[sourceIndex];\n  }\n  return dest;\n}\n\nexport function gatherUpdate<\n  T,\n  Dest extends { [index: number]: T },\n  Source extends { readonly [index: number]: T },\n>(dest: Dest, source: Source, indices: ArrayLike<number>): Dest {\n  for (\n    let destIndex = 0, length = indices.length;\n    destIndex < length;\n    ++destIndex\n  ) {\n    const sourceIndex = indices[destIndex];\n    if (sourceIndex === -1) continue;\n    dest[destIndex] = source[sourceIndex];\n  }\n  return dest;\n}\n\nexport function transposeNestedArrays<T>(x: T[][]) {\n  const result: T[][] = [];\n  for (\n    let outerIndex = 0, outerLength = x.length;\n    outerIndex < outerLength;\n    ++outerIndex\n  ) {\n    const inner = x[outerIndex];\n    for (\n      let innerIndex = 0, innerLength = inner.length;\n      innerIndex < innerLength;\n      ++innerIndex\n    ) {\n      let resultInner = result[innerIndex];\n      if (resultInner === undefined) {\n        resultInner = result[innerIndex] = [];\n      }\n      resultInner.push(inner[innerIndex]);\n    }\n  }\n  return result;\n}\n\nexport interface ArraySpliceOp {\n  retainCount: number;\n  deleteCount: number;\n  insertCount: number;\n}\n\nexport function spliceArray<T>(\n  array: T[],\n  splices: readonly Readonly<ArraySpliceOp>[],\n) {\n  const parts: T[][] = [];\n  let origOffset = 0;\n  for (let i = 0, numSplices = splices.length; i < numSplices; ++i) {\n    const { retainCount, deleteCount, insertCount } = splices[i];\n    if (retainCount !== 0) {\n      parts.push(array.slice(origOffset, origOffset + retainCount));\n      origOffset += retainCount;\n    }\n    origOffset += deleteCount;\n    if (insertCount !== 0) {\n      parts.push(new Array<T>(insertCount));\n    }\n  }\n  const origLength = array.length;\n  if (origOffset !== origLength) {\n    parts.push(array.slice(origOffset));\n  }\n  return new Array(0).concat(...parts);\n}\n\nexport function getMergeSplices<T>(\n  oldArray: readonly T[],\n  newArray: readonly T[],\n  compare: (a: T, b: T) => number,\n): ArraySpliceOp[] {\n  const splices: ArraySpliceOp[] = [];\n  let oldIndex = 0;\n  let newIndex = 0;\n  const oldCount = oldArray.length;\n  const newCount = newArray.length;\n  while (oldIndex < oldCount && newIndex < newCount) {\n    let c: number;\n    const oldValue = oldArray[oldIndex];\n    const newValue = newArray[newIndex];\n    c = compare(oldValue, newValue);\n    if (c === 0) {\n      let retainCount = 1;\n      ++oldIndex;\n      ++newIndex;\n      while (\n        oldIndex < oldCount &&\n        newIndex < newCount &&\n        (c = compare(oldArray[oldIndex], newArray[newIndex])) === 0\n      ) {\n        ++retainCount;\n        ++oldIndex;\n        ++newIndex;\n      }\n      splices.push({ retainCount, deleteCount: 0, insertCount: 0 });\n      continue;\n    }\n    if (c < 0) {\n      let deleteCount = 1;\n      while (\n        ++oldIndex < oldCount &&\n        (c = compare(oldArray[oldIndex], newValue)) < 0\n      ) {\n        ++deleteCount;\n      }\n      splices.push({ retainCount: 0, deleteCount, insertCount: 0 });\n      continue;\n    }\n    if (c > 0) {\n      let insertCount = 1;\n      while (\n        ++newIndex < newCount &&\n        (c = compare(oldValue, newArray[newIndex])) > 0\n      ) {\n        ++insertCount;\n      }\n      splices.push({ retainCount: 0, deleteCount: 0, insertCount });\n    }\n  }\n  if (oldIndex < oldCount || newIndex < newCount) {\n    splices.push({\n      retainCount: 0,\n      deleteCount: oldCount - oldIndex,\n      insertCount: newCount - newIndex,\n    });\n  }\n  return splices;\n}\n\nexport function getFixedOrderMergeSplices<T>(\n  oldArray: readonly T[],\n  newArray: readonly T[],\n  equal: (a: T, b: T) => boolean,\n): ArraySpliceOp[] {\n  const splices: ArraySpliceOp[] = [];\n  let oldIndex = 0;\n  let newIndex = 0;\n  const oldCount = oldArray.length;\n  const newCount = newArray.length;\n  while (oldIndex < oldCount) {\n    let retainCount = 0;\n    while (\n      oldIndex < oldCount &&\n      newIndex < newCount &&\n      equal(oldArray[oldIndex], newArray[newIndex])\n    ) {\n      ++retainCount;\n      ++oldIndex;\n      ++newIndex;\n    }\n    if (retainCount !== 0) {\n      splices.push({ retainCount, deleteCount: 0, insertCount: 0 });\n    }\n    let deleteCount = 0;\n    while (\n      oldIndex < oldCount &&\n      (newIndex === newCount || !equal(oldArray[oldIndex], newArray[newIndex]))\n    ) {\n      ++deleteCount;\n      ++oldIndex;\n    }\n    if (deleteCount !== 0) {\n      splices.push({ retainCount: 0, deleteCount, insertCount: 0 });\n    }\n  }\n  if (newIndex !== newCount) {\n    splices.push({\n      retainCount: 0,\n      deleteCount: 0,\n      insertCount: newCount - newIndex,\n    });\n  }\n  return splices;\n}\n\nexport function mergeSequences(\n  aCount: number,\n  bCount: number,\n  compare: (a: number, b: number) => number,\n  aCallback: (a: number) => void,\n  bCallback: (b: number) => void,\n  abCallback: (a: number, b: number) => void,\n) {\n  let a = 0;\n  let b = 0;\n  if (aCount !== 0 && bCount !== 0) {\n    while (true) {\n      const x = compare(a, b);\n      if (x < 0) {\n        aCallback(a);\n        if (++a === aCount) break;\n      } else if (x > 0) {\n        bCallback(b);\n        if (++b === bCount) break;\n      } else {\n        abCallback(a, b);\n        ++a;\n        ++b;\n        if (a === aCount || b === bCount) break;\n      }\n    }\n  }\n  while (a < aCount) {\n    aCallback(a);\n    ++a;\n  }\n  while (b < bCount) {\n    bCallback(b);\n    ++b;\n  }\n}\n\nexport class TypedArrayBuilder<T extends TypedArray<ArrayBuffer>> {\n  data: T;\n  length: number = 0;\n  constructor(cls: { new (count: number): T }, initialCapacity: number = 16) {\n    this.data = new cls(initialCapacity);\n  }\n\n  resize(newLength: number) {\n    const { data } = this;\n    if (newLength > data.length) {\n      const newData = new (data.constructor as { new (count: number): T })(\n        Math.max(newLength, data.length * 2),\n      );\n      newData.set(data.subarray(0, this.length) as any);\n      this.data = newData;\n    }\n    this.length = newLength;\n  }\n\n  get view(): T {\n    return this.data.subarray(0, this.length) as T;\n  }\n\n  shrinkToFit() {\n    this.data = this.data.slice(0, length) as T;\n  }\n\n  clear() {\n    this.length = 0;\n  }\n\n  appendArray(other: ArrayLike<T extends TypedBigIntArray ? bigint : number>) {\n    const { length } = this;\n    this.resize(length + other.length);\n    this.data.set(other as any, length);\n  }\n\n  eraseRange(start: number, end: number) {\n    this.data.copyWithin(start, end, this.length);\n    this.length -= end - start;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { binarySearchLowerBound } from \"#src/util/array.js\";\n\nexport interface SiPrefix {\n  readonly prefix: string;\n  readonly exponent: number;\n  readonly longPrefix?: string;\n}\n\nexport const preferredSiPrefixes: readonly SiPrefix[] = [\n  { prefix: \"Y\", exponent: 24, longPrefix: \"yotta\" },\n  { prefix: \"Z\", exponent: 21, longPrefix: \"zetta\" },\n  { prefix: \"E\", exponent: 18, longPrefix: \"exa\" },\n  { prefix: \"P\", exponent: 15, longPrefix: \"peta\" },\n  { prefix: \"T\", exponent: 12, longPrefix: \"tera\" },\n  { prefix: \"G\", exponent: 9, longPrefix: \"giga\" },\n  { prefix: \"M\", exponent: 6, longPrefix: \"mega\" },\n  { prefix: \"k\", exponent: 3, longPrefix: \"kilo\" },\n  { prefix: \"\", exponent: 0, longPrefix: \"\" },\n  { prefix: \"m\", exponent: -3, longPrefix: \"milli\" },\n  { prefix: \"µ\", exponent: -6, longPrefix: \"micro\" },\n  { prefix: \"n\", exponent: -9, longPrefix: \"nano\" },\n  { prefix: \"p\", exponent: -12, longPrefix: \"pico\" },\n  { prefix: \"f\", exponent: -15, longPrefix: \"femto\" },\n  { prefix: \"a\", exponent: -18, longPrefix: \"atto\" },\n  { prefix: \"z\", exponent: -21, longPrefix: \"zepto\" },\n  { prefix: \"y\", exponent: -24, longPrefix: \"yocto\" },\n];\n\nexport const allSiPrefixes: readonly SiPrefix[] = [\n  ...preferredSiPrefixes,\n  { prefix: \"h\", exponent: 2, longPrefix: \"hecto\" },\n  { prefix: \"da\", exponent: 1, longPrefix: \"deca\" },\n  { prefix: \"d\", exponent: -1, longPrefix: \"deci\" },\n  { prefix: \"c\", exponent: -2, longPrefix: \"centi\" },\n];\n\nconst siPrefixesWithAlternatives: readonly SiPrefix[] = [\n  { prefix: \"u\", exponent: -6 }, // Also allow \"u\" for micro\n  ...allSiPrefixes,\n];\n\nexport const supportedUnits = new Map<\n  string,\n  { unit: string; exponent: number }\n>();\nsupportedUnits.set(\"\", { unit: \"\", exponent: 0 });\nexport const exponentToPrefix = new Map<number, string>();\nfor (const { prefix, exponent } of siPrefixesWithAlternatives) {\n  exponentToPrefix.set(exponent, prefix);\n  for (const unit of [\"m\", \"s\", \"Hz\", \"rad/s\"]) {\n    supportedUnits.set(`${prefix}${unit}`, { unit, exponent });\n  }\n}\n\nexport function pickSiPrefix(x: number): SiPrefix {\n  const exponent = Math.log10(x);\n  const numPrefixes = preferredSiPrefixes.length;\n  const i = binarySearchLowerBound(\n    0,\n    numPrefixes,\n    (i) => preferredSiPrefixes[i].exponent <= exponent,\n  );\n  return preferredSiPrefixes[Math.min(i, numPrefixes - 1)];\n}\n\ninterface FormatScaleWithUnitOptions {\n  precision?: number;\n  elide1?: boolean;\n}\n\nexport function formatScaleWithUnit(\n  scale: number,\n  unit: string,\n  options: FormatScaleWithUnitOptions = {},\n): { scale: string; prefix: string; unit: string } {\n  const { precision = 6, elide1 = true } = options;\n  let adjustedScale = scale;\n  let prefix = \"\";\n  if (unit !== \"\") {\n    const result = pickSiPrefix(scale);\n    prefix = result.prefix;\n    adjustedScale = scaleByExp10(scale, -result.exponent);\n  }\n  if (elide1 && adjustedScale === 1) {\n    return { scale: \"\", unit, prefix };\n  }\n  let scaleString: string;\n  if (precision !== 0) {\n    if (adjustedScale < 1 || adjustedScale >= 1000) {\n      scaleString = adjustedScale.toPrecision(precision);\n    } else {\n      scaleString = adjustedScale.toFixed(precision);\n    }\n    const eIndex = scaleString.indexOf(\"e\");\n    let numString: string;\n    let exponentString: string;\n    if (eIndex !== -1) {\n      numString = scaleString.substring(0, eIndex);\n      exponentString = scaleString.substring(eIndex);\n    } else {\n      numString = scaleString;\n      exponentString = \"\";\n    }\n    const m = numString.match(/.*\\.(?:[0-9]*[1-9])?(0+)$/);\n    if (m !== null) {\n      numString = numString.substring(0, numString.length - m[1].length);\n      if (numString.endsWith(\".\")) {\n        numString = numString.substring(0, numString.length - 1);\n      }\n      scaleString = numString + exponentString;\n    }\n  } else {\n    scaleString = adjustedScale.toString();\n  }\n  return {\n    scale: scaleString,\n    unit,\n    prefix,\n  };\n}\n\nexport function formatScaleWithUnitAsString(\n  scale: number,\n  unit: string,\n  options?: FormatScaleWithUnitOptions,\n): string {\n  const {\n    scale: formattedScale,\n    unit: formattedUnit,\n    prefix,\n  } = formatScaleWithUnit(scale, unit, options);\n  return `${formattedScale}${prefix}${formattedUnit}`;\n}\n\nexport function parseScale(s: string) {\n  if (s === \"\") {\n    return { scale: 1, unit: \"\" };\n  }\n  const match = s.match(\n    /^((?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)?([µa-zA-Z]+)?$/,\n  );\n  if (match === null) return undefined;\n  const scaleString = match[1];\n  let scale = scaleString === undefined ? 1 : Number(scaleString);\n  if (Number.isNaN(scale)) return undefined;\n  let unit = \"\";\n  if (match[2] !== undefined) {\n    const result = supportedUnits.get(match[2]);\n    if (result === undefined) {\n      return undefined;\n    }\n    unit = result.unit;\n    if (result.exponent > 0) {\n      scale *= 10 ** result.exponent;\n    } else {\n      scale /= 10 ** -result.exponent;\n    }\n  }\n  if (scale <= 0 || !Number.isFinite(scale)) return undefined;\n  return { scale, unit };\n}\n\nexport function unitFromJson(x: unknown) {\n  const result = supportedUnits.get(x as string);\n  if (result === undefined) {\n    throw new Error(`Invalid unit: ${JSON.stringify(x)}`);\n  }\n  return result;\n}\n\n/**\n * Returns `scale * 10**exponent`, but uses division for negative exponents to reduce loss of\n * precision.\n */\nexport function scaleByExp10(scale: number, exponent: number) {\n  if (exponent >= 0) return scale * 10 ** exponent;\n  return scale / 10 ** -exponent;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedNumberArray } from \"#src/util/array.js\";\n\nexport function equal<T extends TypedNumberArray, U extends TypedNumberArray>(\n  a: T,\n  b: U,\n) {\n  const n = a.length;\n  for (let i = 0; i < n; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function add<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] + b[i];\n  }\n  return out;\n}\nexport function subtract<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] - b[i];\n  }\n  return out;\n}\nexport function multiply<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] * b[i];\n  }\n  return out;\n}\nexport function divide<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] / b[i];\n  }\n  return out;\n}\nexport function scaleAndAdd<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B, scale: number) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] + b[i] * scale;\n  }\n  return out;\n}\nexport function scale<Out extends TypedNumberArray, A extends TypedNumberArray>(\n  out: Out,\n  a: A,\n  scale: number,\n) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = a[i] * scale;\n  }\n  return out;\n}\n\nexport function prod(array: ArrayLike<number>) {\n  let result = 1;\n  for (let i = 0, length = array.length; i < length; ++i) {\n    result *= array[i];\n  }\n  return result;\n}\n\nexport function min<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = Math.min(a[i], b[i]);\n  }\n  return out;\n}\n\nexport function max<\n  Out extends TypedNumberArray,\n  A extends TypedNumberArray,\n  B extends TypedNumberArray,\n>(out: Out, a: A, b: B) {\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = Math.max(a[i], b[i]);\n  }\n  return out;\n}\n\nexport const kEmptyFloat32Vec = new Float32Array(0);\nexport const kEmptyFloat64Vec = new Float64Array(0);\nexport const kFloat64Vec3Of1 = Float64Array.of(1, 1, 1);\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport {\n  arraysEqual,\n  arraysEqualWithPredicate,\n  getInsertPermutation,\n} from \"#src/util/array.js\";\nimport {\n  getDependentTransformInputDimensions,\n  mat4,\n  quat,\n  vec3,\n} from \"#src/util/geom.js\";\nimport {\n  expectArray,\n  parseArray,\n  parseFiniteVec,\n  parseFixedLengthArray,\n  verifyFiniteFloat,\n  verifyFinitePositiveFloat,\n  verifyIntegerArray,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalObjectProperty,\n  verifyString,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport {\n  scaleByExp10,\n  supportedUnits,\n  unitFromJson,\n} from \"#src/util/si_units.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { Trackable } from \"#src/util/trackable.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport type DimensionId = number;\n\nlet nextDimensionId = 0;\n\nexport function newDimensionId(): DimensionId {\n  return ++nextDimensionId;\n}\n\nexport interface CoordinateArray {\n  // Indicates whether this coordinate array was specified explicitly, in which case it will be\n  // encoded in the JSON representation.\n  explicit: boolean;\n  // Specifies the coordinates.  Must be montonically increasing integers.\n  coordinates: number[];\n  // Specifies the label for each coordinate in `coordinates`.\n  labels: string[];\n}\n\nexport interface CoordinateSpace {\n  /**\n   * If `true`, has been fully initialized (i.e. based on at least one data source).  If `false`,\n   * may be partially initialized.\n   */\n  readonly valid: boolean;\n\n  readonly rank: number;\n\n  /**\n   * Specifies the name of each dimension.\n   */\n  readonly names: readonly string[];\n\n  readonly ids: readonly DimensionId[];\n\n  /**\n   * Timestamp of last user action that changed the name, scale, or unit of each dimension, or\n   * `undefined` if there was no user action.\n   */\n  readonly timestamps: readonly number[];\n\n  /**\n   * Specifies the physical units corresponding to this dimension.  May be empty to indicate\n   * unitless.\n   */\n  readonly units: readonly string[];\n\n  /**\n   * Specifies a scale for this dimension.\n   */\n  readonly scales: Float64Array;\n\n  readonly bounds: CoordinateSpaceBounds;\n  readonly boundingBoxes: readonly TransformedBoundingBox[];\n\n  readonly coordinateArrays: (CoordinateArray | undefined)[];\n}\n\nexport function boundingBoxesEqual(a: BoundingBox, b: BoundingBox) {\n  return (\n    arraysEqual(a.lowerBounds, b.lowerBounds) &&\n    arraysEqual(a.upperBounds, b.upperBounds)\n  );\n}\n\nexport function coordinateArraysEqual(\n  a: CoordinateArray | undefined,\n  b: CoordinateArray | undefined,\n) {\n  if (a === undefined) return b === undefined;\n  if (b === undefined) return false;\n  return (\n    a.explicit === b.explicit &&\n    arraysEqual(a.coordinates, b.coordinates) &&\n    arraysEqual(a.labels, b.labels)\n  );\n}\n\nexport function normalizeCoordinateArray(\n  coordinates: number[],\n  labels: string[],\n) {\n  const map = new Map<number, string>();\n  for (let i = 0, length = coordinates.length; i < length; ++i) {\n    map.set(coordinates[i], labels[i]);\n  }\n  coordinates = Array.from(map.keys());\n  coordinates.sort((a, b) => a - b);\n  labels = Array.from(coordinates, (x) => map.get(x)!);\n  return { coordinates, labels };\n}\n\nexport function mergeCoordinateArrays(\n  coordinateArrays: ReadonlyArray<CoordinateArray>,\n): CoordinateArray {\n  if (coordinateArrays.length === 1) return coordinateArrays[0];\n  const map = new Map<number, string>();\n  let explicit = false;\n  for (const x of coordinateArrays) {\n    if (x.explicit) explicit = true;\n    const { coordinates, labels } = x;\n    for (let i = 0, length = coordinates.length; i < length; ++i) {\n      map.set(coordinates[i], labels[i]);\n    }\n  }\n  const coordinates = Array.from(map.keys());\n  coordinates.sort((a, b) => a - b);\n  const labels = Array.from(coordinates, (x) => map.get(x)!);\n  return { explicit, coordinates, labels };\n}\n\nexport function mergeOptionalCoordinateArrays(\n  coordinateArrays: ReadonlyArray<CoordinateArray | undefined>,\n): CoordinateArray | undefined {\n  coordinateArrays = coordinateArrays.filter((x) => x !== undefined);\n  if (coordinateArrays.length === 0) return undefined;\n  return mergeCoordinateArrays(\n    coordinateArrays as ReadonlyArray<CoordinateArray>,\n  );\n}\n\nexport function transformedBoundingBoxesEqual(\n  a: TransformedBoundingBox,\n  b: TransformedBoundingBox,\n) {\n  return (\n    arraysEqual(a.transform, b.transform) && boundingBoxesEqual(a.box, b.box)\n  );\n}\n\nexport function coordinateSpacesEqual(a: CoordinateSpace, b: CoordinateSpace) {\n  return (\n    a.valid === b.valid &&\n    a.rank === b.rank &&\n    arraysEqual(a.names, b.names) &&\n    arraysEqual(a.ids, b.ids) &&\n    arraysEqual(a.timestamps, b.timestamps) &&\n    arraysEqual(a.units, b.units) &&\n    arraysEqual(a.scales, b.scales) &&\n    arraysEqualWithPredicate(\n      a.boundingBoxes,\n      b.boundingBoxes,\n      transformedBoundingBoxesEqual,\n    ) &&\n    arraysEqualWithPredicate(\n      a.coordinateArrays,\n      b.coordinateArrays,\n      coordinateArraysEqual,\n    )\n  );\n}\n\nexport function unitsFromJson(\n  units: string[],\n  scaleExponents: Float64Array,\n  obj: any,\n) {\n  parseFixedLengthArray(units, obj, (x: any, index: number) => {\n    const result = unitFromJson(x);\n    scaleExponents[index] = result.exponent;\n    return result.unit;\n  });\n}\n\nexport function makeCoordinateSpace(space: {\n  readonly valid?: boolean;\n  readonly names: readonly string[];\n  readonly units: readonly string[];\n  readonly scales: Float64Array;\n  readonly rank?: number;\n  readonly timestamps?: readonly number[];\n  readonly ids?: readonly DimensionId[];\n  readonly boundingBoxes?: readonly TransformedBoundingBox[];\n  readonly bounds?: CoordinateSpaceBounds;\n  readonly coordinateArrays?: (CoordinateArray | undefined)[];\n}): CoordinateSpace {\n  const { names, units, scales } = space;\n  const {\n    valid = true,\n    rank = names.length,\n    timestamps = names.map(() => Number.NEGATIVE_INFINITY),\n    ids = names.map((_, i) => -i),\n    boundingBoxes = [],\n  } = space;\n  const { coordinateArrays = new Array<CoordinateArray | undefined>(rank) } =\n    space;\n  const { bounds = computeCombinedBounds(boundingBoxes, rank) } = space;\n  return {\n    valid,\n    rank,\n    names,\n    timestamps,\n    ids,\n    units,\n    scales,\n    boundingBoxes,\n    bounds,\n    coordinateArrays,\n  };\n}\n\nexport const emptyInvalidCoordinateSpace = makeCoordinateSpace({\n  valid: false,\n  names: [],\n  units: [],\n  scales: vector.kEmptyFloat64Vec,\n  boundingBoxes: [],\n});\n\nexport const emptyValidCoordinateSpace = makeCoordinateSpace({\n  valid: true,\n  names: [],\n  units: [],\n  scales: vector.kEmptyFloat64Vec,\n  boundingBoxes: [],\n});\n\nfunction unitAndScaleFromJson(obj: unknown) {\n  const [scaleObj, unitObj] = expectArray(obj, 2);\n  const scale = verifyFinitePositiveFloat(scaleObj);\n  const unitString = verifyString(unitObj);\n  const result = supportedUnits.get(unitString);\n  if (result === undefined)\n    throw new Error(`Invalid unit: ${JSON.stringify(unitString)}`);\n  return { unit: result.unit, scale: scaleByExp10(scale, result.exponent) };\n}\n\nexport function coordinateSpaceFromJson(\n  obj: any,\n  allowNumericalDimensions = false,\n): CoordinateSpace {\n  if (obj === undefined) return emptyInvalidCoordinateSpace;\n  verifyObject(obj);\n  const names = dimensionNamesFromJson(\n    Object.keys(obj),\n    allowNumericalDimensions,\n  );\n  const rank = names.length;\n  const units = new Array<string>(rank);\n  const scales = new Float64Array(rank);\n  const coordinateArrays = new Array<CoordinateArray | undefined>(rank);\n  for (let i = 0; i < rank; ++i) {\n    verifyObjectProperty(obj, names[i], (mem) => {\n      if (Array.isArray(mem)) {\n        // Normal unit-scale dimension.\n        const { unit, scale } = unitAndScaleFromJson(mem);\n        units[i] = unit;\n        scales[i] = scale;\n      } else {\n        // Coordinate array dimension.\n        verifyObject(mem);\n        const coordinates = verifyObjectProperty(\n          mem,\n          \"coordinates\",\n          verifyIntegerArray,\n        );\n        const labels = verifyObjectProperty(mem, \"labels\", verifyStringArray);\n        const length = coordinates.length;\n        if (length !== labels.length) {\n          throw new Error(\n            `Length of coordinates array (${length}) ` +\n              `does not match length of labels array (${labels.length})`,\n          );\n        }\n        units[i] = \"\";\n        scales[i] = 1;\n        coordinateArrays[i] = {\n          explicit: true,\n          ...normalizeCoordinateArray(coordinates, labels),\n        };\n      }\n    });\n  }\n  return makeCoordinateSpace({\n    valid: false,\n    names,\n    units,\n    scales,\n    coordinateArrays,\n  });\n}\n\nexport function coordinateSpaceToJson(coordinateSpace: CoordinateSpace): any {\n  const { rank } = coordinateSpace;\n  if (rank === 0) return undefined;\n  const { names, units, scales, coordinateArrays } = coordinateSpace;\n  const json: any = {};\n  for (let i = 0; i < rank; ++i) {\n    const name = names[i];\n    const coordinateArray = coordinateArrays[i];\n    if (coordinateArray?.explicit) {\n      json[name] = {\n        coordinates: Array.from(coordinateArray.coordinates),\n        labels: coordinateArray.labels,\n      };\n    } else {\n      json[name] = [scales[i], units[i]];\n    }\n  }\n  return json;\n}\n\nexport class TrackableCoordinateSpace extends WatchableValue<CoordinateSpace> {\n  constructor() {\n    super(emptyInvalidCoordinateSpace);\n  }\n\n  toJSON() {\n    return coordinateSpaceToJson(this.value);\n  }\n  reset() {\n    this.value = emptyInvalidCoordinateSpace;\n  }\n  restoreState(obj: any) {\n    this.value = coordinateSpaceFromJson(obj);\n  }\n}\n\nexport interface BoundingBox {\n  lowerBounds: Float64Array;\n  upperBounds: Float64Array;\n}\n\nexport interface CoordinateSpaceBounds extends BoundingBox {\n  voxelCenterAtIntegerCoordinates: boolean[];\n}\n\nexport function roundCoordinateToVoxelCenter(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n) {\n  if (bounds.voxelCenterAtIntegerCoordinates[dimIndex]) {\n    coordinate = Math.round(coordinate);\n  } else {\n    coordinate = Math.floor(coordinate) + 0.5;\n  }\n  return coordinate;\n}\n\nexport function getDisplayLowerUpperBounds(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n) {\n  let lower = bounds.lowerBounds[dimIndex];\n  let upper = bounds.upperBounds[dimIndex];\n  if (bounds.voxelCenterAtIntegerCoordinates[dimIndex]) {\n    lower += 0.5;\n    upper += 0.5;\n  }\n  return [lower, upper];\n}\n\n// Clamps `coordinate` to `[lower, upper - 1]`.  This is intended to be used with\n// `roundCoordinateToVoxelCenter`.  If not rounding, it may be desirable to instead\n// clamp to `[lower upper]`.\nexport function clampCoordinateToBounds(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n) {\n  const upperBound = bounds.upperBounds[dimIndex];\n  if (Number.isFinite(upperBound)) {\n    coordinate = Math.min(coordinate, upperBound - 1);\n  }\n\n  const lowerBound = bounds.lowerBounds[dimIndex];\n  if (Number.isFinite(lowerBound)) {\n    coordinate = Math.max(coordinate, lowerBound);\n  }\n  return coordinate;\n}\n\nexport function clampAndRoundCoordinateToVoxelCenter(\n  bounds: CoordinateSpaceBounds,\n  dimIndex: number,\n  coordinate: number,\n): number {\n  coordinate = clampCoordinateToBounds(bounds, dimIndex, coordinate);\n  return roundCoordinateToVoxelCenter(bounds, dimIndex, coordinate);\n}\n\nexport function getCenterBound(lower: number, upper: number) {\n  let x = (lower + upper) / 2;\n  if (!Number.isFinite(x)) x = Math.min(Math.max(0, lower), upper);\n  return x;\n}\n\nexport function getBoundingBoxCenter(\n  out: Float32Array,\n  bounds: BoundingBox,\n): Float32Array {\n  const { lowerBounds, upperBounds } = bounds;\n  const rank = out.length;\n  for (let i = 0; i < rank; ++i) {\n    out[i] = getCenterBound(lowerBounds[i], upperBounds[i]);\n  }\n  return out;\n}\n\nexport interface TransformedBoundingBox {\n  box: BoundingBox;\n\n  /**\n   * Transform from \"box\" coordinate space to target coordinate space.\n   */\n  transform: Float64Array;\n}\n\nexport function makeIdentityTransformedBoundingBox(box: BoundingBox) {\n  const rank = box.lowerBounds.length;\n  return {\n    box,\n    transform: matrix.createIdentity(Float64Array, rank, rank + 1),\n  };\n}\n\nexport function computeCombinedLowerUpperBound(\n  boundingBox: TransformedBoundingBox,\n  outputDimension: number,\n  outputRank: number,\n): { lower: number; upper: number } | undefined {\n  const {\n    box: { lowerBounds: baseLowerBounds, upperBounds: baseUpperBounds },\n    transform,\n  } = boundingBox;\n  const inputRank = baseLowerBounds.length;\n  const stride = outputRank;\n  const offset = transform[stride * inputRank + outputDimension];\n  let targetLower = offset;\n  let targetUpper = offset;\n  let hasCoefficient = false;\n  for (let inputDim = 0; inputDim < inputRank; ++inputDim) {\n    const c = transform[stride * inputDim + outputDimension];\n    if (c === 0) continue;\n    const lower = c * baseLowerBounds[inputDim];\n    const upper = c * baseUpperBounds[inputDim];\n    targetLower += Math.min(lower, upper);\n    targetUpper += Math.max(lower, upper);\n    hasCoefficient = true;\n  }\n  if (!hasCoefficient) return undefined;\n  return { lower: targetLower, upper: targetUpper };\n}\n\nconst INTEGER_BOUNDS_EPSILON = 1e-3;\n\nexport function computeCombinedBounds(\n  boundingBoxes: readonly TransformedBoundingBox[],\n  outputRank: number,\n): CoordinateSpaceBounds {\n  const lowerBounds = new Float64Array(outputRank);\n  const upperBounds = new Float64Array(outputRank);\n  lowerBounds.fill(Number.NEGATIVE_INFINITY);\n  upperBounds.fill(Number.POSITIVE_INFINITY);\n\n  // Number of bounding boxes for which both lower and upper bound has a fractional part of `0.5`.\n  const halfIntegerBounds = new Array<number>(outputRank);\n  halfIntegerBounds.fill(0);\n\n  // Number of bounding boxes for which both lower and upper bound has a fractional part of `0.0`.\n  const integerBounds = new Array<number>(outputRank);\n  integerBounds.fill(0);\n\n  for (const boundingBox of boundingBoxes) {\n    for (let outputDim = 0; outputDim < outputRank; ++outputDim) {\n      const result = computeCombinedLowerUpperBound(\n        boundingBox,\n        outputDim,\n        outputRank,\n      );\n      if (result === undefined) continue;\n      let { lower: targetLower, upper: targetUpper } = result;\n      if (Number.isFinite(targetLower) && Number.isFinite(targetUpper)) {\n        let lowerRound: number;\n        let upperRound: number;\n        let lowerFloor: number;\n        let upperFloor: number;\n        if (\n          Math.abs(targetLower - (lowerRound = Math.round(targetLower))) <\n            INTEGER_BOUNDS_EPSILON &&\n          Math.abs(targetUpper - (upperRound = Math.round(targetUpper))) <\n            INTEGER_BOUNDS_EPSILON\n        ) {\n          ++integerBounds[outputDim];\n          targetLower = lowerRound;\n          targetUpper = upperRound;\n        } else if (\n          Math.abs(targetLower - (lowerFloor = Math.floor(targetLower)) - 0.5) <\n            INTEGER_BOUNDS_EPSILON &&\n          Math.abs(targetUpper - (upperFloor = Math.floor(targetUpper)) - 0.5) <\n            INTEGER_BOUNDS_EPSILON\n        ) {\n          ++halfIntegerBounds[outputDim];\n          targetLower = lowerFloor + 0.5;\n          targetUpper = upperFloor + 0.5;\n        }\n      }\n      lowerBounds[outputDim] =\n        lowerBounds[outputDim] === Number.NEGATIVE_INFINITY\n          ? targetLower\n          : Math.min(lowerBounds[outputDim], targetLower);\n      upperBounds[outputDim] =\n        upperBounds[outputDim] === Number.POSITIVE_INFINITY\n          ? targetUpper\n          : Math.max(upperBounds[outputDim], targetUpper);\n    }\n  }\n\n  const voxelCenterAtIntegerCoordinates = integerBounds.map(\n    (integerCount, i) => {\n      const halfIntegerCount = halfIntegerBounds[i];\n      // If all bounding boxes have half-integer bounds, assume voxel center is at integer\n      // coordinates.  Otherwise, assume voxel center is at half-integer coordinates.\n      return halfIntegerCount > 0 && integerCount === 0;\n    },\n  );\n  return { lowerBounds, upperBounds, voxelCenterAtIntegerCoordinates };\n}\n\nexport function extendTransformedBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  newOutputRank: number,\n  newOutputDims: readonly number[],\n): TransformedBoundingBox {\n  const { transform: oldTransform, box } = boundingBox;\n  const oldOutputRank = newOutputDims.length;\n  const inputRank = box.lowerBounds.length;\n  const newTransform = new Float64Array((inputRank + 1) * newOutputRank);\n  for (let oldOutputDim = 0; oldOutputDim < oldOutputRank; ++oldOutputDim) {\n    const newOutputDim = newOutputDims[oldOutputDim];\n    if (newOutputDim === -1) continue;\n    for (let inputDim = 0; inputDim <= inputRank; ++inputDim) {\n      newTransform[inputDim * newOutputRank + newOutputDim] =\n        oldTransform[inputDim * oldOutputRank + oldOutputDim];\n    }\n  }\n  return {\n    transform: newTransform,\n    box,\n  };\n}\n\nexport function makeSingletonDimTransformedBoundingBox(\n  outputRank: number,\n  outputDim: number,\n) {\n  const box = {\n    lowerBounds: Float64Array.of(0),\n    upperBounds: Float64Array.of(1),\n  };\n  const transform = new Float64Array(2 * outputRank);\n  transform[outputDim] = 1;\n  return { transform, box };\n}\n\nexport function extendTransformedBoundingBoxUpToRank(\n  boundingBox: TransformedBoundingBox,\n  oldOutputRank: number,\n  newOutputRank: number,\n): TransformedBoundingBox {\n  if (oldOutputRank === newOutputRank) return boundingBox;\n  const { box } = boundingBox;\n  const inputRank = box.lowerBounds.length;\n  const transform = new Float64Array((inputRank + 1) * newOutputRank);\n  matrix.copy(\n    transform,\n    newOutputRank,\n    boundingBox.transform,\n    oldOutputRank,\n    oldOutputRank,\n    inputRank + 1,\n  );\n  return { box, transform };\n}\n\nexport interface CoordinateSpaceTransform {\n  /**\n   * Equal to `outputSpace.rank`.\n   */\n  readonly rank: number;\n\n  /**\n   * The source rank, which is <= rank.  Input dimensions >= sourceRank are synthetic and serve only\n   * to embed the source data in a larger view space.\n   */\n  readonly sourceRank: number;\n\n  /**\n   * May have rank less than `outputSpace.rank`, in which case additional unnamed dimensions with\n   * range `[0, 1)` are implicitly added.\n   */\n  readonly inputSpace: CoordinateSpace;\n\n  readonly outputSpace: CoordinateSpace;\n\n  /**\n   * `(rank + 1) * (rank + 1)` homogeneous column-major transformation matrix, where columns\n   * correspond to input dimensions and rows correspond to output dimensions.\n   */\n  readonly transform: Float64Array;\n}\n\nexport function coordinateSpaceTransformsEquivalent(\n  defaultTransform: CoordinateSpaceTransform,\n  transform: CoordinateSpaceTransform,\n) {\n  const { rank, sourceRank } = defaultTransform;\n  if (rank !== transform.rank || sourceRank !== transform.sourceRank)\n    return false;\n  const { inputSpace: defaultInputSpace } = defaultTransform;\n  const { inputSpace } = transform;\n  if (\n    !arraysEqual(inputSpace.scales, defaultInputSpace.scales) ||\n    !arraysEqual(inputSpace.units, defaultInputSpace.units) ||\n    !arraysEqual(\n      transform.outputSpace.names,\n      defaultTransform.outputSpace.names,\n    )\n  ) {\n    return false;\n  }\n  return isTransformDerivableFromDefault(\n    defaultTransform.transform,\n    rank,\n    defaultTransform.outputSpace.scales,\n    transform.transform,\n    rank,\n    transform.outputSpace.scales,\n  );\n}\n\nexport function makeIdentityTransform(\n  inputSpace: CoordinateSpace,\n): CoordinateSpaceTransform {\n  return {\n    rank: inputSpace.rank,\n    sourceRank: inputSpace.rank,\n    inputSpace,\n    outputSpace: inputSpace,\n    transform: matrix.createIdentity(Float64Array, inputSpace.rank + 1),\n  };\n}\n\nfunction transformBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  transform: Float64Array,\n  sourceScales: Float64Array,\n  targetScales: Float64Array,\n): TransformedBoundingBox {\n  const { transform: oldBoxTransform, box } = boundingBox;\n  const inputRank = boundingBox.box.lowerBounds.length;\n  const targetRank = targetScales.length;\n  // transform is a column-major homogeneous `(rows=targetRank+1, cols=targetRank+1)` matrix.\n  // oldBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.\n  // newBoxTransform is a column-major `(rows=targetRank, cols=inputRank+1)` matrix.\n  const newBoxTransform = new Float64Array((inputRank + 1) * targetRank);\n  for (let targetDim = 0; targetDim < targetRank; ++targetDim) {\n    const targetScale = targetScales[targetDim];\n    // Compute the rotation/scaling components\n    for (let inputDim = 0; inputDim < inputRank; ++inputDim) {\n      let sum = 0;\n      for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {\n        const sourceScale = sourceScales[sourceDim];\n        sum +=\n          transform[(targetRank + 1) * sourceDim + targetDim] *\n          oldBoxTransform[targetRank * inputDim + sourceDim] *\n          (sourceScale / targetScale);\n      }\n      newBoxTransform[targetRank * inputDim + targetDim] = sum;\n    }\n    // Compute the translation component\n    let sum = transform[(targetRank + 1) * targetRank + targetDim];\n    for (let sourceDim = 0; sourceDim < targetRank; ++sourceDim) {\n      const sourceScale = sourceScales[sourceDim];\n      sum +=\n        transform[(targetRank + 1) * sourceDim + targetDim] *\n        oldBoxTransform[targetRank * inputRank + sourceDim] *\n        (sourceScale / targetScale);\n    }\n    newBoxTransform[inputRank * targetRank + targetDim] = sum;\n  }\n  return {\n    transform: newBoxTransform,\n    box,\n  };\n}\n\nfunction getTransformedBoundingBoxes(\n  inputSpace: CoordinateSpace,\n  transform: Float64Array,\n  outputScales: Float64Array,\n) {\n  return inputSpace.boundingBoxes.map((boundingBox) =>\n    transformBoundingBox(\n      boundingBox,\n      transform,\n      inputSpace.scales,\n      outputScales,\n    ),\n  );\n}\n\nexport function getOutputSpaceWithTransformedBoundingBoxes(\n  inputSpace: CoordinateSpace,\n  transform: Float64Array,\n  oldOutputSpace: CoordinateSpace,\n) {\n  const newSpace = makeCoordinateSpace({\n    valid: inputSpace.valid,\n    rank: oldOutputSpace.rank,\n    ids: oldOutputSpace.ids,\n    names: oldOutputSpace.names,\n    timestamps: oldOutputSpace.timestamps,\n    scales: oldOutputSpace.scales,\n    units: oldOutputSpace.units,\n    boundingBoxes: getTransformedBoundingBoxes(\n      inputSpace,\n      transform,\n      oldOutputSpace.scales,\n    ),\n    coordinateArrays: oldOutputSpace.coordinateArrays,\n  });\n  if (coordinateSpacesEqual(newSpace, oldOutputSpace)) return oldOutputSpace;\n  return newSpace;\n}\n\nexport function isValidDimensionName(\n  name: string,\n  allowNumericalNames = false,\n) {\n  if (allowNumericalNames) {\n    const n = Number(name);\n    if (Number.isInteger(n) && n >= 0) return true;\n  }\n  return name.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;\n}\n\nexport function validateDimensionNames(\n  names: string[],\n  allowNumericalNames = false,\n) {\n  const seenNames = new Set<string>();\n  for (const name of names) {\n    if (!isValidDimensionName(name, allowNumericalNames)) return false;\n    if (seenNames.has(name)) return false;\n    seenNames.add(name);\n  }\n  return true;\n}\n\nexport function getDimensionNameValidity(names: readonly string[]): boolean[] {\n  const rank = names.length;\n  const isValid = new Array<boolean>(rank);\n  isValid.fill(true);\n  for (let i = 0; i < rank; ++i) {\n    const name = names[i];\n    if (!isValidDimensionName(name)) {\n      isValid[i] = false;\n      continue;\n    }\n    const otherIndex = names.indexOf(name, i + 1);\n    if (otherIndex !== -1) {\n      isValid[i] = false;\n      isValid[otherIndex] = false;\n    }\n  }\n  return isValid;\n}\n\nexport function isLocalDimension(name: string) {\n  return name.endsWith(\"'\");\n}\n\nexport function isLocalOrChannelDimension(name: string) {\n  return name.endsWith(\"'\") || name.endsWith(\"^\");\n}\n\nexport function isChannelDimension(name: string) {\n  return name.endsWith(\"^\");\n}\n\nexport function isGlobalDimension(name: string) {\n  return !isLocalOrChannelDimension(name);\n}\n\nexport function convertTransformOutputScales(\n  existingTransform: Float64Array,\n  existingOutputScales: Float64Array,\n  newOutputScales: Float64Array,\n) {\n  const newTransform = new Float64Array(existingTransform);\n  const rank = existingOutputScales.length;\n  const baseIndex = (rank + 1) * rank;\n  for (let i = 0; i < rank; ++i) {\n    newTransform[baseIndex + i] *= existingOutputScales[i] / newOutputScales[i];\n  }\n  return newTransform;\n}\n\nfunction isTransformDerivableFromDefault(\n  defaultTransform: Float64Array,\n  defaultRank: number,\n  defaultOutputScales: Float64Array,\n  newTransform: Float64Array,\n  newRank: number,\n  newOutputScales: Float64Array,\n) {\n  // Verify that matched linear portion is equal.\n  if (\n    !matrix.equal(\n      defaultTransform,\n      defaultRank + 1,\n      newTransform,\n      newRank + 1,\n      defaultRank,\n      defaultRank,\n    )\n  )\n    return false;\n\n  // Verify that common translation is equivalent.\n  for (let i = 0; i < defaultRank; ++i) {\n    const aValue = defaultTransform[(defaultRank + 1) * defaultRank + i];\n    const bValue = newTransform[(newRank + 1) * newRank + i];\n    if (aValue * (defaultOutputScales[i] / newOutputScales[i]) !== bValue)\n      return false;\n  }\n\n  // Verify that extended translation is 0.\n  for (let i = defaultRank; i < newRank; ++i) {\n    if (newTransform[(newRank + 1) * newRank + i] !== 0) return false;\n  }\n\n  // Verify that extended linear portion is identity.\n  for (let i = defaultRank; i < newRank; ++i) {\n    for (let j = 0; j < defaultRank; ++j) {\n      if (newTransform[(newRank + 1) * j + i] !== 0) return false;\n    }\n    for (let j = 0; j < newRank; ++j) {\n      const coeff = newTransform[(newRank + 1) * i + j];\n      if (i === j) {\n        if (coeff !== 1) return false;\n      } else {\n        if (coeff !== 0) return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport function makeDimensionNameUnique(\n  name: string,\n  existingNames: readonly string[],\n) {\n  if (!existingNames.includes(name)) return name;\n  const [, prefix, suffix] = name.match(/^([^']*)('?)$/)!;\n  for (let i = 0; ; ++i) {\n    const newName = `${prefix}${i}${suffix}`;\n    if (!existingNames.includes(newName)) return newName;\n  }\n}\n\nexport function remapTransformInputSpace(\n  old: CoordinateSpaceTransform,\n  inputSpace: CoordinateSpace,\n): CoordinateSpaceTransform {\n  const { inputSpace: oldInputSpace, transform: oldTransform } = old;\n  const { ids: oldInputDimensionIds, rank: oldRank } = oldInputSpace;\n  const {\n    rank: newRank,\n    names: newInputDimensionNames,\n    units: newInputUnits,\n    scales: newInputScales,\n  } = inputSpace;\n  const removedOldInputIndices = new Array(oldRank);\n  removedOldInputIndices.fill(true);\n  const addedInputDimensionIndices: number[] = [];\n  const newToOldInputDimensionIndices: number[] = inputSpace.ids.map(\n    (id, i) => {\n      const oldIndex = oldInputDimensionIds.indexOf(id);\n      if (oldIndex !== -1) {\n        removedOldInputIndices[oldIndex] = false;\n      } else {\n        addedInputDimensionIndices.push(i);\n      }\n      return oldIndex;\n    },\n  );\n  const { outputSpace: oldOutputSpace } = old;\n  const {\n    names: oldOutputDimensionNames,\n    units: oldOutputUnits,\n    scales: oldOutputScales,\n    ids: oldOutputDimensionIds,\n    timestamps: oldOutputTimestamps,\n    coordinateArrays: oldOutputCoordinateArrays,\n  } = oldOutputSpace;\n  // For now just use a simple mapping.\n  const removedOldOutputIndices = removedOldInputIndices;\n  const outputDimensionNames: string[] = [];\n  const outputUnits: string[] = [];\n  const outputScales = new Float64Array(newRank);\n  const outputDimensionIds: DimensionId[] = [];\n  const outputDimensionTimestamps: number[] = [];\n  const outputCoordinateArrays = new Array<CoordinateArray | undefined>(\n    newRank,\n  );\n  let newOutputDim = 0;\n  const newTransform = new Float64Array((newRank + 1) ** 2);\n  newTransform[newTransform.length - 1] = 1;\n  for (let oldOutputDim = 0; oldOutputDim < oldRank; ++oldOutputDim) {\n    if (removedOldOutputIndices[oldOutputDim]) continue;\n    outputDimensionNames[newOutputDim] = oldOutputDimensionNames[oldOutputDim];\n    outputDimensionIds[newOutputDim] = oldOutputDimensionIds[oldOutputDim];\n    outputUnits[newOutputDim] = oldOutputUnits[oldOutputDim];\n    outputScales[newOutputDim] = oldOutputScales[oldOutputDim];\n    outputDimensionTimestamps[newOutputDim] = oldOutputTimestamps[oldOutputDim];\n    outputCoordinateArrays[newOutputDim] =\n      oldOutputCoordinateArrays[oldOutputDim];\n    for (let newInputDim = 0; newInputDim < newRank; ++newInputDim) {\n      const oldInputDim = newToOldInputDimensionIndices[newInputDim];\n      if (oldInputDim === -1) continue;\n      newTransform[newInputDim * (newRank + 1) + newOutputDim] =\n        oldTransform[oldInputDim * (oldRank + 1) + oldOutputDim];\n    }\n    newTransform[newRank * (newRank + 1) + newOutputDim] =\n      oldTransform[oldRank * (oldRank + 1) + oldOutputDim];\n    ++newOutputDim;\n  }\n  for (const newInputDim of addedInputDimensionIndices) {\n    outputDimensionIds[newOutputDim] = newDimensionId();\n    outputDimensionNames[newOutputDim] = makeDimensionNameUnique(\n      newInputDimensionNames[newInputDim],\n      outputDimensionNames,\n    );\n    outputScales[newOutputDim] = newInputScales[newInputDim];\n    outputUnits[newOutputDim] = newInputUnits[newInputDim];\n    newTransform[newInputDim * (newRank + 1) + newOutputDim] = 1;\n    ++newOutputDim;\n  }\n  const outputSpace = makeCoordinateSpace({\n    valid: inputSpace.valid,\n    rank: newRank,\n    names: outputDimensionNames,\n    ids: outputDimensionIds,\n    timestamps: outputDimensionTimestamps,\n    units: outputUnits,\n    scales: outputScales,\n    boundingBoxes: getTransformedBoundingBoxes(\n      inputSpace,\n      newTransform,\n      outputScales,\n    ),\n    coordinateArrays: outputCoordinateArrays,\n  });\n  return {\n    rank: newRank,\n    sourceRank: old.sourceRank,\n    inputSpace,\n    outputSpace,\n    transform: newTransform,\n  };\n}\n\nfunction normalizeCoordinateSpaceTransform(value: CoordinateSpaceTransform) {\n  const outputSpace = getOutputSpaceWithTransformedBoundingBoxes(\n    value.inputSpace,\n    value.transform,\n    value.outputSpace,\n  );\n  if (outputSpace === value.outputSpace) return value;\n  return {\n    rank: value.rank,\n    sourceRank: value.sourceRank,\n    inputSpace: value.inputSpace,\n    transform: value.transform,\n    outputSpace,\n  };\n}\n\nexport class WatchableCoordinateSpaceTransform\n  implements Trackable, WatchableValueInterface<CoordinateSpaceTransform>\n{\n  private value_: CoordinateSpaceTransform | undefined = undefined;\n  readonly outputSpace: WatchableValueInterface<CoordinateSpace>;\n  readonly inputSpace: WatchableValueInterface<CoordinateSpace>;\n  changed = new NullarySignal();\n  private inputSpaceChanged = new NullarySignal();\n  readonly defaultTransform: CoordinateSpaceTransform;\n\n  constructor(\n    defaultTransform: CoordinateSpaceTransform,\n    public readonly mutableSourceRank: boolean = false,\n  ) {\n    this.defaultTransform = normalizeCoordinateSpaceTransform(defaultTransform);\n    const self = this;\n    this.outputSpace = {\n      changed: self.changed,\n      get value() {\n        return self.value.outputSpace;\n      },\n      set value(newOutputSpace: CoordinateSpace) {\n        const { value } = self;\n        if (coordinateSpacesEqual(value.outputSpace, newOutputSpace)) return;\n        if (value.rank !== newOutputSpace.rank) return;\n        const transform = convertTransformOutputScales(\n          value.transform,\n          value.outputSpace.scales,\n          newOutputSpace.scales,\n        );\n        self.value_ = {\n          sourceRank: value.sourceRank,\n          rank: value.rank,\n          inputSpace: value.inputSpace,\n          outputSpace: getOutputSpaceWithTransformedBoundingBoxes(\n            value.inputSpace,\n            transform,\n            newOutputSpace,\n          ),\n          transform,\n        };\n        self.changed.dispatch();\n      },\n    };\n    this.inputSpace = {\n      changed: self.inputSpaceChanged,\n      get value() {\n        return self.value.inputSpace;\n      },\n      set value(newInputSpace: CoordinateSpace) {\n        const { value } = self;\n        if (coordinateSpacesEqual(value.inputSpace, newInputSpace)) return;\n        self.value_ = remapTransformInputSpace(value, newInputSpace);\n        self.inputSpaceChanged.dispatch();\n        self.changed.dispatch();\n      },\n    };\n  }\n\n  set value(value: CoordinateSpaceTransform) {\n    const existingValue = this.value;\n    if (value === existingValue) return;\n    this.value_ = normalizeCoordinateSpaceTransform(value);\n    if (value.inputSpace !== existingValue.inputSpace) {\n      this.inputSpaceChanged.dispatch();\n    }\n    this.changed.dispatch();\n  }\n\n  get value(): CoordinateSpaceTransform {\n    let { value_: value } = this;\n    if (value === undefined) {\n      value = this.value_ = this.defaultTransform;\n    }\n    return value;\n  }\n\n  reset() {\n    if (this.value_ === this.defaultTransform) return;\n    this.value_ = this.defaultTransform;\n    this.inputSpaceChanged.dispatch();\n    this.changed.dispatch();\n  }\n\n  get defaultInputSpace() {\n    return this.defaultTransform.inputSpace;\n  }\n\n  get spec(): Readonly<CoordinateTransformSpecification> | undefined {\n    const { value } = this;\n    const { rank, transform, inputSpace, outputSpace, sourceRank } = value;\n    const { defaultTransform, mutableSourceRank } = this;\n    const {\n      inputSpace: defaultInputSpace,\n      rank: defaultRank,\n      transform: defaultTransformMatrix,\n      outputSpace: defaultOutputSpace,\n    } = defaultTransform;\n    const { units, scales } = inputSpace;\n    const inputSpaceSame =\n      sourceRank === rank &&\n      arraysEqual(\n        scales,\n        mutableSourceRank ? outputSpace.scales : defaultInputSpace.scales,\n      ) &&\n      arraysEqual(\n        units,\n        mutableSourceRank ? outputSpace.units : defaultInputSpace.units,\n      );\n    const transformSame = isTransformDerivableFromDefault(\n      defaultTransformMatrix,\n      defaultRank,\n      defaultOutputSpace.scales,\n      transform,\n      rank,\n      outputSpace.scales,\n    );\n    const outputNamesSame = arraysEqual(\n      defaultOutputSpace.names,\n      outputSpace.names,\n    );\n    if (transformSame && outputNamesSame && inputSpaceSame) {\n      return undefined;\n    }\n    return {\n      sourceRank,\n      transform: transformSame ? undefined : transform,\n      outputSpace: value.outputSpace,\n      inputSpace: inputSpaceSame ? undefined : inputSpace,\n    };\n  }\n\n  set transform(transform: Float64Array) {\n    const { value } = this;\n    const { inputSpace } = value;\n    this.value_ = {\n      rank: value.rank,\n      sourceRank: value.sourceRank,\n      inputSpace,\n      transform,\n      outputSpace: getOutputSpaceWithTransformedBoundingBoxes(\n        inputSpace,\n        transform,\n        value.outputSpace,\n      ),\n    };\n    this.changed.dispatch();\n  }\n\n  set spec(spec: Readonly<CoordinateTransformSpecification> | undefined) {\n    if (spec === undefined) {\n      this.reset();\n      return;\n    }\n    if (this.mutableSourceRank) {\n      const origInputSpace = spec.inputSpace || spec.outputSpace;\n      const rank = origInputSpace.rank;\n      const inputSpace = makeCoordinateSpace({\n        rank,\n        names: origInputSpace.names.map((_, i) => `${i}`),\n        units: origInputSpace.units,\n        scales: origInputSpace.scales,\n        coordinateArrays: origInputSpace.coordinateArrays,\n      });\n      this.value = {\n        rank,\n        transform:\n          spec.transform || matrix.createIdentity(Float64Array, rank + 1),\n        sourceRank: spec.sourceRank,\n        outputSpace: spec.outputSpace,\n        inputSpace,\n      };\n      return;\n    }\n    const {\n      inputSpace: defaultInputSpace,\n      sourceRank: defaultSourceRank,\n      outputSpace: defaultOutputSpace,\n      transform: defaultTransformMatrix,\n      rank: defaultRank,\n    } = this.defaultTransform;\n    const {\n      inputSpace: specInputSpace,\n      sourceRank: specSourceRank,\n      outputSpace: specOutputSpace,\n      transform: specTransformMatrix,\n    } = spec;\n    const specRank = spec.outputSpace.rank;\n    const defaultInputNames = defaultInputSpace.names;\n    const specInputNames =\n      specInputSpace !== undefined ? specInputSpace.names : defaultInputNames;\n    const newToSpecDimensionIndices = new Array<number>(defaultSourceRank);\n    for (let defaultDim = 0; defaultDim < defaultSourceRank; ++defaultDim) {\n      let specDim = specInputNames.indexOf(defaultInputNames[defaultDim]);\n      if (specDim >= specSourceRank) specDim = -1;\n      newToSpecDimensionIndices[defaultDim] = specDim;\n    }\n    const newRank = specRank - specSourceRank + defaultSourceRank;\n    for (let i = specSourceRank; i < specRank; ++i) {\n      newToSpecDimensionIndices[defaultSourceRank + i - specSourceRank] = i;\n    }\n    const newInputScales = new Float64Array(newRank);\n    const newInputCoordinateArrays = new Array<CoordinateArray | undefined>(\n      newRank,\n    );\n    const newInputUnits: string[] = [];\n    for (let newDim = 0; newDim < defaultSourceRank; ++newDim) {\n      const specDim = newToSpecDimensionIndices[newDim];\n      if (specDim === -1 || specInputSpace === undefined) {\n        newInputScales[newDim] = defaultInputSpace.scales[newDim];\n        newInputUnits[newDim] = defaultInputSpace.units[newDim];\n        newInputCoordinateArrays[newDim] =\n          defaultInputSpace.coordinateArrays[newDim];\n      } else {\n        newInputScales[newDim] = specInputSpace.scales[specDim];\n        newInputUnits[newDim] = specInputSpace.units[specDim];\n        newInputCoordinateArrays[newDim] = mergeOptionalCoordinateArrays([\n          defaultInputSpace.coordinateArrays[newDim],\n          specInputSpace.coordinateArrays[specDim],\n        ]);\n      }\n    }\n    const specInputOrOutputSpace = specInputSpace || specOutputSpace;\n    const newInputNames = defaultInputNames.slice(0, defaultSourceRank);\n    const newOutputNames = defaultOutputSpace.names.slice(0, defaultSourceRank);\n    const newOutputCoordinateArrays = defaultOutputSpace.coordinateArrays.slice(\n      0,\n      defaultSourceRank,\n    );\n    const newOutputScales = new Float64Array(newRank);\n    const newOutputUnits: string[] = [];\n    for (let newDim = 0; newDim < newRank; ++newDim) {\n      const specDim = newToSpecDimensionIndices[newDim];\n      if (specDim === -1) {\n        newOutputScales[newDim] = defaultOutputSpace.scales[newDim];\n        newOutputUnits[newDim] = defaultOutputSpace.units[newDim];\n        newOutputCoordinateArrays[newDim] =\n          defaultOutputSpace.coordinateArrays[newDim];\n      } else {\n        newOutputNames[newDim] = specOutputSpace.names[specDim];\n        newOutputUnits[newDim] = specOutputSpace.units[specDim];\n        newOutputScales[newDim] = specOutputSpace.scales[specDim];\n        newOutputCoordinateArrays[newDim] =\n          specOutputSpace.coordinateArrays[specDim];\n      }\n    }\n    if (!validateDimensionNames(newOutputNames)) {\n      // Spec is incompatible, ignore it.\n      this.reset();\n      return;\n    }\n    // Handle singleton dimensions.\n    for (let newDim = defaultSourceRank; newDim < newRank; ++newDim) {\n      const specDim = newDim - defaultSourceRank + specSourceRank;\n      newInputScales[newDim] = specInputOrOutputSpace.scales[specDim];\n      newInputUnits[newDim] = specInputOrOutputSpace.units[specDim];\n      newInputNames[newDim] = `${newDim}`;\n    }\n\n    const newTransform = new Float64Array((newRank + 1) ** 2);\n    newTransform[newTransform.length - 1] = 1;\n    for (let newRow = 0; newRow < newRank; ++newRow) {\n      const specRow = newToSpecDimensionIndices[newRow];\n      let value: number;\n      if (specRow === -1 || specTransformMatrix === undefined) {\n        if (newRow >= defaultSourceRank) {\n          value = 0;\n        } else {\n          value =\n            defaultTransformMatrix[defaultRank * (defaultRank + 1) + newRow] *\n            (defaultOutputSpace.scales[newRow] / newOutputScales[newRow]);\n        }\n      } else {\n        value = specTransformMatrix[specRank * (specRank + 1) + specRow];\n      }\n      newTransform[newRank * (newRank + 1) + newRow] = value;\n      for (let newCol = 0; newCol < newRank; ++newCol) {\n        const specCol = newToSpecDimensionIndices[newCol];\n        let value: number;\n        if ((specRow === -1) !== (specCol === -1)) {\n          value = 0;\n        } else if (specRow === -1 || specTransformMatrix === undefined) {\n          if (specRow >= defaultSourceRank || specCol >= defaultSourceRank) {\n            value = specRow === specCol ? 1 : 0;\n          } else {\n            value = defaultTransformMatrix[newCol * (defaultRank + 1) + newRow];\n          }\n        } else {\n          value = specTransformMatrix[specCol * (specRank + 1) + specRow];\n        }\n        newTransform[newCol * (newRank + 1) + newRow] = value;\n      }\n    }\n    const boundingBoxes = defaultInputSpace.boundingBoxes.map((boundingBox) =>\n      extendTransformedBoundingBoxUpToRank(boundingBox, defaultRank, newRank),\n    );\n    for (let i = defaultSourceRank; i < newRank; ++i) {\n      boundingBoxes.push(makeSingletonDimTransformedBoundingBox(newRank, i));\n    }\n    // Propagate coordinate arrays from input dimensions to output dimensions.\n    for (let outputDim = 0; outputDim < newRank; ++outputDim) {\n      // Check if this output dimension is identity mapped from a single input dimension.\n      const translation = newTransform[newRank * (newRank + 1) + outputDim];\n      if (translation !== 0) continue;\n      let singleInputDim: number | undefined | null = undefined;\n      for (let inputDim = 0; inputDim < newRank; ++inputDim) {\n        const factor = newTransform[inputDim * (newRank + 1) + outputDim];\n        if (factor === 0) continue;\n        if (factor === 1) {\n          if (singleInputDim === undefined) {\n            // First input dimension that maps to this output dimension.\n            singleInputDim = inputDim;\n          } else {\n            // Multiple input dimensions map to this output dimension.\n            singleInputDim = null;\n            break;\n          }\n        } else {\n          // Non-identity mapping.\n          singleInputDim = null;\n          break;\n        }\n      }\n      if (singleInputDim == null) continue;\n      let coordinateArray = newInputCoordinateArrays[singleInputDim];\n      if (coordinateArray === undefined) continue;\n      if (coordinateArray.explicit) {\n        coordinateArray = { ...coordinateArray, explicit: false };\n      }\n      newOutputCoordinateArrays[outputDim] = mergeOptionalCoordinateArrays([\n        coordinateArray,\n        newOutputCoordinateArrays[outputDim],\n      ]);\n    }\n    this.value = {\n      rank: newRank,\n      transform: newTransform,\n      sourceRank: defaultSourceRank,\n      outputSpace: makeCoordinateSpace({\n        rank: newRank,\n        names: newOutputNames,\n        scales: newOutputScales,\n        units: newOutputUnits,\n        coordinateArrays: newOutputCoordinateArrays,\n      }),\n      inputSpace: makeCoordinateSpace({\n        rank: newRank,\n        names: newInputNames,\n        scales: newInputScales,\n        units: newInputUnits,\n        coordinateArrays: newInputCoordinateArrays,\n        boundingBoxes,\n      }),\n    };\n  }\n\n  toJSON() {\n    return coordinateTransformSpecificationToJson(this.spec);\n  }\n\n  restoreState(obj: unknown) {\n    this.spec = coordinateTransformSpecificationFromJson(obj);\n  }\n}\n\nexport function expectDimensionName(\n  obj: unknown,\n  allowNumericalNames = false,\n): string {\n  const name = verifyString(obj);\n  if (!isValidDimensionName(name, allowNumericalNames)) {\n    throw new Error(`Invalid dimension name: ${JSON.stringify(name)}`);\n  }\n  return name;\n}\n\nexport function dimensionNamesFromJson(obj: any, allowNumericalNames = false) {\n  const dimensions = parseArray(obj, (x) =>\n    expectDimensionName(x, allowNumericalNames),\n  );\n  if (!validateDimensionNames(dimensions, allowNumericalNames)) {\n    throw new Error(`Invalid dimensions: ${JSON.stringify(dimensions)}`);\n  }\n  return dimensions;\n}\n\ninterface BoundCoordinateSpace {\n  space: WatchableValueInterface<CoordinateSpace>;\n  prevValue: CoordinateSpace | undefined;\n  mappedDimensionIds: (DimensionId | undefined)[];\n}\n\nexport class CoordinateSpaceCombiner {\n  private bindings = new Set<BoundCoordinateSpace>();\n\n  private retainCount = 0;\n\n  private prevCombined: CoordinateSpace | undefined;\n\n  dimensionRefCounts = new Map<string, number>();\n\n  getRenameValidity(newNames: readonly string[]): boolean[] {\n    const existingNames = this.combined.value.names;\n    const validity = getDimensionNameValidity(newNames);\n    const rank = newNames.length;\n    for (let i = 0; i < rank; ++i) {\n      if (!validity[i]) continue;\n      const newName = newNames[i];\n      if (existingNames.includes(newName)) continue;\n      let valid = true;\n      for (const binding of this.bindings) {\n        const otherNames = binding.space.value.names;\n        if (otherNames.includes(newName)) {\n          valid = false;\n          break;\n        }\n      }\n      validity[i] = valid;\n    }\n    return validity;\n  }\n\n  private includeDimensionPredicate_: (name: string) => boolean;\n\n  get includeDimensionPredicate() {\n    return this.includeDimensionPredicate_;\n  }\n  set includeDimensionPredicate(value: (name: string) => boolean) {\n    this.includeDimensionPredicate_ = value;\n    this.update();\n  }\n\n  constructor(\n    public combined: WatchableValueInterface<CoordinateSpace>,\n    includeDimensionPredicate: (name: string) => boolean,\n  ) {\n    this.includeDimensionPredicate_ = includeDimensionPredicate;\n    this.prevCombined = this.combined.value;\n  }\n\n  private update() {\n    const { combined, bindings } = this;\n    const retainExisting = this.retainCount > 0 ? 1 : 0;\n    if (bindings.size === 0 && !retainExisting) {\n      combined.value = emptyInvalidCoordinateSpace;\n      return;\n    }\n    const include = this.includeDimensionPredicate_;\n    const existing = combined.value;\n    let mergedNames = Array.from(existing.names);\n    let mergedUnits = Array.from(existing.units);\n    let mergedScales = Array.from(existing.scales);\n    let mergedIds = Array.from(existing.ids);\n    let mergedTimestamps = Array.from(existing.timestamps);\n    let dimensionRefs: number[] = existing.names.map(() =>\n      retainExisting ? 1 : 0,\n    );\n    const bindingCombinedIndices: (number | undefined)[][] = [];\n    let valid = false;\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n        prevValue,\n        mappedDimensionIds,\n      } = binding;\n      valid = valid || space.valid;\n      const { names, units, scales, ids, timestamps } = space;\n      const newMappedDimensionIds: (DimensionId | undefined)[] = [];\n      const combinedIndices: (number | undefined)[] = [];\n      bindingCombinedIndices.push(combinedIndices);\n      binding.mappedDimensionIds = newMappedDimensionIds;\n      binding.prevValue = space;\n      const rank = names.length;\n      for (let i = 0; i < rank; ++i) {\n        const name = names[i];\n        if (!include(name)) continue;\n        if (prevValue !== undefined) {\n          const id = ids[i];\n          const prevIndex = prevValue.ids.indexOf(id);\n          if (prevIndex !== -1) {\n            const combinedId = mappedDimensionIds[prevIndex];\n            if (combinedId !== undefined) {\n              const combinedIndex = mergedIds.indexOf(combinedId);\n              if (combinedIndex !== -1) {\n                newMappedDimensionIds[i] = combinedId;\n                ++dimensionRefs[combinedIndex];\n                combinedIndices[i] = combinedIndex;\n                const timestamp = timestamps[i];\n                if (\n                  timestamp !== undefined &&\n                  !(timestamp <= mergedTimestamps[combinedIndex])\n                ) {\n                  mergedNames[combinedIndex] = name;\n                  mergedScales[combinedIndex] = scales[i];\n                  mergedUnits[combinedIndex] = units[i];\n                  mergedTimestamps[combinedIndex] = timestamp;\n                }\n                continue;\n              }\n            }\n          }\n        }\n        let combinedIndex = mergedNames.indexOf(name);\n        if (combinedIndex !== -1) {\n          newMappedDimensionIds[i] = mergedIds[combinedIndex];\n          ++dimensionRefs[combinedIndex];\n          combinedIndices[i] = combinedIndex;\n          continue;\n        }\n        combinedIndex = mergedNames.length;\n        combinedIndices[i] = combinedIndex;\n        dimensionRefs[combinedIndex] = 1 + retainExisting;\n        mergedNames[combinedIndex] = name;\n        mergedUnits[combinedIndex] = units[i];\n        mergedScales[combinedIndex] = scales[i];\n        mergedTimestamps[combinedIndex] = timestamps[i];\n        const combinedId = newDimensionId();\n        mergedIds[combinedIndex] = combinedId;\n        newMappedDimensionIds[i] = combinedId;\n      }\n    }\n    // Propagate names, units, and scales back\n    const { dimensionRefCounts } = this;\n    dimensionRefCounts.clear();\n    let bindingIndex = 0;\n    let newRank = mergedNames.length;\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n      } = binding;\n      const combinedIndices = bindingCombinedIndices[bindingIndex++];\n      const { rank } = space;\n      const names = Array.from(space.names);\n      const timestamps = Array.from(space.timestamps);\n      const scales = Float64Array.from(space.scales);\n      const units = Array.from(space.units);\n      for (let i = 0; i < rank; ++i) {\n        const combinedIndex = combinedIndices[i];\n        if (combinedIndex === undefined) continue;\n        units[i] = mergedUnits[combinedIndex];\n        scales[i] = mergedScales[combinedIndex];\n        timestamps[i] = mergedTimestamps[combinedIndex];\n        names[i] = mergedNames[combinedIndex];\n      }\n      for (const name of names) {\n        let count = dimensionRefCounts.get(name);\n        if (count === undefined) {\n          count = 1;\n        } else {\n          ++count;\n        }\n        dimensionRefCounts.set(name, count);\n      }\n      if (\n        !arraysEqual(units, space.units) ||\n        !arraysEqual(scales, space.scales) ||\n        !arraysEqual(names, space.names) ||\n        !arraysEqual(timestamps, space.timestamps)\n      ) {\n        const newSpace = makeCoordinateSpace({\n          valid: space.valid,\n          ids: space.ids,\n          scales,\n          units,\n          names,\n          timestamps,\n          boundingBoxes: space.boundingBoxes,\n          coordinateArrays: space.coordinateArrays,\n        });\n        binding.prevValue = newSpace;\n        binding.space.value = newSpace;\n      }\n    }\n\n    {\n      for (let i = 0; i < newRank; ++i) {\n        if (!include(mergedNames[i])) {\n          dimensionRefs[i] = 0;\n        }\n      }\n      const hasRefs = (_: any, i: number) => dimensionRefs[i] !== 0;\n      mergedNames = mergedNames.filter(hasRefs);\n      mergedUnits = mergedUnits.filter(hasRefs);\n      mergedScales = mergedScales.filter(hasRefs);\n      mergedIds = mergedIds.filter(hasRefs);\n      mergedTimestamps = mergedTimestamps.filter(hasRefs);\n      dimensionRefs = dimensionRefs.filter(hasRefs);\n      newRank = mergedNames.length;\n    }\n\n    const mergedBoundingBoxes: TransformedBoundingBox[] = [];\n    const allCoordinateArrays = new Array<CoordinateArray[] | undefined>(\n      newRank,\n    );\n    // Include any explicit coordinate arrays from `existing`.\n    for (let i = 0, existingRank = existing.rank; i < existingRank; ++i) {\n      const coordinateArray = existing.coordinateArrays[i];\n      if (!coordinateArray?.explicit) continue;\n      const newDim = mergedIds.indexOf(existing.ids[i]);\n      if (newDim === -1) continue;\n      allCoordinateArrays[newDim] = [coordinateArray];\n    }\n    for (const binding of bindings) {\n      const {\n        space: { value: space },\n      } = binding;\n      const { rank, boundingBoxes, coordinateArrays } = space;\n      const newDims = space.names.map((x) => mergedNames.indexOf(x));\n      for (const oldBoundingBox of boundingBoxes) {\n        mergedBoundingBoxes.push(\n          extendTransformedBoundingBox(oldBoundingBox, newRank, newDims),\n        );\n      }\n      for (let i = 0; i < rank; ++i) {\n        const coordinateArray = coordinateArrays[i];\n        if (coordinateArray === undefined) continue;\n        const newDim = newDims[i];\n        const mergedList = allCoordinateArrays[newDim];\n        if (mergedList === undefined) {\n          allCoordinateArrays[newDim] = [coordinateArray];\n        } else {\n          mergedList.push(coordinateArray);\n        }\n      }\n    }\n    const mergedCoordinateArrays = new Array<CoordinateArray | undefined>(\n      newRank,\n    );\n    for (let i = 0; i < newRank; ++i) {\n      const mergedList = allCoordinateArrays[i];\n      if (mergedList === undefined) continue;\n      mergedCoordinateArrays[i] = mergeCoordinateArrays(mergedList);\n    }\n    const newCombined = makeCoordinateSpace({\n      valid,\n      ids: mergedIds,\n      names: mergedNames,\n      units: mergedUnits,\n      scales: new Float64Array(mergedScales),\n      boundingBoxes: mergedBoundingBoxes,\n      coordinateArrays: mergedCoordinateArrays,\n    });\n    if (retainExisting) {\n      for (let i = 0; i < newRank; ++i) {\n        --dimensionRefs[i];\n      }\n    }\n    if (!coordinateSpacesEqual(existing, newCombined)) {\n      this.prevCombined = newCombined;\n      combined.value = newCombined;\n    }\n  }\n\n  private handleCombinedChanged = () => {\n    if (this.combined.value === this.prevCombined) return;\n    this.update();\n  };\n\n  retain() {\n    ++this.retainCount;\n    return () => {\n      if (--this.retainCount === 0) {\n        this.update();\n      }\n    };\n  }\n\n  bind(space: WatchableValueInterface<CoordinateSpace>) {\n    const binding = { space, mappedDimensionIds: [], prevValue: undefined };\n    const { bindings } = this;\n    if (bindings.size === 0) {\n      this.combined.changed.add(this.handleCombinedChanged);\n    }\n    bindings.add(binding);\n\n    const changedDisposer = space.changed.add(() => {\n      if (space.value === binding.prevValue) return;\n      this.update();\n    });\n    const disposer = () => {\n      changedDisposer();\n      const { bindings } = this;\n      bindings.delete(binding);\n      if (bindings.size === 0) {\n        this.combined.changed.remove(this.handleCombinedChanged);\n      }\n      this.update();\n    };\n    this.update();\n    return disposer;\n  }\n}\n\nexport function homogeneousTransformSubmatrix<T extends TypedNumberArray>(\n  arrayConstructor: { new (n: number): T },\n  oldTransform: TypedNumberArray,\n  oldRank: number,\n  oldRows: readonly number[],\n  oldCols: readonly number[],\n): T {\n  const newRank = oldCols.length;\n  const newTransform = new arrayConstructor((newRank + 1) ** 2);\n  newTransform[newTransform.length - 1] = 1;\n  for (let newRow = 0; newRow < newRank; ++newRow) {\n    const oldRow = oldRows[newRow];\n    newTransform[(newRank + 1) * newRank + newRow] =\n      oldTransform[(oldRank + 1) * oldRank + oldRow];\n    for (let newCol = 0; newCol < newRank; ++newCol) {\n      const oldCol = oldCols[newCol];\n      newTransform[(newRank + 1) * newCol + newRow] =\n        oldTransform[(oldRank + 1) * oldCol + oldRow];\n    }\n  }\n  return newTransform;\n}\n\nexport interface CoordinateTransformSpecification {\n  sourceRank: number;\n  transform: Float64Array | undefined;\n  inputSpace: CoordinateSpace | undefined;\n  outputSpace: CoordinateSpace;\n}\n\nexport function coordinateTransformSpecificationFromLegacyJson(\n  obj: unknown,\n): CoordinateTransformSpecification | undefined {\n  if (obj === undefined) return undefined;\n  const transform = new Float64Array(16);\n  if (Array.isArray(obj)) {\n    if (obj.length === 16) {\n      for (let i = 0; i < 4; ++i) {\n        for (let j = 0; j < 4; ++j) {\n          transform[i * 4 + j] = verifyFiniteFloat(obj[j * 4 + i]);\n        }\n      }\n    } else {\n      expectArray(obj, 4);\n      for (let i = 0; i < 4; ++i) {\n        const row = expectArray(obj[i], 4);\n        for (let j = 0; j < 4; ++j) {\n          transform[j * 4 + i] = verifyFiniteFloat(row[j]);\n        }\n      }\n    }\n  } else {\n    verifyObject(obj);\n    const rotation = quat.create();\n    const translation = vec3.create();\n    const scale = vec3.fromValues(1, 1, 1);\n    verifyOptionalObjectProperty(obj, \"rotation\", (x) => {\n      parseFiniteVec(rotation, x);\n      quat.normalize(rotation, rotation);\n    });\n    verifyOptionalObjectProperty(obj, \"translation\", (x) => {\n      parseFiniteVec(translation, x);\n    });\n    verifyOptionalObjectProperty(obj, \"scale\", (x) => {\n      parseFiniteVec(scale, x);\n    });\n    const tempMat4 = mat4.create();\n    mat4.fromRotationTranslationScale(tempMat4, rotation, translation, scale);\n    transform.set(tempMat4);\n  }\n  return {\n    sourceRank: 3,\n    transform,\n    outputSpace: makeCoordinateSpace({\n      valid: true,\n      names: [\"x\", \"y\", \"z\"],\n      units: [\"m\", \"m\", \"m\"],\n      scales: Float64Array.of(1e-9, 1e-9, 1e-9),\n    }),\n    inputSpace: undefined,\n  };\n}\n\nexport function coordinateTransformSpecificationFromJson(\n  j: unknown,\n): CoordinateTransformSpecification | undefined {\n  if (j === undefined) return undefined;\n  const obj = verifyObject(j);\n  const outputSpace = verifyObjectProperty(\n    obj,\n    \"outputDimensions\",\n    coordinateSpaceFromJson,\n  );\n  const rank = outputSpace.rank;\n  const sourceRank = verifyObjectProperty(obj, \"sourceRank\", (rankObj) => {\n    if (rankObj === undefined) return rank;\n    if (!Number.isInteger(rankObj) || rankObj < 0 || rankObj > rank) {\n      throw new Error(\n        `Expected integer in range [0, ${rank}] but received: ${JSON.stringify(\n          rankObj,\n        )}`,\n      );\n    }\n    return rankObj as number;\n  });\n  const inputSpace = verifyOptionalObjectProperty(\n    obj,\n    \"inputDimensions\",\n    (inputSpaceObj) => {\n      const space = coordinateSpaceFromJson(inputSpaceObj, true);\n      if (space.rank !== rank) {\n        throw new Error(\n          `Expected rank of ${rank}, but received rank of: ${space.rank}`,\n        );\n      }\n      return space;\n    },\n  );\n  const transform = verifyOptionalObjectProperty(obj, \"matrix\", (x) => {\n    const transform = new Float64Array((rank + 1) ** 2);\n    const a = expectArray(x, rank);\n    transform[transform.length - 1] = 1;\n    for (let i = 0; i < rank; ++i) {\n      try {\n        const row = expectArray(a[i], rank + 1);\n        for (let j = 0; j <= rank; ++j) {\n          transform[(rank + 1) * j + i] = verifyFiniteFloat(row[j]);\n        }\n      } catch (e) {\n        throw new Error(`Error in row ${i}: ${e.message}`);\n      }\n    }\n    return transform;\n  });\n  return { transform, outputSpace, inputSpace, sourceRank };\n}\n\nexport function coordinateTransformSpecificationToJson(\n  spec: CoordinateTransformSpecification | undefined,\n) {\n  if (spec === undefined) return undefined;\n  const { transform, outputSpace, inputSpace, sourceRank } = spec;\n  let m: number[][] | undefined;\n  const rank = outputSpace.rank;\n  if (transform !== undefined) {\n    m = [];\n    for (let i = 0; i < rank; ++i) {\n      const row: number[] = [];\n      m[i] = row;\n      for (let j = 0; j <= rank; ++j) {\n        row[j] = transform[(rank + 1) * j + i];\n      }\n    }\n  }\n  return {\n    sourceRank: sourceRank === rank ? undefined : sourceRank,\n    matrix: m,\n    outputDimensions: coordinateSpaceToJson(outputSpace),\n    inputDimensions:\n      inputSpace === undefined ? undefined : coordinateSpaceToJson(inputSpace),\n  };\n}\n\nexport function permuteTransformedBoundingBox(\n  boundingBox: TransformedBoundingBox,\n  newToOld: readonly number[],\n  oldOutputRank: number,\n): TransformedBoundingBox | undefined {\n  const { box, transform } = boundingBox;\n  const inputRank = boundingBox.box.lowerBounds.length;\n  const outputRank = newToOld.length;\n  const newTransform = new Float64Array((inputRank + 1) * outputRank);\n  matrix.permuteRows(\n    newTransform,\n    outputRank,\n    transform,\n    oldOutputRank,\n    newToOld,\n    inputRank + 1,\n  );\n  if (newTransform.every((x) => x === 0)) return undefined;\n  return {\n    transform: newTransform,\n    box,\n  };\n}\n\nexport function permuteCoordinateSpace(\n  existing: CoordinateSpace,\n  newToOld: readonly number[],\n) {\n  const { ids, names, scales, units, timestamps, coordinateArrays } = existing;\n  return makeCoordinateSpace({\n    rank: newToOld.length,\n    valid: existing.valid,\n    ids: newToOld.map((i) => ids[i]),\n    names: newToOld.map((i) => names[i]),\n    timestamps: newToOld.map((i) => timestamps[i]),\n    scales: Float64Array.from(newToOld, (i) => scales[i]),\n    units: newToOld.map((i) => units[i]),\n    coordinateArrays: newToOld.map((i) => coordinateArrays[i]),\n    boundingBoxes: existing.boundingBoxes\n      .map((b) => permuteTransformedBoundingBox(b, newToOld, existing.rank))\n      .filter((b) => b !== undefined) as TransformedBoundingBox[],\n  });\n}\n\nexport function insertDimensionAt(\n  existing: CoordinateSpace,\n  targetIndex: number,\n  sourceIndex: number,\n) {\n  if (targetIndex === sourceIndex) return existing;\n  return permuteCoordinateSpace(\n    existing,\n    getInsertPermutation(existing.rank, sourceIndex, targetIndex),\n  );\n}\n\nexport function getInferredOutputScale(\n  transform: CoordinateSpaceTransform,\n  outputDim: number,\n): { scale: number; unit: string } | undefined {\n  const { transform: transformMatrix, rank } = transform;\n  const inputDims = getDependentTransformInputDimensions(\n    transformMatrix,\n    rank,\n    [outputDim],\n  );\n  if (inputDims.length !== 1) return undefined;\n  const [inputDim] = inputDims;\n  const coeff = Math.abs(transformMatrix[(rank + 1) * inputDim + outputDim]);\n  const { inputSpace } = transform;\n  return {\n    scale: inputSpace.scales[inputDim] * coeff,\n    unit: inputSpace.units[inputDim],\n  };\n}\n\nexport function getDefaultInputScale(\n  transform: WatchableCoordinateSpaceTransform,\n  inputDim: number,\n): { scale: number; unit: string } | undefined {\n  const { scales: defaultScales, units: defaultUnits } =\n    transform.defaultInputSpace;\n  return inputDim < defaultScales.length\n    ? { scale: defaultScales[inputDim], unit: defaultUnits[inputDim] }\n    : undefined;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Defines a generic interface for a simple state tracking mechanism.\n */\n\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { verifyObject, verifyOptionalObjectProperty } from \"#src/util/json.js\";\nimport type { NullaryReadonlySignal } from \"#src/util/signal.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\n\nexport interface JsonRestorable {\n  restoreState: (x: any) => void;\n}\n\nexport function optionallyRestoreFromJsonMember(\n  obj: any,\n  member: string,\n  restorable: JsonRestorable,\n) {\n  verifyOptionalObjectProperty(obj, member, (x) => restorable.restoreState(x));\n}\n\nexport interface Trackable extends JsonRestorable {\n  restoreState: (x: any) => void;\n  reset: () => void;\n  changed: NullaryReadonlySignal;\n  toJSON: () => any;\n}\n\nexport class CompoundTrackable extends RefCounted implements Trackable {\n  children = new Map<string, Trackable>();\n  changed = new NullarySignal();\n\n  add(key: string, value: Trackable): () => void {\n    const { children } = this;\n    if (children.has(key)) {\n      throw new Error(`Key ${JSON.stringify(key)} already registered.`);\n    }\n    this.children.set(key, value);\n    value.changed.add(this.changed.dispatch);\n    this.changed.dispatch();\n    return () => {\n      this.remove(key);\n    };\n  }\n\n  remove(key: string): void {\n    const { children } = this;\n    if (children.has(key)) {\n      throw new Error(`Key ${JSON.stringify(key)} not registered.`);\n    }\n    const value = children.get(key)!;\n    this.children.delete(key);\n    value.changed.remove(this.changed.dispatch);\n    this.changed.dispatch();\n  }\n\n  disposed() {\n    const { changed } = this;\n    for (const value of this.children.values()) {\n      value.changed.remove(changed.dispatch);\n    }\n    this.children = <any>undefined;\n    super.disposed();\n  }\n\n  toJSON() {\n    const result = this.baseJSON();\n    for (const [key, value] of this.children) {\n      result[key] = value.toJSON();\n    }\n    return result;\n  }\n\n  baseJSON() {\n    return <{ [key: string]: any }>{};\n  }\n\n  reset() {\n    for (const value of this.children.values()) {\n      value.reset();\n    }\n  }\n\n  restoreState(x: any) {\n    verifyObject(x);\n    for (const [key, value] of this.children) {\n      try {\n        if (Object.prototype.hasOwnProperty.call(x, key)) {\n          const subValue = x[key];\n          if (subValue === undefined) {\n            continue;\n          }\n          value.restoreState(subValue);\n        }\n      } catch (restoreError) {\n        throw new Error(\n          `Error restoring property ${JSON.stringify(key)}: ${\n            restoreError.message\n          }`,\n        );\n      }\n    }\n  }\n}\n\nexport class PersistentCompoundTrackable extends CompoundTrackable {\n  lastState: { [key: string]: any } = {};\n\n  restoreState(x: any) {\n    verifyObject(x);\n    this.lastState = x;\n    super.restoreState(x);\n  }\n\n  reset() {\n    this.lastState = {};\n    super.reset();\n  }\n\n  baseJSON() {\n    const result = Object.assign(super.baseJSON(), this.lastState);\n    for (const key of this.children.keys()) {\n      delete result[key];\n    }\n    return result;\n  }\n\n  toJSON() {\n    const result = super.toJSON();\n    this.lastState = result;\n    return result;\n  }\n  add(key: string, value: Trackable) {\n    const result = super.add(key, value);\n    const existingValue = this.lastState[key];\n    if (existingValue !== undefined) {\n      value.reset();\n      value.restoreState(existingValue);\n    }\n    return result;\n  }\n}\n\n/**\n * Cache used by getCachedJson.\n */\nconst jsonCache = new WeakMap<Trackable, { value: any; generation: number }>();\n\n/**\n * Returns a JSON representation of a Trackable object.\n *\n * Recursively caches the result, such that it is only necessary to traverse the changed portions of\n * the object.\n *\n * The returned value must not be modified.\n */\nexport function getCachedJson(root: Trackable): {\n  value: any;\n  generation: number;\n} {\n  let cacheState = jsonCache.get(root);\n  const generation = root.changed.count;\n  if (cacheState !== undefined) {\n    if (cacheState.generation === generation) {\n      return cacheState;\n    }\n  }\n  let value: any;\n  if (root instanceof CompoundTrackable) {\n    value = root.baseJSON();\n    for (const [k, v] of root.children) {\n      value[k] = getCachedJson(v).value;\n    }\n  } else {\n    value = root.toJSON();\n  }\n  if (cacheState === undefined) {\n    cacheState = { generation, value };\n    jsonCache.set(root, cacheState);\n  } else {\n    cacheState.generation = generation;\n    cacheState.value = value;\n  }\n  return cacheState;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\n\nimport type { FrameNumberCounter } from \"#src/chunk_manager/frontend.js\";\nimport { TrackableValue } from \"#src/trackable_value.js\";\nimport { animationFrameDebounce } from \"#src/util/animation_frame_debounce.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { FramerateMonitor } from \"#src/util/framerate.js\";\nimport type { mat4 } from \"#src/util/geom.js\";\nimport { parseFixedLengthArray, verifyFloat01 } from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport {\n  TrackableScreenshotMode,\n  ScreenshotMode,\n} from \"#src/util/trackable_screenshot_mode.js\";\nimport type { WatchableVisibilityPriority } from \"#src/visibility_priority/frontend.js\";\nimport type { GL } from \"#src/webgl/context.js\";\nimport { initializeWebGL } from \"#src/webgl/context.js\";\n\nconst DELAY_AFTER_CONTINUOUS_CAMERA_MOTION_MS = 300;\n\nexport class RenderViewport {\n  // Width of visible portion of panel in canvas pixels.\n  width = 0;\n\n  // Height of visible portion of panel in canvas pixels.\n  height = 0;\n\n  // Width in canvas pixels, including portions outside of the canvas (i.e. outside the \"viewport\"\n  // window).\n  logicalWidth = 0;\n\n  // Height in canvas pixels, including portions outside of the canvas (i.e. outside the \"viewport\"\n  // window).\n  logicalHeight = 0;\n\n  // Left edge of visible region within full (logical) panel, as fraction in [0, 1].\n  visibleLeftFraction = 0;\n\n  // Top edge of visible region within full (logical) panel, as fraction in [0, 1].\n  visibleTopFraction = 0;\n\n  // Fraction of logical width that is visible, equal to `widthInCanvasPixels / logicalWidth`.\n  visibleWidthFraction = 0;\n\n  // Fraction of logical height that is visible, equal to `heightInCanvasPixels / logicalHeight`.\n  visibleHeightFraction = 0;\n}\n\nexport function applyRenderViewportToProjectionMatrix(\n  viewport: RenderViewport,\n  projectionMatrix: mat4,\n) {\n  const xScale = 1 / viewport.visibleWidthFraction;\n  const yScale = 1 / viewport.visibleHeightFraction;\n  const xOffset = -1 - (-1 + 2 * viewport.visibleLeftFraction) * xScale;\n  let yOffset = -1 - (-1 + 2 * viewport.visibleTopFraction) * yScale;\n  yOffset = -yOffset;\n  projectionMatrix[0] =\n    projectionMatrix[0] * xScale + projectionMatrix[3] * xOffset;\n  projectionMatrix[4] =\n    projectionMatrix[4] * xScale + projectionMatrix[7] * xOffset;\n  projectionMatrix[8] =\n    projectionMatrix[8] * xScale + projectionMatrix[11] * xOffset;\n  projectionMatrix[12] =\n    projectionMatrix[12] * xScale + projectionMatrix[15] * xOffset;\n\n  projectionMatrix[1] =\n    projectionMatrix[1] * yScale + projectionMatrix[3] * yOffset;\n  projectionMatrix[5] =\n    projectionMatrix[5] * yScale + projectionMatrix[7] * yOffset;\n  projectionMatrix[9] =\n    projectionMatrix[9] * yScale + projectionMatrix[11] * yOffset;\n  projectionMatrix[13] =\n    projectionMatrix[13] * yScale + projectionMatrix[15] * yOffset;\n}\n\nexport function renderViewportsEqual(a: RenderViewport, b: RenderViewport) {\n  return (\n    a.width === b.width &&\n    a.height === b.height &&\n    a.logicalWidth === b.logicalWidth &&\n    a.logicalHeight === b.logicalHeight &&\n    a.visibleLeftFraction === b.visibleLeftFraction &&\n    a.visibleTopFraction === b.visibleTopFraction\n  );\n}\n\nexport abstract class RenderedPanel extends RefCounted {\n  gl: GL;\n\n  // Generation used to check whether the following bounds-related fields are up to date.\n  boundsGeneration = -1;\n\n  // Offset of visible portion of panel in canvas pixels from left side of canvas.\n  canvasRelativeClippedLeft = 0;\n\n  // Offset of visible portion of panel in canvas pixels from top of canvas.\n  canvasRelativeClippedTop = 0;\n\n  canvasRelativeLogicalLeft = 0;\n  canvasRelativeLogicalTop = 0;\n\n  renderViewport = new RenderViewport();\n\n  boundsUpdated = new NullarySignal();\n\n  private monitorState: PanelMonitorState = { isIntersecting: true };\n\n  constructor(\n    public context: Borrowed<DisplayContext>,\n    public element: HTMLElement,\n    public visibility: WatchableVisibilityPriority,\n  ) {\n    super();\n    this.gl = context.gl;\n    context.addPanel(this);\n  }\n\n  scheduleRedraw() {\n    if (this.visible) {\n      this.context.scheduleRedraw();\n    }\n  }\n\n  abstract isReady(): boolean;\n\n  ensureBoundsUpdated(canScaleForScreenshot: boolean = false) {\n    const { context } = this;\n    context.ensureBoundsUpdated();\n    const { boundsGeneration } = context;\n    if (boundsGeneration === this.boundsGeneration) return;\n    this.boundsGeneration = boundsGeneration;\n    const { element } = this;\n    const clientRect = element.getBoundingClientRect();\n    context.ensureMonitorPanel(element, this.monitorState, clientRect);\n    const root = context.container;\n    const canvasRect = context.canvasRect!;\n    const { canvas } = context;\n    const { width: canvasPixelWidth, height: canvasPixelHeight } = canvas;\n    const screenToCanvasPixelScaleX = canvasPixelWidth / canvasRect.width;\n    const screenToCanvasPixelScaleY = canvasPixelHeight / canvasRect.height;\n    // Logical bounding rectangle in canvas/WebGL pixels (which may be a different size than screen\n    // pixels when using a fixed canvas size via the Python integration).\n    const canvasLeft = canvasRect.left;\n    const canvasTop = canvasRect.top;\n    const logicalLeft = (this.canvasRelativeLogicalLeft = Math.round(\n      (clientRect.left - canvasLeft) * screenToCanvasPixelScaleX +\n        element.clientLeft,\n    ));\n    const logicalTop = (this.canvasRelativeLogicalTop = Math.round(\n      (clientRect.top - canvasTop) * screenToCanvasPixelScaleY +\n        element.clientTop,\n    ));\n    const logicalWidth = element.clientWidth;\n    const logicalHeight = element.clientHeight;\n    const logicalRight = logicalLeft + logicalWidth;\n    const logicalBottom = logicalTop + logicalHeight;\n    // Clipped bounding rectangle in canvas/WebGL pixels.  The clipped bounding rectangle is the\n    // portion actually visible and overlapping the canvas.\n    let clippedTop = logicalTop;\n    let clippedLeft = logicalLeft;\n    let clippedRight = logicalRight;\n    let clippedBottom = logicalBottom;\n    for (\n      let parent = element.parentElement;\n      parent !== null && parent !== root;\n      parent = parent.parentElement\n    ) {\n      const rect = parent.getBoundingClientRect();\n      if (\n        rect.x === 0 &&\n        rect.y === 0 &&\n        rect.width === 0 &&\n        rect.height === 0\n      ) {\n        // Assume this is a `display: contents;` element.\n        continue;\n      }\n      const newClippedLeft = Math.max(\n        clippedLeft,\n        (rect.left - canvasLeft) * screenToCanvasPixelScaleX,\n      );\n      const newClippedTop = Math.max(\n        clippedTop,\n        (rect.top - canvasTop) * screenToCanvasPixelScaleY,\n      );\n      const newClippedRight = Math.min(\n        clippedRight,\n        (rect.right - canvasLeft) * screenToCanvasPixelScaleX,\n      );\n      const newClippedBottom = Math.min(\n        clippedBottom,\n        (rect.bottom - canvasTop) * screenToCanvasPixelScaleY,\n      );\n      if (newClippedLeft !== clippedLeft || newClippedRight !== clippedRight) {\n        const overflowX = getComputedStyle(parent).overflowX;\n        if (overflowX === \"hidden\" || overflowX === \"clip\") {\n          clippedLeft = newClippedLeft;\n          clippedRight = newClippedRight;\n        }\n      }\n      if (newClippedTop !== clippedTop || newClippedBottom !== clippedBottom) {\n        const overflowY = getComputedStyle(parent).overflowY;\n        if (overflowY === \"hidden\" || overflowY === \"clip\") {\n          clippedTop = newClippedTop;\n          clippedBottom = newClippedBottom;\n        }\n      }\n    }\n    clippedTop = this.canvasRelativeClippedTop = Math.round(\n      Math.max(clippedTop, 0),\n    );\n    clippedLeft = this.canvasRelativeClippedLeft = Math.round(\n      Math.max(clippedLeft, 0),\n    );\n    clippedRight = Math.round(Math.min(clippedRight, canvasPixelWidth));\n    clippedBottom = Math.round(Math.min(clippedBottom, canvasPixelHeight));\n    const viewport = this.renderViewport;\n    const clippedWidth = (viewport.width = Math.max(\n      0,\n      clippedRight - clippedLeft,\n    ));\n    const clippedHeight = (viewport.height = Math.max(\n      0,\n      clippedBottom - clippedTop,\n    ));\n    if (\n      this.context.screenshotMode.value !== ScreenshotMode.OFF &&\n      canScaleForScreenshot\n    ) {\n      viewport.width = logicalWidth * screenToCanvasPixelScaleX;\n      viewport.height = logicalHeight * screenToCanvasPixelScaleY;\n      viewport.logicalWidth = logicalWidth * screenToCanvasPixelScaleX;\n      viewport.logicalHeight = logicalHeight * screenToCanvasPixelScaleY;\n    } else {\n      viewport.logicalWidth = logicalWidth;\n      viewport.logicalHeight = logicalHeight;\n    }\n    viewport.visibleLeftFraction = (clippedLeft - logicalLeft) / logicalWidth;\n    viewport.visibleTopFraction = (clippedTop - logicalTop) / logicalHeight;\n    viewport.visibleWidthFraction = clippedWidth / logicalWidth;\n    viewport.visibleHeightFraction = clippedHeight / logicalHeight;\n    this.boundsUpdated.dispatch();\n  }\n\n  // Sets the viewport to the clipped viewport.  Any drawing must take\n  // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {\n  setGLClippedViewport() {\n    const {\n      gl,\n      canvasRelativeClippedTop,\n      canvasRelativeClippedLeft,\n      renderViewport: { width, height },\n    } = this;\n    const bottom = canvasRelativeClippedTop + height;\n    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);\n    const glBottom = this.context.canvas.height - bottom;\n    gl.viewport(canvasRelativeClippedLeft, glBottom, width, height);\n    gl.scissor(canvasRelativeClippedLeft, glBottom, width, height);\n  }\n\n  // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the\n  // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into\n  // account.\n  setGLLogicalViewport() {\n    const {\n      gl,\n      renderViewport: { width, height, logicalWidth, logicalHeight },\n    } = this;\n    const canvasHeight = this.context.canvas.height;\n    gl.enable(WebGL2RenderingContext.SCISSOR_TEST);\n    gl.viewport(\n      this.canvasRelativeLogicalLeft,\n      canvasHeight - (this.canvasRelativeLogicalTop + logicalHeight),\n      logicalWidth,\n      logicalHeight,\n    );\n    gl.scissor(\n      this.canvasRelativeClippedLeft,\n      canvasHeight - (this.canvasRelativeClippedTop + height),\n      width,\n      height,\n    );\n  }\n\n  abstract draw(): void;\n\n  disposed() {\n    this.context.unmonitorPanel(this.element, this.monitorState);\n    this.context.removePanel(this);\n    super.disposed();\n  }\n\n  get visible() {\n    return this.visibility.visible;\n  }\n\n  getDepthArray(): Float32Array | undefined {\n    return undefined;\n  }\n\n  get shouldDraw() {\n    if (!this.visible) return false;\n    const { element } = this;\n    if (\n      element.clientWidth === 0 ||\n      element.clientHeight === 0 ||\n      element.offsetWidth === 0 ||\n      element.offsetHeight === 0\n    ) {\n      // Skip drawing if the panel has zero client area.\n      return false;\n    }\n    return true;\n  }\n\n  // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel\n  // to ensure it is drawn after other panels that update the histogram.\n  //\n  // A higher number -> later draw.\n  get drawOrder() {\n    return 0;\n  }\n}\n\nexport abstract class IndirectRenderedPanel extends RenderedPanel {\n  canvas = document.createElement(\"canvas\");\n  canvasRenderingContext = this.canvas.getContext(\"2d\");\n  constructor(\n    context: Borrowed<DisplayContext>,\n    element: HTMLElement,\n    visibility: WatchableVisibilityPriority,\n  ) {\n    super(context, element, visibility);\n    const { canvas } = this;\n    element.appendChild(canvas);\n    element.style.position = \"relative\";\n    canvas.style.position = \"absolute\";\n    canvas.style.left = \"0\";\n    canvas.style.right = \"0\";\n    canvas.style.top = \"0\";\n    canvas.style.bottom = \"0\";\n  }\n\n  abstract drawIndirect(): void;\n\n  draw() {\n    this.drawIndirect();\n    const { renderViewport, canvas } = this;\n    const { logicalWidth, logicalHeight } = renderViewport;\n    canvas.width = logicalWidth;\n    canvas.height = logicalHeight;\n    const { canvasRenderingContext } = this;\n    canvasRenderingContext?.drawImage(\n      this.context.canvas,\n      this.canvasRelativeLogicalLeft,\n      this.canvasRelativeLogicalTop,\n      logicalWidth,\n      logicalHeight,\n      0,\n      0,\n      logicalWidth,\n      logicalHeight,\n    );\n  }\n}\n\n// Specifies a rectangular sub-region of the full viewer area to actually be rendered on the canvas.\n// This is used by the Python integration to produce large screenshots by tiling multiple\n// screenshots.\n//\n// The value is: `[left, top, width, height]` where all values are in [0, 1].\nexport class TrackableWindowedViewport extends TrackableValue<Float64Array> {\n  constructor() {\n    super(Float64Array.of(0, 0, 1, 1), (obj) =>\n      parseFixedLengthArray(new Float64Array(4), obj, verifyFloat01),\n    );\n  }\n  toJSON() {\n    const { value } = this;\n    const [left, top, width, height] = value;\n    if (left === 0 && top === 0 && width === 1 && height === 1)\n      return undefined;\n    return Array.from(value);\n  }\n}\n\n// Size/position monitoring state for a single panel.\ninterface PanelMonitorState {\n  // Intersection observer used to detect movement of a panel.  The root element is always the root\n  // container element.\n  intersectionObserver?: IntersectionObserver;\n\n  // Margin within the root element chosen to exactly match the bounds\n  // of the panel element when the IntersectionObserver was created.\n  // When the bounds of either the root element or the panel element\n  // have possibly changed, the new margin is computed and compared to\n  // this value.  This is stored separately, rather than just relying\n  // on `intersectionObserver?.rootMargin`, to avoid spuriously change\n  // detections due to normalization that the browser may do.\n  intersectionObserverMargin?: string;\n\n  // Indicates that the element is intersecting the viewport at all. If `true`,\n  // then the intersection observer margin is set normally to detect any\n  // changes. If `false`, then the intersection observer margin is set to cover\n  // the entire viewport in order to detect when the panel becomes visible\n  // again.\n  isIntersecting: boolean;\n\n  // Indicates that the panel element was added to the resize observer.\n  addedToResizeObserver?: boolean;\n}\n\nexport class DisplayContext extends RefCounted implements FrameNumberCounter {\n  canvas = document.createElement(\"canvas\");\n  gl: GL;\n  updateStarted = new NullarySignal();\n  updateFinished = new NullarySignal();\n  continuousCameraMotionStarted = new NullarySignal();\n  continuousCameraMotionFinished = new NullarySignal();\n  changed = this.updateFinished;\n  panels = new Set<RenderedPanel>();\n  canvasRect: DOMRect | undefined;\n  rootRect: DOMRect | undefined;\n  resizeGeneration = 0;\n  boundsGeneration = -1;\n  screenshotMode: TrackableScreenshotMode = new TrackableScreenshotMode(\n    ScreenshotMode.OFF,\n  );\n  force3DHistogramForAutoRange = false;\n  private framerateMonitor = new FramerateMonitor();\n\n  private continuousCameraMotionInProgress = false;\n\n  // Panels ordered by `drawOrder`.  If length is 0, needs to be recomputed.\n  private orderedPanels: RenderedPanel[] = [];\n\n  /**\n   * Unique number of the next frame.  Incremented once each time a frame is drawn.\n   */\n  frameNumber = 0;\n\n  resizeCallback = () => {\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  };\n\n  ensureMonitorPanel(\n    element: HTMLElement,\n    state: PanelMonitorState,\n    elementClientRect: DOMRect,\n  ) {\n    if (!state.addedToResizeObserver) {\n      this.resizeObserver.observe(element);\n      state.addedToResizeObserver = true;\n    }\n    let margin: string;\n    if (state.isIntersecting) {\n      const rootRect = this.rootRect!;\n      const marginTop = rootRect.top - elementClientRect.top;\n      const marginLeft = rootRect.left - elementClientRect.left;\n      const marginRight = elementClientRect.right - rootRect.right;\n      const marginBottom = elementClientRect.bottom - rootRect.bottom;\n      margin = `${marginTop}px ${marginRight}px ${marginBottom}px ${marginLeft}px`;\n    } else {\n      margin = \"\";\n    }\n    if (state.intersectionObserverMargin !== margin) {\n      state.intersectionObserverMargin = margin;\n      state.intersectionObserver?.disconnect();\n      const thresholds = new Array(101);\n      for (let i = 0; i <= 100; ++i) {\n        thresholds[i] = 0.01 * i;\n      }\n      const intersectionObserver = (state.intersectionObserver =\n        new IntersectionObserver(\n          (entries) => {\n            const lastEntry = entries[entries.length - 1];\n            state.isIntersecting = lastEntry.isIntersecting;\n            this.resizeCallback();\n          },\n          {\n            root: this.container,\n            rootMargin: margin,\n            threshold: thresholds,\n          },\n        ));\n      intersectionObserver.observe(element);\n    }\n  }\n\n  unmonitorPanel(element: HTMLElement, state: PanelMonitorState) {\n    if (state.addedToResizeObserver) {\n      this.resizeObserver.unobserve(element);\n    }\n    state.intersectionObserver?.disconnect();\n  }\n\n  private resizeObserver = new ResizeObserver(this.resizeCallback);\n\n  private debouncedEndContinuousCameraMotion = this.registerCancellable(\n    debounce(() => {\n      this.continuousCameraMotionInProgress = false;\n      this.continuousCameraMotionFinished.dispatch();\n    }, DELAY_AFTER_CONTINUOUS_CAMERA_MOTION_MS),\n  );\n\n  flagContinuousCameraMotion() {\n    if (!this.continuousCameraMotionInProgress) {\n      this.continuousCameraMotionStarted.dispatch();\n    }\n    this.continuousCameraMotionInProgress = true;\n    this.debouncedEndContinuousCameraMotion();\n  }\n\n  get isContinuousCameraMotionInProgress() {\n    return this.continuousCameraMotionInProgress;\n  }\n\n  constructor(public container: HTMLElement) {\n    super();\n    const { canvas, resizeObserver } = this;\n    container.style.position = \"relative\";\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0px\";\n    canvas.style.left = \"0px\";\n    canvas.style.width = \"100%\";\n    canvas.style.height = \"100%\";\n    canvas.style.zIndex = \"0\";\n    resizeObserver.observe(canvas);\n    container.appendChild(canvas);\n    // Additionally monitor for scroll events.  This catches cases not handled\n    // by the IntersectionObserver.\n    this.registerEventListener(\n      container,\n      \"scroll\",\n      () => {\n        this.resizeCallback();\n      },\n      { capture: true, passive: true },\n    );\n    this.registerEventListener(\n      canvas,\n      \"webglcontextlost\",\n      (event: WebGLContextEvent) => {\n        console.log(`Lost WebGL context: ${event.statusMessage}`);\n        // Wait for context to be regained.\n        event.preventDefault();\n      },\n    );\n    this.registerEventListener(canvas, \"webglcontextrestored\", () => {\n      console.log(\"WebGL context restored\");\n      // Simply reload Neuroglancer.\n      window.location.reload();\n    });\n    this.gl = initializeWebGL(canvas);\n  }\n\n  applyWindowedViewportToElement(element: HTMLElement, value: Float64Array) {\n    // These values specify the position of the canvas relative to the viewer.  However, we will\n    // actually leave the canvas in place (such that it still fills the browser window) and move\n    // the viewer.\n    const [left, top, width, height] = value;\n    const totalWidth = 1 / width;\n    const totalHeight = 1 / height;\n    element.style.position = \"absolute\";\n    element.style.top = `${-totalHeight * top * 100}%`;\n    element.style.left = `${-totalWidth * left * 100}%`;\n    element.style.width = `${totalWidth * 100}%`;\n    element.style.height = `${totalHeight * 100}%`;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  isReady() {\n    for (const panel of this.panels) {\n      if (!panel.visible) {\n        continue;\n      }\n      if (!panel.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns a child element that overlays the canvas.\n   */\n  makeCanvasOverlayElement() {\n    const element = document.createElement(\"div\");\n    element.style.position = \"absolute\";\n    element.style.top = \"0px\";\n    element.style.left = \"0px\";\n    element.style.width = \"100%\";\n    element.style.height = \"100%\";\n    element.style.zIndex = \"2\";\n    this.container.appendChild(element);\n    return element;\n  }\n\n  disposed() {\n    this.orderedPanels.length = 0;\n    this.resizeObserver.disconnect();\n  }\n\n  addPanel(panel: Borrowed<RenderedPanel>) {\n    this.panels.add(panel);\n    this.orderedPanels.length = 0;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  removePanel(panel: Borrowed<RenderedPanel>) {\n    this.panels.delete(panel);\n    this.orderedPanels.length = 0;\n    ++this.resizeGeneration;\n    this.scheduleRedraw();\n  }\n\n  readonly scheduleRedraw = this.registerCancellable(\n    animationFrameDebounce(() => this.draw()),\n  );\n\n  ensureBoundsUpdated() {\n    const { resizeGeneration } = this;\n    if (this.boundsGeneration === resizeGeneration) return;\n    const { canvas } = this;\n    if (this.screenshotMode.value === ScreenshotMode.OFF) {\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n    }\n    this.canvasRect = canvas.getBoundingClientRect();\n    this.rootRect = this.container.getBoundingClientRect();\n    this.boundsGeneration = resizeGeneration;\n  }\n\n  draw() {\n    ++this.frameNumber;\n    this.updateStarted.dispatch();\n    const gl = this.gl;\n    const ext = this.framerateMonitor.getTimingExtension(gl);\n    this.framerateMonitor.startFrameTimeQuery(gl, ext, this.frameNumber);\n    this.ensureBoundsUpdated();\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    const { orderedPanels, panels } = this;\n    if (orderedPanels.length !== panels.size) {\n      orderedPanels.push(...panels);\n      orderedPanels.sort((a, b) => a.drawOrder - b.drawOrder);\n    }\n    for (const panel of orderedPanels) {\n      panel.ensureBoundsUpdated();\n      if (!panel.shouldDraw) continue;\n      const { renderViewport } = panel;\n      if (renderViewport.width === 0 || renderViewport.height === 0) continue;\n      panel.draw();\n    }\n\n    // Ensure the alpha buffer is set to 1.\n    gl.disable(gl.SCISSOR_TEST);\n    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n    this.gl.colorMask(false, false, false, true);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    this.gl.colorMask(true, true, true, true);\n    this.updateFinished.dispatch();\n    this.framerateMonitor.endLastTimeQuery(gl, ext);\n    this.framerateMonitor.grabAnyFinishedQueryResults(gl);\n  }\n\n  getDepthArray(): Float32Array {\n    const { width, height } = this.canvas;\n    const depthArray = new Float32Array(width * height);\n    for (const panel of this.panels) {\n      if (!panel.shouldDraw) continue;\n      const panelDepthArray = panel.getDepthArray();\n      if (panelDepthArray === undefined) continue;\n      const {\n        canvasRelativeClippedTop,\n        canvasRelativeClippedLeft,\n        renderViewport: { width, height },\n      } = panel;\n      for (let y = 0; y < height; ++y) {\n        const panelDepthArrayOffset = (height - 1 - y) * width;\n        depthArray.set(\n          panelDepthArray.subarray(\n            panelDepthArrayOffset,\n            panelDepthArrayOffset + width,\n          ),\n          (canvasRelativeClippedTop + y) * width + canvasRelativeClippedLeft,\n        );\n      }\n    }\n    return depthArray;\n  }\n\n  getLastFrameTimesInMs(numberOfFrames: number = 10) {\n    return this.framerateMonitor.getLastFrameTimesInMs(numberOfFrames);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  CoordinateSpace,\n  CoordinateSpaceTransform,\n} from \"#src/coordinate_transform.js\";\nimport {\n  emptyValidCoordinateSpace,\n  homogeneousTransformSubmatrix,\n} from \"#src/coordinate_transform.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport type {\n  CachedWatchableValue,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport {\n  constantWatchableValue,\n  makeCachedDerivedWatchableValue,\n} from \"#src/trackable_value.js\";\nimport { arraysEqual, scatterUpdate } from \"#src/util/array.js\";\nimport type { ValueOrError } from \"#src/util/error.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport { mat4, getDependentTransformInputDimensions } from \"#src/util/geom.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport { prod } from \"#src/util/vector.js\";\n\n/**\n * Specifies coordinate transform information for a RenderLayer.\n */\nexport interface RenderLayerTransform {\n  /**\n   * Rank of chunk/model/layer subspace used by this RenderLayer, including any additional `[0,1)`\n   * padding dimensions.\n   */\n  rank: number;\n\n  /**\n   * Rank of chunk/model/layer space, excluding any padding dimensions.\n   */\n  unpaddedRank: number;\n\n  /**\n   * Specifies for each local user layer dimension the corresponding \"render layer\" dimension.  A\n   * value of `-1` indicates there is no corresponding \"render layer\" dimension.  The combined\n   * values of `localToRenderLayerDimensions` and `globalToRenderLayerDimensions` that are not `-1`\n   * must be distinct and partition `[0, ..., rank)`, where `rank` is the rank of the \"model\"\n   * coordinate space.\n   */\n  localToRenderLayerDimensions: readonly number[];\n\n  /**\n   * Specifies for each global dimension the corresponding \"render layer\" dimension.  A value of\n   * `-1` indicates there is no corresponding \"render layer\" dimension.\n   */\n  globalToRenderLayerDimensions: readonly number[];\n\n  /**\n   * Specifies for each channel dimension the corresponding \"render layer\" dimension.  A value of\n   * `-1` indicates there is no corresponding \"render layer\" dimension.\n   */\n  channelToRenderLayerDimensions: readonly number[];\n\n  channelToModelDimensions: readonly number[];\n\n  channelSpaceShape: Uint32Array;\n\n  /**\n   * Homogeneous transform from \"model\" coordinate space to \"render layer\" coordinate space.\n   */\n  modelToRenderLayerTransform: Float32Array;\n\n  modelDimensionNames: readonly string[];\n  layerDimensionNames: readonly string[];\n}\n\nexport interface ChannelSpace {\n  channelCoordinateSpace: CoordinateSpace;\n  // Shape of multi-dimensional channel space.\n  shape: Uint32Array;\n  // Total number of channels, equal to product of `shape`.\n  numChannels: number;\n  // Row-major array of shape `[count, rank]` specifying the coordinates for each flattened channel.\n  // Channels are ordered in Fortran order.\n  coordinates: Uint32Array;\n}\n\nexport const zeroRankChannelSpace: ChannelSpace = {\n  channelCoordinateSpace: emptyValidCoordinateSpace,\n  shape: new Uint32Array(0),\n  numChannels: 1,\n  coordinates: new Uint32Array(0),\n};\n\nexport function getChannelSpace(\n  channelCoordinateSpace: CoordinateSpace,\n): ChannelSpace {\n  const { rank } = channelCoordinateSpace;\n  const {\n    bounds: { lowerBounds, upperBounds },\n  } = channelCoordinateSpace;\n  if (lowerBounds.some((x) => x !== 0)) {\n    throw new Error(\"Lower bounds of channel coordinate space must all be 0\");\n  }\n  if (upperBounds.some((x) => !Number.isInteger(x) || x <= 0 || x >= 2 ** 32)) {\n    throw new Error(\n      \"Upper bounds of channel coordinate space must all be positive integers\",\n    );\n  }\n  const shape = new Uint32Array(upperBounds);\n  const numChannels = prod(shape);\n  const coordinates = new Uint32Array(numChannels * rank);\n  for (let flatIndex = 0; flatIndex < numChannels; ++flatIndex) {\n    let remainder = flatIndex;\n    for (let dim = 0; dim < rank; ++dim) {\n      const coordinate = remainder % shape[dim];\n      remainder = (remainder - coordinate) / shape[dim];\n      coordinates[flatIndex * rank + dim] = coordinate;\n    }\n  }\n  return { channelCoordinateSpace, shape, numChannels, coordinates };\n}\n\nexport type RenderLayerTransformOrError = ValueOrError<RenderLayerTransform>;\nexport type WatchableRenderLayerTransform =\n  WatchableValueInterface<RenderLayerTransformOrError>;\n\nfunction scaleTransformSubmatrix(\n  transform: Float32Array,\n  rank: number,\n  baseInputSpace: CoordinateSpace,\n  inputToBaseDimensions: readonly number[],\n  baseOutputSpace: CoordinateSpace,\n  baseToOutputDimensions: readonly number[],\n) {\n  const { scales: baseInputScales } = baseInputSpace;\n  const { scales: baseOutputScales, rank: baseOutputRank } = baseOutputSpace;\n  const stride = rank + 1;\n  for (let baseOutputDim = 0; baseOutputDim < baseOutputRank; ++baseOutputDim) {\n    const outputDim = baseToOutputDimensions[baseOutputDim];\n    if (outputDim === -1) continue;\n    const baseOutputScale = baseOutputScales[baseOutputDim];\n    for (let inputDim = 0; inputDim < rank; ++inputDim) {\n      const baseInputDim = inputToBaseDimensions[inputDim];\n      const baseInputScale = baseInputScales[baseInputDim];\n      transform[stride * inputDim + outputDim] *=\n        baseInputScale / baseOutputScale;\n    }\n  }\n}\n\nexport function getRenderLayerTransform(\n  globalCoordinateSpace: CoordinateSpace,\n  localCoordinateSpace: CoordinateSpace,\n  modelToLayerTransform: CoordinateSpaceTransform,\n  subsourceEntry:\n    | {\n        subsourceToModelSubspaceTransform: Float32Array;\n        modelSubspaceDimensionIndices: readonly number[];\n      }\n    | undefined,\n  channelCoordinateSpace: CoordinateSpace = emptyValidCoordinateSpace,\n): RenderLayerTransformOrError {\n  const {\n    inputSpace: modelSpace,\n    rank: fullRank,\n    sourceRank,\n    outputSpace: layerSpace,\n    transform: oldTransform,\n  } = modelToLayerTransform;\n  const { names: modelDimensionNames } = modelSpace;\n  const { names: transformOutputDimensions } = layerSpace;\n  let requiredInputDims: number[];\n  if (subsourceEntry !== undefined) {\n    requiredInputDims = Array.from(\n      subsourceEntry.modelSubspaceDimensionIndices,\n    );\n  } else {\n    requiredInputDims = [];\n    for (let i = 0; i < sourceRank; ++i) {\n      requiredInputDims[i] = i;\n    }\n  }\n  const unpaddedRank = requiredInputDims.length;\n  for (let i = sourceRank; i < fullRank; ++i) {\n    requiredInputDims.push(i);\n  }\n  const requiredOutputDims = getDependentTransformInputDimensions(\n    modelToLayerTransform.transform,\n    fullRank,\n    requiredInputDims,\n    true,\n  );\n  const subspaceRank = requiredInputDims.length;\n  const modelSubspaceDimensionNames = requiredInputDims.map(\n    (i) => modelDimensionNames[i] || `${i}`,\n  );\n  const layerSubspaceDimensionNames = requiredOutputDims.map(\n    (i) => transformOutputDimensions[i],\n  );\n  if (subspaceRank !== requiredOutputDims.length) {\n    return {\n      error:\n        \"Rank mismatch between model subspace dimensions (\" +\n        modelSubspaceDimensionNames.join(\", \") +\n        \") and corresponding layer/global dimensions (\" +\n        layerSubspaceDimensionNames.join(\", \") +\n        \")\",\n    };\n  }\n  let newTransform = homogeneousTransformSubmatrix(\n    Float32Array,\n    oldTransform,\n    fullRank,\n    requiredOutputDims,\n    requiredInputDims,\n  );\n  const renderLayerDimensions = requiredOutputDims.map(\n    (i) => transformOutputDimensions[i],\n  );\n  const localToRenderLayerDimensions = localCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  const globalToRenderLayerDimensions = globalCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    globalCoordinateSpace,\n    globalToRenderLayerDimensions,\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    localCoordinateSpace,\n    localToRenderLayerDimensions,\n  );\n  const channelToRenderLayerDimensions = channelCoordinateSpace.names.map((x) =>\n    renderLayerDimensions.indexOf(x),\n  );\n  scaleTransformSubmatrix(\n    newTransform,\n    subspaceRank,\n    modelSpace,\n    requiredInputDims,\n    channelCoordinateSpace,\n    channelToRenderLayerDimensions,\n  );\n  const channelToModelSubspaceDimensions: number[] = [];\n  const channelRank = channelCoordinateSpace.rank;\n  if (subsourceEntry !== undefined) {\n    let { subsourceToModelSubspaceTransform } = subsourceEntry;\n    if (unpaddedRank !== subspaceRank) {\n      subsourceToModelSubspaceTransform = matrix.extendHomogeneousTransform(\n        new Float32Array((subspaceRank + 1) ** 2),\n        subspaceRank,\n        subsourceToModelSubspaceTransform,\n        unpaddedRank,\n      );\n    }\n    newTransform = matrix.multiply(\n      new Float32Array((subspaceRank + 1) ** 2),\n      subspaceRank + 1,\n      newTransform,\n      subspaceRank + 1,\n      subsourceToModelSubspaceTransform,\n      subspaceRank + 1,\n      subspaceRank + 1,\n      subspaceRank + 1,\n      subspaceRank + 1,\n    ) as Float32Array<ArrayBuffer>;\n  }\n  const channelSpaceShape = new Uint32Array(channelRank);\n  const {\n    lowerBounds: channelLowerBounds,\n    upperBounds: channelUpperBounds,\n    voxelCenterAtIntegerCoordinates: channelVoxelCenterAtIntegerCoordinates,\n  } = channelCoordinateSpace.bounds;\n  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n    let lower = channelLowerBounds[channelDim];\n    let upper = channelUpperBounds[channelDim];\n    if (channelVoxelCenterAtIntegerCoordinates[channelDim]) {\n      lower += 0.5;\n      upper += 0.5;\n    }\n    if (\n      lower !== 0 ||\n      !Number.isInteger(upper) ||\n      upper <= 0 ||\n      upper >= 2 ** 32\n    ) {\n      return {\n        error:\n          `Channel dimension ${channelCoordinateSpace.names[channelDim]} must have ` +\n          `lower bound of 0 and positive integer upper bound; current bounds are [${lower}, ${upper}]`,\n      };\n    }\n    channelSpaceShape[channelDim] = upper;\n    const layerDim = channelToRenderLayerDimensions[channelDim];\n    let correspondingModelSubspaceDim = -1;\n    if (layerDim !== -1) {\n      for (let chunkDim = 0; chunkDim < subspaceRank; ++chunkDim) {\n        const coeff = newTransform[layerDim + chunkDim * (subspaceRank + 1)];\n        if (coeff === 0) continue;\n        if (coeff !== 1 || correspondingModelSubspaceDim !== -1) {\n          return {\n            error:\n              `Channel dimension ${layerSubspaceDimensionNames[layerDim]} ` +\n              \"must map to a single source dimension\",\n          };\n        }\n        correspondingModelSubspaceDim = chunkDim;\n      }\n    }\n    channelToModelSubspaceDimensions[channelDim] =\n      correspondingModelSubspaceDim;\n  }\n  return {\n    rank: subspaceRank,\n    unpaddedRank,\n    modelDimensionNames: modelSubspaceDimensionNames,\n    layerDimensionNames: layerSubspaceDimensionNames,\n    localToRenderLayerDimensions,\n    globalToRenderLayerDimensions,\n    channelToRenderLayerDimensions,\n    modelToRenderLayerTransform: newTransform,\n    channelToModelDimensions: channelToModelSubspaceDimensions,\n    channelSpaceShape,\n  };\n}\n\nexport function renderLayerTransformsEqual(\n  a: RenderLayerTransformOrError,\n  b: RenderLayerTransformOrError,\n) {\n  if (a === b) return true;\n  if (a.error !== undefined || b.error !== undefined) return false;\n  return (\n    arraysEqual(a.modelDimensionNames, b.modelDimensionNames) &&\n    arraysEqual(a.layerDimensionNames, b.layerDimensionNames) &&\n    arraysEqual(\n      a.globalToRenderLayerDimensions,\n      b.globalToRenderLayerDimensions,\n    ) &&\n    arraysEqual(\n      a.localToRenderLayerDimensions,\n      b.localToRenderLayerDimensions,\n    ) &&\n    arraysEqual(\n      a.channelToRenderLayerDimensions,\n      b.channelToRenderLayerDimensions,\n    ) &&\n    arraysEqual(a.modelToRenderLayerTransform, b.modelToRenderLayerTransform) &&\n    arraysEqual(a.channelSpaceShape, b.channelSpaceShape)\n  );\n}\n\nexport function getWatchableRenderLayerTransform(\n  globalCoordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  localCoordinateSpace: WatchableValueInterface<CoordinateSpace>,\n  modelToLayerTransform: WatchableValueInterface<CoordinateSpaceTransform>,\n  subsourceEntry:\n    | {\n        subsourceToModelSubspaceTransform: Float32Array;\n        modelSubspaceDimensionIndices: readonly number[];\n      }\n    | undefined,\n  channelCoordinateSpace?: WatchableValueInterface<CoordinateSpace | undefined>,\n): CachedWatchableValue<RenderLayerTransformOrError> {\n  return makeCachedDerivedWatchableValue(\n    (\n      globalCoordinateSpace: CoordinateSpace,\n      localCoordinateSpace: CoordinateSpace,\n      modelToLayerTransform: CoordinateSpaceTransform,\n      channelCoordinateSpace: CoordinateSpace | undefined,\n    ) =>\n      getRenderLayerTransform(\n        globalCoordinateSpace,\n        localCoordinateSpace,\n        modelToLayerTransform,\n        subsourceEntry,\n        channelCoordinateSpace,\n      ),\n    [\n      globalCoordinateSpace,\n      localCoordinateSpace,\n      modelToLayerTransform,\n      channelCoordinateSpace === undefined\n        ? constantWatchableValue(undefined)\n        : channelCoordinateSpace,\n    ],\n    renderLayerTransformsEqual,\n  );\n}\n\nexport interface LayerDisplayDimensionMapping {\n  /**\n   * List of indices of layer dimensions that correspond to display dimensions.\n   */\n  layerDisplayDimensionIndices: number[];\n\n  /**\n   * Maps each display dimension index to the corresponding layer dimension index, or `-1`.\n   */\n  displayToLayerDimensionIndices: number[];\n}\n\nexport interface ChunkChannelAccessParameters {\n  channelSpaceShape: Uint32Array;\n\n  /**\n   * Equal to the values in `channelToChunkDimensionIndices` not equal to `-1`.\n   */\n  chunkChannelDimensionIndices: readonly number[];\n\n  /**\n   * Product of `modelTransform.channelSpaceShape`.\n   */\n  numChannels: number;\n\n  /**\n   * Row-major array of shape `[numChannels, chunkChannelDimensionIndices.length]`, specifies the\n   * coordinates within the chunk channel dimensions corresponding to each flat channel index.\n   */\n  chunkChannelCoordinates: Uint32Array;\n}\n\nexport interface ChunkTransformParameters extends ChunkChannelAccessParameters {\n  modelTransform: RenderLayerTransform;\n  chunkToLayerTransform: Float32Array;\n  layerToChunkTransform: Float32Array;\n  chunkToLayerTransformDet: number;\n  /**\n   * Maps channel dimension indices in the layer channel coordinate space to the corresponding chunk\n   * dimension index, or `-1` if there is no correpsonding chunk dimension.\n   */\n  channelToChunkDimensionIndices: readonly number[];\n  combinedGlobalLocalToChunkTransform: Float32Array;\n  combinedGlobalLocalRank: number;\n  layerRank: number;\n}\n\nexport function layerToDisplayCoordinates(\n  displayPosition: vec3,\n  layerPosition: Float32Array,\n  modelTransform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n) {\n  const { globalToRenderLayerDimensions } = modelTransform;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    let v = 0;\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        v = layerPosition[layerDim];\n      }\n    }\n    displayPosition[displayDim] = v;\n  }\n}\n\nexport function displayToLayerCoordinates(\n  layerPosition: Float32Array,\n  displayPosition: vec3,\n  modelTransform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n) {\n  const { globalToRenderLayerDimensions } = modelTransform;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        layerPosition[layerDim] = displayPosition[displayDim];\n      }\n    }\n  }\n}\n\nexport function chunkToDisplayCoordinates(\n  displayPosition: vec3,\n  chunkPosition: Float32Array,\n  chunkTransform: ChunkTransformParameters,\n  displayDimensionIndices: Int32Array,\n): vec3 {\n  const { globalToRenderLayerDimensions } = chunkTransform.modelTransform;\n  const { layerRank, chunkToLayerTransform } = chunkTransform;\n  const stride = layerRank + 1;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    let sum = 0;\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim !== -1) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim !== -1) {\n        sum = chunkToLayerTransform[stride * layerRank + layerDim];\n        for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n          sum +=\n            chunkToLayerTransform[stride * chunkDim + layerDim] *\n            chunkPosition[chunkDim];\n        }\n      }\n    }\n    displayPosition[displayDim] = sum;\n  }\n  return displayPosition;\n}\n\nexport interface ChunkDisplayTransformParameters {\n  modelTransform: RenderLayerTransform;\n  chunkTransform: ChunkTransformParameters;\n  displaySubspaceModelMatrix: mat4;\n  displaySubspaceInvModelMatrix: mat4;\n  chunkDisplayDimensionIndices: number[];\n  numChunkDisplayDims: number;\n}\n\nexport function getChunkTransformParameters(\n  modelTransform: RenderLayerTransform,\n  chunkToModelTransform?: Float32Array,\n): ChunkTransformParameters {\n  const layerRank = modelTransform.rank;\n  const unpaddedRank = modelTransform.unpaddedRank;\n  let chunkToLayerTransform: Float32Array;\n  if (unpaddedRank !== layerRank && chunkToModelTransform !== undefined) {\n    chunkToModelTransform = matrix.extendHomogeneousTransform(\n      new Float32Array((layerRank + 1) ** 2),\n      layerRank,\n      chunkToModelTransform,\n      unpaddedRank,\n    );\n  }\n  if (chunkToModelTransform !== undefined) {\n    chunkToLayerTransform = new Float32Array((layerRank + 1) * (layerRank + 1));\n    matrix.multiply(\n      chunkToLayerTransform,\n      layerRank + 1,\n      modelTransform.modelToRenderLayerTransform,\n      layerRank + 1,\n      chunkToModelTransform,\n      layerRank + 1,\n      layerRank + 1,\n      layerRank + 1,\n      layerRank + 1,\n    );\n  } else {\n    chunkToLayerTransform = modelTransform.modelToRenderLayerTransform;\n  }\n  const layerToChunkTransform = new Float32Array(\n    (layerRank + 1) * (layerRank + 1),\n  );\n  const det = matrix.inverse(\n    layerToChunkTransform,\n    layerRank + 1,\n    chunkToLayerTransform,\n    layerRank + 1,\n    layerRank + 1,\n  );\n  if (det === 0) {\n    throw new Error(\"Transform is singular\");\n  }\n  const {\n    globalToRenderLayerDimensions,\n    localToRenderLayerDimensions,\n    channelToRenderLayerDimensions,\n  } = modelTransform;\n  const globalRank = globalToRenderLayerDimensions.length;\n  const localRank = localToRenderLayerDimensions.length;\n  const combinedGlobalLocalRank = globalRank + localRank;\n\n  // Compute `combinedGlobalLocalToChunkTransform`.\n  const combinedGlobalLocalToChunkTransform = new Float32Array(\n    (combinedGlobalLocalRank + 1) * layerRank,\n  );\n  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      const layerDim = globalToRenderLayerDimensions[globalDim];\n      if (layerDim === -1) continue;\n      combinedGlobalLocalToChunkTransform[chunkDim + globalDim * layerRank] =\n        layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];\n    }\n    for (let localDim = 0; localDim < localRank; ++localDim) {\n      const layerDim = localToRenderLayerDimensions[localDim];\n      if (layerDim === -1) continue;\n      combinedGlobalLocalToChunkTransform[\n        chunkDim + (globalRank + localDim) * layerRank\n      ] = layerToChunkTransform[chunkDim + layerDim * (layerRank + 1)];\n    }\n    combinedGlobalLocalToChunkTransform[\n      chunkDim + combinedGlobalLocalRank * layerRank\n    ] = layerToChunkTransform[chunkDim + layerRank * (layerRank + 1)];\n  }\n\n  const channelRank = channelToRenderLayerDimensions.length;\n  const channelToChunkDimensionIndices = new Array<number>(channelRank);\n  const chunkChannelDimensionIndices: number[] = [];\n  for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n    const layerDim = channelToRenderLayerDimensions[channelDim];\n    let correspondingChunkDim = -1;\n    if (layerDim !== -1) {\n      for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n        const coeff =\n          chunkToLayerTransform[layerDim + chunkDim * (layerRank + 1)];\n        if (coeff === 0) continue;\n        if (coeff !== 1 || correspondingChunkDim !== -1) {\n          throw new Error(\n            `Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` +\n              \"must map with stride 1 to a single data chunk dimensions\",\n          );\n        }\n        correspondingChunkDim = chunkDim;\n      }\n      if (correspondingChunkDim !== -1) {\n        const offset =\n          chunkToLayerTransform[layerDim + layerRank * (layerRank + 1)];\n        if (offset !== 0 && offset !== -0.5) {\n          throw new Error(\n            `Channel dimension ${modelTransform.layerDimensionNames[layerDim]} ` +\n              `must have an offset of 0 in the chunk coordinate space; current offset is ${offset}`,\n          );\n        }\n        chunkChannelDimensionIndices.push(correspondingChunkDim);\n      }\n    }\n    channelToChunkDimensionIndices[channelDim] = correspondingChunkDim;\n  }\n  const { channelSpaceShape } = modelTransform;\n  const numChannels = vector.prod(channelSpaceShape);\n  const chunkChannelRank = chunkChannelDimensionIndices.length;\n  const chunkChannelCoordinates = new Uint32Array(\n    numChannels * chunkChannelRank,\n  );\n  for (let channelIndex = 0; channelIndex < numChannels; ++channelIndex) {\n    let remainder = channelIndex;\n    let chunkChannelDim = 0;\n    for (let channelDim = 0; channelDim < channelRank; ++channelDim) {\n      const coordinate = remainder % channelSpaceShape[channelDim];\n      remainder = (remainder - coordinate) / channelSpaceShape[channelDim];\n      const chunkDim = channelToChunkDimensionIndices[channelDim];\n      if (chunkDim !== -1) {\n        chunkChannelCoordinates[\n          channelIndex * chunkChannelRank + chunkChannelDim\n        ] = coordinate;\n        ++chunkChannelDim;\n      }\n    }\n  }\n  return {\n    layerRank: layerRank,\n    modelTransform,\n    chunkToLayerTransform,\n    layerToChunkTransform,\n    chunkToLayerTransformDet: det,\n    combinedGlobalLocalRank,\n    combinedGlobalLocalToChunkTransform,\n    channelToChunkDimensionIndices,\n    chunkChannelDimensionIndices,\n    numChannels,\n    chunkChannelCoordinates,\n    channelSpaceShape,\n  };\n}\n\nexport function getLayerDisplayDimensionMapping(\n  transform: RenderLayerTransform,\n  displayDimensionIndices: Int32Array,\n): LayerDisplayDimensionMapping {\n  const { globalToRenderLayerDimensions } = transform;\n\n  // List of layer dimension indices corresponding to global display dimensions.\n  const layerDisplayDimensionIndices: number[] = [];\n\n  // Maps global display dimension (in {0, 1, 2}) to the corresponding layer dimension index, or\n  // `-1`.\n  const displayToLayerDimensionIndices: number[] = [];\n\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim === -1) continue;\n    const layerDim = globalToRenderLayerDimensions[globalDim];\n    displayToLayerDimensionIndices.push(layerDim);\n    if (layerDim === -1) continue;\n    layerDisplayDimensionIndices.push(layerDim);\n  }\n  for (let i = displayToLayerDimensionIndices.length; i < 3; ++i) {\n    displayToLayerDimensionIndices[i] = -1;\n  }\n  return { layerDisplayDimensionIndices, displayToLayerDimensionIndices };\n}\n\nexport function getChunkDisplayTransformParameters(\n  chunkTransform: ChunkTransformParameters,\n  layerDisplayDimensionMapping: LayerDisplayDimensionMapping,\n): ChunkDisplayTransformParameters {\n  const { chunkToLayerTransform, modelTransform } = chunkTransform;\n  const rank = modelTransform.rank;\n  const { layerDisplayDimensionIndices, displayToLayerDimensionIndices } =\n    layerDisplayDimensionMapping;\n  const numLayerDisplayDims = layerDisplayDimensionIndices.length;\n  const chunkDisplayDimensionIndices = getDependentTransformInputDimensions(\n    chunkToLayerTransform,\n    rank,\n    layerDisplayDimensionIndices,\n  );\n  if (chunkDisplayDimensionIndices.length !== numLayerDisplayDims) {\n    const { modelDimensionNames, layerDimensionNames } = modelTransform;\n    throw new Error(\n      \"Rank mismatch between displayed layer dimensions \" +\n        `(${Array.from(\n          layerDisplayDimensionIndices,\n          (i) => layerDimensionNames[i],\n        ).join(\",\\u00a0\")}) ` +\n        \"and corresponding chunk dimensions \" +\n        `(${Array.from(\n          chunkDisplayDimensionIndices,\n          (i) => modelDimensionNames[i],\n        ).join(\",\\u00a0\")})`,\n    );\n  }\n  // Compute \"model matrix\" (transform from the displayed subspace of the chunk space) to the global\n  // display coordinate space.\n  const displaySubspaceModelMatrix = mat4.create();\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const layerDim = displayToLayerDimensionIndices[displayDim];\n    if (layerDim === -1) continue;\n    for (\n      let chunkDisplayDimIndex = 0;\n      chunkDisplayDimIndex < numLayerDisplayDims;\n      ++chunkDisplayDimIndex\n    ) {\n      const chunkDim = chunkDisplayDimensionIndices[chunkDisplayDimIndex];\n      displaySubspaceModelMatrix[chunkDisplayDimIndex * 4 + displayDim] =\n        chunkToLayerTransform[chunkDim * (rank + 1) + layerDim];\n    }\n    displaySubspaceModelMatrix[12 + displayDim] =\n      chunkToLayerTransform[rank * (rank + 1) + layerDim];\n  }\n  const displaySubspaceInvModelMatrix = mat4.create();\n  mat4.invert(displaySubspaceInvModelMatrix, displaySubspaceModelMatrix);\n\n  for (let i = chunkDisplayDimensionIndices.length; i < 3; ++i) {\n    chunkDisplayDimensionIndices[i] = -1;\n  }\n  return {\n    modelTransform: chunkTransform.modelTransform,\n    chunkTransform,\n    displaySubspaceModelMatrix,\n    displaySubspaceInvModelMatrix,\n    chunkDisplayDimensionIndices,\n    numChunkDisplayDims: numLayerDisplayDims,\n  };\n}\n\nexport function getChunkPositionFromCombinedGlobalLocalPositions(\n  chunkPosition: Float32Array,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n  layerRank: number,\n  combinedGlobalLocalToChunkTransform: Float32Array,\n) {\n  const globalRank = globalPosition.length;\n  const localRank = localPosition.length;\n  const rank = chunkPosition.length;\n  let valid = true;\n  for (let chunkDim = 0; chunkDim < layerRank; ++chunkDim) {\n    let off = chunkDim;\n    let sum = 0;\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      sum +=\n        combinedGlobalLocalToChunkTransform[off + globalDim * layerRank] *\n        globalPosition[globalDim];\n    }\n    off += globalRank * layerRank;\n    for (let localDim = 0; localDim < localRank; ++localDim) {\n      sum +=\n        combinedGlobalLocalToChunkTransform[off + localDim * layerRank] *\n        localPosition[localDim];\n    }\n    sum += combinedGlobalLocalToChunkTransform[off + localRank * layerRank];\n    if (chunkDim < rank) {\n      chunkPosition[chunkDim] = sum;\n    } else {\n      // Handle clipping\n      if (sum < 0 || sum >= 1) {\n        valid = false;\n      }\n    }\n  }\n  return valid;\n}\n\nexport function getLayerPositionFromCombinedGlobalLocalPositions(\n  layerPosition: Float32Array,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n  modelTransform: RenderLayerTransform,\n) {\n  scatterUpdate(\n    layerPosition,\n    globalPosition,\n    modelTransform.globalToRenderLayerDimensions,\n  );\n  scatterUpdate(\n    layerPosition,\n    localPosition,\n    modelTransform.localToRenderLayerDimensions,\n  );\n  return layerPosition;\n}\n\nexport function get3dModelToDisplaySpaceMatrix(\n  out: mat4,\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo,\n  transform: RenderLayerTransform,\n) {\n  out.fill(0);\n  out[15] = 1;\n  let fullRank = true;\n  const { displayDimensionIndices } = displayDimensionRenderInfo;\n  const { globalToRenderLayerDimensions, modelToRenderLayerTransform } =\n    transform;\n  const layerRank = transform.rank;\n  for (let displayDim = 0; displayDim < 3; ++displayDim) {\n    const globalDim = displayDimensionIndices[displayDim];\n    if (globalDim === -1) {\n      fullRank = false;\n      continue;\n    }\n    const layerDim = globalToRenderLayerDimensions[globalDim];\n    if (layerDim === -1) {\n      fullRank = false;\n      continue;\n    }\n    out[displayDim + 12] =\n      modelToRenderLayerTransform[layerDim + layerRank * (layerRank + 1)];\n    for (let modelDim = 0; modelDim < 3; ++modelDim) {\n      out[displayDim + 4 * modelDim] =\n        modelToRenderLayerTransform[layerDim + (layerRank + 1) * modelDim];\n    }\n  }\n  if (!fullRank) {\n    const { globalDimensionNames } = displayDimensionRenderInfo;\n    const displayDimDesc = Array.from(\n      displayDimensionIndices.filter((i) => i !== -1),\n      (i) => globalDimensionNames[i],\n    ).join(\",\\u00a0\");\n    throw new Error(\n      `Transform from model dimensions (${transform.modelDimensionNames.join(\n        \",\\u00a0\",\n      )}) ` +\n        `to display dimensions (${displayDimDesc}) does not have full rank`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  validateDisplayDimensionRenderInfoProperty,\n  type DisplayDimensionRenderInfo,\n} from \"#src/navigation_state.js\";\nimport { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport { getChunkPositionFromCombinedGlobalLocalPositions } from \"#src/render_coordinate_transform.js\";\nimport { ChunkLayout } from \"#src/sliceview/chunk_layout.js\";\nimport type {\n  WatchableValueChangeInterface,\n  WatchableValueInterface,\n} from \"#src/trackable_value.js\";\nimport { DATA_TYPE_BYTES, DataType } from \"#src/util/data_type.js\";\nimport type { Disposable } from \"#src/util/disposable.js\";\nimport {\n  getFrustrumPlanes,\n  getViewFrustrumDepthRange,\n  isAABBIntersectingPlane,\n  isAABBVisible,\n  mat4,\n  vec3,\n} from \"#src/util/geom.js\";\nimport * as matrix from \"#src/util/matrix.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport { SharedObject } from \"#src/worker_rpc.js\";\n\nexport { DATA_TYPE_BYTES, DataType };\n\nconst DEBUG_VISIBLE_SOURCES = false;\nconst DEBUG_CHUNK_VISIBILITY = false;\n\nconst tempMat4 = mat4.create();\n\n/**\n * Average cross-sectional area contained within a chunk of the specified size and rotation.\n *\n * This is estimated by taking the total volume of the chunk and dividing it by the total length of\n * the chunk along the z axis.\n */\nexport function estimateSliceAreaPerChunk(\n  chunkLayout: ChunkLayout,\n  viewMatrix: mat4,\n) {\n  // Compute the length of the projection of the chunk along the z axis in view space.\n  //\n  // Each chunk dimension `i` can independently affect the z projection by the dot product of column\n  // `i` of `chunkLayout.transform` and row 2 of `viewMatrix`.\n  let viewZProjection = 0;\n  let chunkVolume = Math.abs(chunkLayout.detTransform);\n  const { transform, size } = chunkLayout;\n  for (let i = 0; i < 3; ++i) {\n    let sum = 0;\n    for (let j = 0; j < 3; ++j) {\n      sum += viewMatrix[j * 4 + 2] * transform[4 * i + j];\n    }\n    const s = size[i];\n    viewZProjection += Math.abs(sum) * s;\n    chunkVolume *= s;\n  }\n  return chunkVolume / viewZProjection;\n}\n\nexport interface MultiscaleVolumetricDataRenderLayer {\n  localPosition: WatchableValueInterface<Float32Array>;\n  renderScaleTarget: WatchableValueInterface<number>;\n}\n\nexport interface TransformedSource<\n  RLayer extends MultiscaleVolumetricDataRenderLayer = SliceViewRenderLayer,\n  Source extends SliceViewChunkSource = SliceViewChunkSource,\n> {\n  renderLayer: RLayer;\n\n  source: Source;\n\n  /**\n   * Approximate voxel size in each of the display dimensions.\n   */\n  effectiveVoxelSize: vec3;\n\n  chunkLayout: ChunkLayout;\n\n  /**\n   * Arrays of length `rank` specifying the clip bounds (in voxels) for dimensions not in\n   * `chunkDisplayDimensionIndices` and not channel dimensions.  The values for display/channel\n   * dimensions are set to -/+infinity.\n   */\n  nonDisplayLowerClipBound: Float32Array;\n  nonDisplayUpperClipBound: Float32Array;\n\n  /**\n   * Arrays of length `rank` specifying the clip bounds (in voxels) for all dimensions.\n   */\n  lowerClipBound: Float32Array;\n  upperClipBound: Float32Array;\n\n  // Lower clip bound (in voxels) in the \"display\" subspace of the chunk coordinate space.\n  lowerClipDisplayBound: vec3;\n  // Upper clip bound (in voxels) in the \"display\" subspace of the chunk coordinate space.\n  upperClipDisplayBound: vec3;\n\n  // Lower bound (in chunks) within the \"display\" subspace of the chunk coordinate space.\n  lowerChunkDisplayBound: vec3;\n  // Upper bound (in chunks) within the \"display\" subspace of the chunk coordinate space.\n  upperChunkDisplayBound: vec3;\n\n  /**\n   * Dimensions of the chunk corresponding to the 3 display dimensions of the slice view.\n   */\n  chunkDisplayDimensionIndices: number[];\n\n  /**\n   * Rank of \"layer\" space and the \"chunk clip\" space, which is >= rank of chunk space.\n   */\n  layerRank: number;\n\n  /**\n   * Transform from dimensions of layer space to dimensions of chunk space.\n   *\n   * Matrix has dimensions `(globalRank + localRank + 1) * layerRank`.\n   *\n   * Input space is `[global dimensions, local dimensions]`.  Output space is the \"chunk clip\"\n   * coordinate space, in units of voxels.\n   *\n   */\n  combinedGlobalLocalToChunkTransform: Float32Array;\n\n  /**\n   * Transform from non-display dimensions of layer space to non-display dimensions of chunk space.\n   *\n   * Same as `combinedGlobalLocalToChunkTransform`, except that rows corresponding to \"display\"\n   * chunk dimensions are all 0.\n   *\n   * Matrix has dimensions `(globalRank + localRank + 1) * layerRank`.\n   *\n   * Input space is `[global dimensions, local dimensions]`.  Output space is the \"chunk clip\"\n   * coordinate space, in units of voxels.\n   */\n  fixedLayerToChunkTransform: Float32Array;\n\n  /**\n   * When `computeVisibleChunks` invokes the `addChunk` callback, this is set to the position of the\n   * chunk.\n   */\n  curPositionInChunks: Float32Array;\n\n  fixedPositionWithinChunk: Uint32Array;\n}\n\nexport interface SliceViewRenderLayer {\n  /**\n   * Current position of non-global layer dimensions.\n   */\n  localPosition: WatchableValueInterface<Float32Array>;\n  renderScaleTarget: WatchableValueInterface<number>;\n\n  filterVisibleSources(\n    sliceView: SliceViewBase<SliceViewChunkSource, SliceViewRenderLayer>,\n    sources: readonly TransformedSource[],\n  ): Iterable<TransformedSource>;\n}\n\nfunction updateFixedCurPositionInChunks<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  tsource: TransformedSource<RLayer, SliceViewChunkSource>,\n  globalPosition: Float32Array,\n  localPosition: Float32Array,\n): boolean {\n  const { curPositionInChunks, fixedPositionWithinChunk } = tsource;\n  const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } = tsource;\n  const { rank, chunkDataSize, lowerChunkBound, upperChunkBound } =\n    tsource.source.spec;\n  if (\n    !getChunkPositionFromCombinedGlobalLocalPositions(\n      curPositionInChunks,\n      globalPosition,\n      localPosition,\n      tsource.layerRank,\n      tsource.fixedLayerToChunkTransform,\n    )\n  ) {\n    return false;\n  }\n  // Fraction by which non-display dimensions can be outside clip bounds, to\n  // account for floating-point imprecision.\n  const EPSILON = 1e-3;\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    const x = curPositionInChunks[chunkDim];\n    if (\n      x < nonDisplayLowerClipBound[chunkDim] - EPSILON ||\n      x > nonDisplayUpperClipBound[chunkDim] + EPSILON\n    ) {\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\n          \"excluding source\",\n          tsource,\n          `because of chunkDim=${chunkDim}, sum=${x}`,\n          nonDisplayLowerClipBound,\n          nonDisplayUpperClipBound,\n          tsource.fixedLayerToChunkTransform,\n        );\n      }\n      return false;\n    }\n    const chunkSize = chunkDataSize[chunkDim];\n    // Given that clip bounds are already tested above, clamp chunk index to its\n    // bounds, to ensure floating-point imprecision does not result in an\n    // out-of-bounds index.\n    const chunk = (curPositionInChunks[chunkDim] = Math.min(\n      upperChunkBound[chunkDim] - 1,\n      Math.max(lowerChunkBound[chunkDim], Math.floor(x / chunkSize)),\n    ));\n    fixedPositionWithinChunk[chunkDim] = x - chunk * chunkSize;\n  }\n  return true;\n}\n\nfunction pickBestAlternativeSource<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(viewMatrix: mat4, alternatives: Transformed[]) {\n  const numAlternatives = alternatives.length;\n  let bestAlternativeIndex = 0;\n  if (DEBUG_VISIBLE_SOURCES) {\n    console.log(alternatives);\n  }\n  if (numAlternatives > 1) {\n    let bestSliceArea = 0;\n    for (\n      let alternativeIndex = 0;\n      alternativeIndex < numAlternatives;\n      ++alternativeIndex\n    ) {\n      const alternative = alternatives[alternativeIndex];\n      const { chunkLayout } = alternative;\n      const sliceArea = estimateSliceAreaPerChunk(chunkLayout, viewMatrix);\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\n          `chunksize = ${chunkLayout.size}, sliceArea = ${sliceArea}`,\n        );\n      }\n      if (sliceArea > bestSliceArea) {\n        bestSliceArea = sliceArea;\n        bestAlternativeIndex = alternativeIndex;\n      }\n    }\n  }\n  return bestAlternativeIndex;\n}\n\nexport interface VisibleLayerSources<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n> {\n  allSources: Transformed[][];\n  visibleSources: Transformed[];\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n}\n\nconst tempChunkLayout = new ChunkLayout(vec3.create(), mat4.create(), 0);\n\nexport class SliceViewProjectionParameters extends ProjectionParameters {\n  /**\n   * Normal vector of cross section in (non-isotropic) global voxel coordinates.\n   */\n  viewportNormalInGlobalCoordinates = vec3.create();\n\n  /**\n   * Normal vector of cross section in isotropic global canonical voxel coordinates.\n   */\n  viewportNormalInCanonicalCoordinates = vec3.create();\n\n  centerDataPosition = vec3.create();\n\n  /**\n   * Size in physical units of a single pixel.\n   */\n  pixelSize = 0;\n}\n\nfunction visibleSourcesInvalidated(\n  oldValue: SliceViewProjectionParameters,\n  newValue: SliceViewProjectionParameters,\n) {\n  if (\n    oldValue.displayDimensionRenderInfo !== newValue.displayDimensionRenderInfo\n  ) {\n    return true;\n  }\n  if (oldValue.pixelSize !== newValue.pixelSize) return true;\n  const { viewMatrix: oldViewMatrix } = oldValue;\n  const { viewMatrix: newViewMatrix } = newValue;\n  for (let i = 0; i < 12; ++i) {\n    if (oldViewMatrix[i] !== newViewMatrix[i]) return true;\n  }\n  return false;\n}\n\nexport class SliceViewBase<\n  Source extends SliceViewChunkSource = SliceViewChunkSource,\n  RLayer extends SliceViewRenderLayer = SliceViewRenderLayer,\n  Transformed extends TransformedSource<RLayer, Source> = TransformedSource<\n    RLayer,\n    Source\n  >,\n> extends SharedObject {\n  visibleLayers = new Map<\n    RLayer,\n    VisibleLayerSources<RLayer, Source, Transformed>\n  >();\n  visibleSourcesStale = true;\n\n  constructor(\n    public projectionParameters: WatchableValueChangeInterface<SliceViewProjectionParameters>,\n  ) {\n    super();\n    this.registerDisposer(\n      projectionParameters.changed.add((oldValue, newValue) => {\n        if (visibleSourcesInvalidated(oldValue, newValue)) {\n          this.invalidateVisibleSources();\n        }\n        this.invalidateVisibleChunks();\n      }),\n    );\n  }\n\n  invalidateVisibleSources() {\n    this.visibleSourcesStale = true;\n  }\n\n  invalidateVisibleChunks() {}\n\n  /**\n   * Computes the list of sources to use for each visible layer, based on the\n   * current pixelSize.\n   */\n  updateVisibleSources() {\n    if (!this.visibleSourcesStale) {\n      return;\n    }\n    this.visibleSourcesStale = false;\n    const curDisplayDimensionRenderInfo =\n      this.projectionParameters.value.displayDimensionRenderInfo;\n\n    const { visibleLayers } = this;\n    for (const [renderLayer, visibleLayerSources] of visibleLayers) {\n      const { allSources, visibleSources } = visibleLayerSources;\n      visibleSources.length = 0;\n      if (\n        allSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          visibleLayerSources,\n          curDisplayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n      const preferredOrientationIndex = pickBestAlternativeSource(\n        this.projectionParameters.value.viewMatrix,\n        allSources.map((x) => x[0]),\n      );\n\n      const sources = allSources[preferredOrientationIndex];\n\n      for (const source of renderLayer.filterVisibleSources(this, sources)) {\n        visibleSources.push(source as Transformed);\n      }\n      // Reverse visibleSources list since we added sources from coarsest to finest resolution, but\n      // we want them ordered from finest to coarsest.\n      visibleSources.reverse();\n      if (DEBUG_VISIBLE_SOURCES) {\n        console.log(\"visible sources chosen\", visibleSources);\n      }\n    }\n  }\n}\n\n/**\n * By default, choose a chunk size with at most 2^18 = 262144 voxels.\n */\nexport const DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2 = 18;\n\n/**\n * Specifies common options for getNearIsotropicBlockSize and getTwoDimensionalBlockSize.\n */\nexport interface BaseChunkLayoutOptions {\n  /**\n   * Number of chunk dimensions.\n   */\n  rank: number;\n\n  /**\n   * This, together with upperVoxelBound, specifies the total volume dimensions, which serves as a\n   * bound on the maximum chunk size.  If not specified, defaults to a zero vector.\n   */\n  lowerVoxelBound?: Float32Array;\n\n  /**\n   * Upper voxel bound.  If not specified, the total volume dimensions are not used to bound the\n   * chunk size.\n   */\n  upperVoxelBound?: Float32Array;\n\n  /**\n   * Base 2 logarithm of the maximum number of voxels per chunk.  Defaults to\n   * DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2.\n   */\n  maxVoxelsPerChunkLog2?: number;\n\n  /**\n   * Linear (not affine) transformation matrix with `rank` columns and `displayRank` rows in\n   * column-major order.  Specifies the transformation from chunk space to an isotropic \"camera view\n   * space\".  Note that only relative scales of input dimensions are relevant, any rotations applied\n   * are irrelevant.\n   */\n  chunkToViewTransform: Float32Array;\n  displayRank: number;\n\n  minBlockSize?: Uint32Array;\n  maxBlockSize?: Uint32Array;\n}\n\nexport type GetNearIsotropicBlockSizeOptions = BaseChunkLayoutOptions;\n\n/**\n * Determines a near-isotropic (in camera view space) block size.  All dimensions will be\n * powers of 2, and will not exceed upperVoxelBound - lowerVoxelBound.  The total number of voxels\n * will not exceed maxVoxelsPerChunkLog2.\n */\nexport function getNearIsotropicBlockSize(\n  options: GetNearIsotropicBlockSizeOptions,\n): Uint32Array {\n  let {\n    rank,\n    upperVoxelBound,\n    maxVoxelsPerChunkLog2 = DEFAULT_MAX_VOXELS_PER_CHUNK_LOG2,\n    chunkToViewTransform,\n    displayRank,\n    minBlockSize,\n    maxBlockSize,\n  } = options;\n\n  const { lowerVoxelBound = new Uint32Array(rank) } = options;\n\n  // Adjust voxelSize by effective scaling factor.\n  const effectiveVoxelSize = new Float32Array(rank);\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    let factor = 0;\n    for (let displayDim = 0; displayDim < displayRank; ++displayDim) {\n      const c = chunkToViewTransform[chunkDim * displayRank + displayDim];\n      factor += c * c;\n    }\n    effectiveVoxelSize[chunkDim] = Math.sqrt(factor);\n  }\n\n  const chunkDataSize = new Uint32Array(rank);\n  if (minBlockSize !== undefined) {\n    chunkDataSize.set(minBlockSize);\n  } else {\n    chunkDataSize.fill(1);\n  }\n  const chunkDataSizeUpperBound = new Array<number>(rank);\n  for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n    let bound = Number.POSITIVE_INFINITY;\n    if (effectiveVoxelSize[chunkDim] === 0) {\n      bound = chunkDataSize[chunkDim];\n    } else {\n      if (upperVoxelBound !== undefined) {\n        bound =\n          2 **\n          Math.floor(\n            Math.log2(upperVoxelBound[chunkDim] - lowerVoxelBound[chunkDim]),\n          );\n      }\n      if (maxBlockSize !== undefined) {\n        bound = Math.min(bound, maxBlockSize[chunkDim]);\n      }\n    }\n    chunkDataSizeUpperBound[chunkDim] = bound;\n  }\n\n  // Determine the dimension in which chunkDataSize should be increased.  This is the smallest\n  // dimension (in nanometers) that is < maxChunkDataSize (in voxels).\n  //\n  // Returns -1 if there is no such dimension.\n  function findNextDimension() {\n    let minSize = Infinity;\n    let minDimension = -1;\n    for (let chunkDim = 0; chunkDim < rank; ++chunkDim) {\n      if (chunkDataSize[chunkDim] >= chunkDataSizeUpperBound[chunkDim]) {\n        continue;\n      }\n      const size = chunkDataSize[chunkDim] * effectiveVoxelSize[chunkDim];\n      if (size < minSize) {\n        minSize = size;\n        minDimension = chunkDim;\n      }\n    }\n    return minDimension;\n  }\n\n  maxVoxelsPerChunkLog2 -= Math.log2(vector.prod(chunkDataSize));\n  for (let i = 0; i < maxVoxelsPerChunkLog2; ++i) {\n    const nextDim = findNextDimension();\n    if (nextDim === -1) {\n      break;\n    }\n    chunkDataSize[nextDim] *= 2;\n  }\n  return chunkDataSize;\n}\n\n/**\n * Returns an array of [xy, yz, xz] 2-dimensional block sizes, where [x, y, z] refer to the view\n * dimensions.\n */\nexport function getTwoDimensionalBlockSizes(options: BaseChunkLayoutOptions) {\n  const chunkDataSizes: Uint32Array[] = [];\n  const { displayRank, chunkToViewTransform, rank } = options;\n  if (displayRank > 3) {\n    throw new Error(\"Unsupported view transform\");\n  }\n  if (displayRank < 3) {\n    return [getNearIsotropicBlockSize(options)];\n  }\n  for (let i = 0; i < 3; ++i) {\n    const excludedDim = (i + 2) % 3;\n    const restrictedTransform = new Float32Array(chunkToViewTransform);\n    for (let j = 0; j < rank; ++j) {\n      restrictedTransform[j * displayRank + excludedDim] = 0;\n    }\n    chunkDataSizes[i] = getNearIsotropicBlockSize({\n      ...options,\n      chunkToViewTransform: restrictedTransform,\n    });\n  }\n  return chunkDataSizes;\n}\n\nexport enum ChunkLayoutPreference {\n  /**\n   * Indicates that isotropic chunks are desired.\n   */\n  ISOTROPIC = 0,\n\n  /**\n   * Indicates that 2-D chunks are desired.\n   */\n  FLAT = 1,\n}\n\nexport interface SliceViewSourceOptions {\n  /**\n   * Transform from the multiscale source coordinate space to a \"view\" coordinate space that\n   * reflects the relative scales.  This is a *linear* (not affine) transformation matrix with\n   * `rank` columns and `displayRank` rows in column-major order, where `rank` is the rank of the\n   * multiscale source.\n   */\n  multiscaleToViewTransform: Float32Array;\n  displayRank: number;\n  modelChannelDimensionIndices: readonly number[];\n}\n\nexport function getCombinedTransform(\n  rank: number,\n  bToC: Float32Array,\n  aToB: Float32Array | undefined,\n) {\n  if (aToB === undefined) {\n    return bToC;\n  }\n  return matrix.multiply(\n    new Float32Array((rank + 1) * (rank + 1)),\n    rank + 1,\n    bToC,\n    rank + 1,\n    aToB,\n    rank + 1,\n    rank + 1,\n    rank + 1,\n    rank + 1,\n  );\n}\n\n/**\n * Specifies parameters for getChunkDataSizes.\n */\nexport interface ChunkLayoutOptions {\n  /**\n   * Chunk sizes in voxels.\n   */\n  chunkDataSizes?: Uint32Array[];\n\n  /**\n   * Preferred chunk layout, which determines chunk sizes to use if chunkDataSizes is not\n   * specified.\n   */\n  chunkLayoutPreference?: ChunkLayoutPreference;\n}\n\nexport function getChunkDataSizes(\n  options: ChunkLayoutOptions & BaseChunkLayoutOptions,\n) {\n  if (options.chunkDataSizes !== undefined) {\n    return options.chunkDataSizes;\n  }\n  const { chunkLayoutPreference = ChunkLayoutPreference.ISOTROPIC } = options;\n  switch (chunkLayoutPreference) {\n    case ChunkLayoutPreference.ISOTROPIC:\n      return [getNearIsotropicBlockSize(options)];\n    case ChunkLayoutPreference.FLAT:\n      return getTwoDimensionalBlockSizes(options);\n  }\n}\n\n/**\n * Generic specification for SliceView chunks specifying a layout and voxel size.\n */\nexport interface SliceViewChunkSpecification<\n  ChunkDataSize extends Uint32Array | Float32Array = Uint32Array | Float32Array,\n> {\n  rank: number;\n\n  /**\n   * Size of chunk in voxels.\n   */\n  chunkDataSize: ChunkDataSize;\n\n  /**\n   * All valid chunks are in the range [lowerChunkBound, upperChunkBound).\n   *\n   * These are specified in units of chunks (not voxels).\n   */\n  lowerChunkBound: Float32Array;\n  upperChunkBound: Float32Array;\n\n  lowerVoxelBound: Float32Array;\n  upperVoxelBound: Float32Array;\n}\n\nexport function makeSliceViewChunkSpecification<\n  ChunkDataSize extends Uint32Array | Float32Array,\n>(\n  options: SliceViewChunkSpecificationOptions<ChunkDataSize>,\n): SliceViewChunkSpecification<ChunkDataSize> {\n  const { rank, chunkDataSize, upperVoxelBound } = options;\n  const { lowerVoxelBound = new Float32Array(rank) } = options;\n  const lowerChunkBound = new Float32Array(rank);\n  const upperChunkBound = new Float32Array(rank);\n  for (let i = 0; i < rank; ++i) {\n    lowerChunkBound[i] = Math.floor(lowerVoxelBound[i] / chunkDataSize[i]);\n    upperChunkBound[i] = Math.floor(\n      (upperVoxelBound[i] - 1) / chunkDataSize[i] + 1,\n    );\n  }\n  return {\n    rank,\n    chunkDataSize,\n    lowerChunkBound,\n    upperChunkBound,\n    lowerVoxelBound,\n    upperVoxelBound,\n  };\n}\n\nexport function* filterVisibleSources(\n  sliceView: SliceViewBase,\n  renderLayer: SliceViewRenderLayer,\n  sources: readonly TransformedSource[],\n): Iterable<TransformedSource> {\n  // Increase pixel size by a small margin.\n  const pixelSize = sliceView.projectionParameters.value.pixelSize * 1.1;\n  // At the smallest scale, all alternative sources must have the same voxel size, which is\n  // considered to be the base voxel size.\n  const smallestVoxelSize = sources[0].effectiveVoxelSize;\n\n  const renderScaleTarget = renderLayer.renderScaleTarget.value;\n\n  /**\n   * Determines whether we should continue to look for a finer-resolution source *after* one\n   * with the specified voxelSize.\n   */\n  const canImproveOnVoxelSize = (voxelSize: vec3) => {\n    const targetSize = pixelSize * renderScaleTarget;\n    for (let i = 0; i < 3; ++i) {\n      const size = voxelSize[i];\n      // If size <= pixelSize, no need for improvement.\n      // If size === smallestVoxelSize, also no need for improvement.\n      if (size > targetSize && size > 1.01 * smallestVoxelSize[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const improvesOnPrevVoxelSize = (voxelSize: vec3, prevVoxelSize: vec3) => {\n    const targetSize = pixelSize * renderScaleTarget;\n    for (let i = 0; i < 3; ++i) {\n      const size = voxelSize[i];\n      const prevSize = prevVoxelSize[i];\n      if (\n        Math.abs(targetSize - size) < Math.abs(targetSize - prevSize) &&\n        size < 1.01 * prevSize\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n  let scaleIndex = sources.length - 1;\n  let prevVoxelSize: vec3 | undefined;\n  while (true) {\n    const transformedSource = sources[scaleIndex];\n    if (\n      prevVoxelSize !== undefined &&\n      !improvesOnPrevVoxelSize(\n        transformedSource.effectiveVoxelSize,\n        prevVoxelSize,\n      )\n    ) {\n      break;\n    }\n    yield transformedSource;\n\n    if (\n      scaleIndex === 0 ||\n      !canImproveOnVoxelSize(transformedSource.effectiveVoxelSize)\n    ) {\n      break;\n    }\n    prevVoxelSize = transformedSource.effectiveVoxelSize;\n    --scaleIndex;\n  }\n}\n\n/**\n * Common parameters for SliceView Chunks.\n */\nexport interface SliceViewChunkSpecificationBaseOptions {\n  rank: number;\n\n  /**\n   * If not specified, defaults to an all-zero vector.  This determines lowerChunkBound.  If this is\n   * not a multiple of chunkDataSize, then voxels at lower positions may still be requested.\n   */\n  lowerVoxelBound?: Float32Array;\n\n  /**\n   * Exclusive upper bound in \"chunk\" coordinate space, in voxels.  This determines upperChunkBound.\n   */\n  upperVoxelBound: Float32Array;\n}\n\nexport interface SliceViewChunkSpecificationOptions<\n  ChunkDataSize extends Uint32Array | Float32Array = Uint32Array | Float32Array,\n> extends SliceViewChunkSpecificationBaseOptions {\n  chunkDataSize: ChunkDataSize;\n}\n\nexport interface SliceViewChunkSource<\n  Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n> extends Disposable {\n  spec: Spec;\n}\n\nexport const SLICEVIEW_RPC_ID = \"SliceView\";\nexport const SLICEVIEW_RENDERLAYER_RPC_ID = \"sliceview/RenderLayer\";\nexport const SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID = \"SliceView.addVisibleLayer\";\nexport const SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID =\n  \"SliceView.removeVisibleLayer\";\nexport const SLICEVIEW_REQUEST_CHUNK_RPC_ID = \"ChunkManager.requestChunk\";\n\nconst tempVisibleVolumetricChunkLower = new Float32Array(3);\nconst tempVisibleVolumetricChunkUpper = new Float32Array(3);\nconst tempVisibleVolumetricModelViewProjection = mat4.create();\nconst tempVisibleVolumetricClippingPlanes = new Float32Array(24);\n\nfunction forEachVolumetricChunkWithinFrustrum<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  clippingPlanes: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  callback: (positionInChunks: vec3, clippingPlanes: Float32Array) => void,\n  predicate: (\n    xLower: number,\n    yLower: number,\n    zLower: number,\n    xUpper: number,\n    yUpper: number,\n    zUpper: number,\n    clippingPlanes: Float32Array,\n  ) => boolean,\n) {\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  const { lowerChunkDisplayBound, upperChunkDisplayBound } = transformedSource;\n  for (let i = 0; i < 3; ++i) {\n    lower[i] = Math.max(lower[i], lowerChunkDisplayBound[i]);\n    upper[i] = Math.min(upper[i], upperChunkDisplayBound[i]);\n  }\n  const { curPositionInChunks, chunkDisplayDimensionIndices } =\n    transformedSource;\n\n  function recurse() {\n    if (\n      !predicate(\n        lower[0],\n        lower[1],\n        lower[2],\n        upper[0],\n        upper[1],\n        upper[2],\n        clippingPlanes,\n      )\n    ) {\n      return;\n    }\n\n    let splitDim = 0;\n    let splitSize = Math.max(0, upper[0] - lower[0]);\n    let volume = splitSize;\n    for (let i = 1; i < 3; ++i) {\n      const size = Math.max(0, upper[i] - lower[i]);\n      volume *= size;\n      if (size > splitSize) {\n        splitSize = size;\n        splitDim = i;\n      }\n    }\n    if (volume === 0) return;\n    if (volume === 1) {\n      curPositionInChunks[chunkDisplayDimensionIndices[0]] = lower[0];\n      curPositionInChunks[chunkDisplayDimensionIndices[1]] = lower[1];\n      curPositionInChunks[chunkDisplayDimensionIndices[2]] = lower[2];\n      callback(lower as vec3, clippingPlanes);\n      return;\n    }\n    const prevLower = lower[splitDim];\n    const prevUpper = upper[splitDim];\n    const splitPoint = Math.floor(0.5 * (prevLower + prevUpper));\n    upper[splitDim] = splitPoint;\n    recurse();\n    upper[splitDim] = prevUpper;\n    lower[splitDim] = splitPoint;\n    recurse();\n    lower[splitDim] = prevLower;\n  }\n  recurse();\n}\n\nexport function forEachVisibleVolumetricChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  callback: (positionInChunks: vec3, clippingPlanes: Float32Array) => void,\n) {\n  if (\n    !updateFixedCurPositionInChunks(\n      transformedSource,\n      projectionParameters.globalPosition,\n      localPosition,\n    )\n  ) {\n    return;\n  }\n  const { size: chunkSize } = transformedSource.chunkLayout;\n  const modelViewProjection = mat4.multiply(\n    tempVisibleVolumetricModelViewProjection,\n    projectionParameters.viewProjectionMat,\n    transformedSource.chunkLayout.transform,\n  );\n  for (let i = 0; i < 3; ++i) {\n    const s = chunkSize[i];\n    for (let j = 0; j < 4; ++j) {\n      modelViewProjection[4 * i + j] *= s;\n    }\n  }\n\n  const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n  getFrustrumPlanes(clippingPlanes, modelViewProjection);\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  lower.fill(Number.NEGATIVE_INFINITY);\n  upper.fill(Number.POSITIVE_INFINITY);\n  forEachVolumetricChunkWithinFrustrum(\n    clippingPlanes,\n    transformedSource,\n    callback,\n    isAABBVisible,\n  );\n}\n\nexport function forEachPlaneIntersectingVolumetricChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  transformedSource: TransformedSource<RLayer>,\n  chunkLayout: ChunkLayout,\n  callback: (positionInChunks: vec3) => void,\n) {\n  if (\n    !updateFixedCurPositionInChunks(\n      transformedSource,\n      projectionParameters.globalPosition,\n      localPosition,\n    )\n  ) {\n    return;\n  }\n  const { size: chunkSize } = chunkLayout;\n  const modelViewProjection = mat4.multiply(\n    tempVisibleVolumetricModelViewProjection,\n    projectionParameters.viewProjectionMat,\n    chunkLayout.transform,\n  );\n  for (let i = 0; i < 3; ++i) {\n    const s = chunkSize[i];\n    for (let j = 0; j < 4; ++j) {\n      modelViewProjection[4 * i + j] *= s;\n    }\n  }\n\n  const { upperChunkDisplayBound } = transformedSource;\n\n  const invModelViewProjection = tempMat4;\n  mat4.invert(invModelViewProjection, modelViewProjection);\n  const lower = tempVisibleVolumetricChunkLower;\n  const upper = tempVisibleVolumetricChunkUpper;\n  const BIAS_EPSILON = 1e-4;\n  const BOUND_EPSILON = 1e-3;\n  for (let i = 0; i < 3; ++i) {\n    // Add small offset of `epsilon` voxels to bias towards the higher coordinate if very close to a\n    // voxel boundary.\n    const c = invModelViewProjection[12 + i] + BIAS_EPSILON / chunkSize[i];\n    const xCoeff = Math.abs(invModelViewProjection[i]);\n    const yCoeff = Math.abs(invModelViewProjection[4 + i]);\n\n    const upperBound = upperChunkDisplayBound[i];\n    let lowerValue = c - xCoeff - yCoeff;\n    if (lowerValue >= upperBound && lowerValue < upperBound + BOUND_EPSILON) {\n      // Lower bound of the viewport is within `BOUND_EPSILON` of the upper\n      // chunk bound. Try to ensure that data is still shown in this case.\n      lowerValue = upperBound - 1;\n    } else {\n      lowerValue = Math.floor(lowerValue);\n    }\n    lower[i] = lowerValue;\n    upper[i] = Math.floor(c + xCoeff + yCoeff + 1);\n  }\n\n  const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n  for (let i = 0; i < 3; ++i) {\n    const xCoeff = modelViewProjection[4 * i];\n    const yCoeff = modelViewProjection[4 * i + 1];\n    const zCoeff = modelViewProjection[4 * i + 2];\n    clippingPlanes[i] = xCoeff;\n    clippingPlanes[4 + i] = -xCoeff;\n    clippingPlanes[8 + i] = +yCoeff;\n    clippingPlanes[12 + i] = -yCoeff;\n    clippingPlanes[16 + i] = +zCoeff;\n    clippingPlanes[20 + i] = -zCoeff;\n  }\n  {\n    const i = 3;\n    const xCoeff = modelViewProjection[4 * i];\n    const yCoeff = modelViewProjection[4 * i + 1];\n    const zCoeff = modelViewProjection[4 * i + 2];\n    clippingPlanes[i] = 1 + xCoeff;\n    clippingPlanes[4 + i] = 1 - xCoeff;\n    clippingPlanes[8 + i] = 1 + yCoeff;\n    clippingPlanes[12 + i] = 1 - yCoeff;\n    clippingPlanes[16 + i] = zCoeff;\n    clippingPlanes[20 + i] = -zCoeff;\n  }\n  if (DEBUG_CHUNK_VISIBILITY) {\n    console.log(\"clippingPlanes\", clippingPlanes);\n    console.log(\"modelViewProjection\", modelViewProjection.join(\",\"));\n    console.log(`lower=${lower.join(\",\")}, upper=${upper.join(\",\")}`);\n  }\n  forEachVolumetricChunkWithinFrustrum(\n    clippingPlanes,\n    transformedSource,\n    callback,\n    isAABBIntersectingPlane,\n  );\n}\n\n/**\n * For chunk layouts with finiteRank < 3, returns an adjusted chunk layout where chunk 0 in each\n * non-finite dimension is guaranteed to cover the viewport.\n */\nexport function getNormalizedChunkLayout(\n  projectionParameters: ProjectionParameters,\n  chunkLayout: ChunkLayout,\n): ChunkLayout {\n  const { finiteRank } = chunkLayout;\n  if (finiteRank === 3) return chunkLayout;\n  tempChunkLayout.finiteRank = finiteRank;\n  vec3.copy(tempChunkLayout.size, chunkLayout.size);\n  const transform = mat4.copy(tempChunkLayout.transform, chunkLayout.transform);\n  const invTransform = mat4.copy(\n    tempChunkLayout.invTransform,\n    chunkLayout.invTransform,\n  );\n  tempChunkLayout.detTransform = chunkLayout.detTransform;\n  const { invViewMatrix, width, height } = projectionParameters;\n  const depth = getViewFrustrumDepthRange(projectionParameters.projectionMat);\n  for (let chunkRenderDim = finiteRank; chunkRenderDim < 3; ++chunkRenderDim) {\n    // we want to ensure chunk [0] fully covers the viewport\n    const offset = invViewMatrix[12 + chunkRenderDim];\n    let lower = offset;\n    let upper = offset;\n    const xc = Math.abs(invViewMatrix[chunkRenderDim] * width);\n    lower -= xc;\n    upper += xc;\n    const yc = Math.abs(invViewMatrix[chunkRenderDim + 4] * height);\n    lower -= yc;\n    upper += yc;\n    const zc = Math.abs(invViewMatrix[chunkRenderDim + 8] * depth);\n    lower -= zc;\n    upper += zc;\n    const scaleFactor = Math.max(1, upper - lower);\n    transform[12 + chunkRenderDim] = lower;\n    transform[5 * chunkRenderDim] = scaleFactor;\n  }\n  mat4.invert(invTransform, transform);\n  return tempChunkLayout;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Velocity estimation for prefetching using exponentially-weighted moving estimate of\n * univariate gaussian distribution of per-dimension velocities.\n *\n * Because changes to the global position are not continuous, we estimate the velocity itself using\n * an exponentially-weighted moving average over a relatively short time scale\n * `velocityHalfLifeMilliseconds`, and then estimate a mean and variance of these velocity estimates\n * using an expeonentially-weighted moving average over a longer time scale.\n */\n\nconst VELOCITY_HALF_LIFE_MS = 50;\nconst MODEL_HALF_LIFE_MS = 1000;\n\nexport class VelocityEstimator {\n  private lastTime = Number.NEGATIVE_INFINITY;\n  rank = 0;\n\n  private numSamples = 0;\n\n  // Previous position sampled.\n  private prevPosition = new Float32Array();\n\n  // Moving average of raw velocity over `velocityHalfLifeMilliseconds`.\n  private velocity = new Float32Array();\n\n  // Moving average of `velocity` estimate using `modelHalfLifeMilliseconds`.\n  mean = new Float32Array();\n  // Moving variance of `velocity` estimate using `modelHalfLifeMilliseconds`.\n  variance = new Float32Array();\n\n  constructor(\n    public velocityHalfLifeMilliseconds: number = VELOCITY_HALF_LIFE_MS,\n    public modelHalfLifeMilliseconds: number = MODEL_HALF_LIFE_MS,\n  ) {}\n\n  reset(rank: number) {\n    this.lastTime = Number.NEGATIVE_INFINITY;\n    this.rank = rank;\n    this.numSamples = 0;\n    this.velocity = new Float32Array(rank);\n    this.prevPosition = new Float32Array(rank);\n    this.mean = new Float32Array(rank);\n    this.variance = new Float32Array(rank);\n  }\n\n  addSample(position: Float32Array, time = Date.now()) {\n    const rank = position.length;\n    if (rank !== this.rank) {\n      this.reset(rank);\n    }\n\n    const numSamples = this.numSamples;\n    ++this.numSamples;\n\n    // Update `velocity` estimate.\n    if (this.numSamples === 0) {\n      this.prevPosition.set(position);\n      this.lastTime = time;\n      return;\n    }\n\n    const deltaT = time - this.lastTime;\n    this.lastTime = time;\n    const velocityAlpha =\n      1 - 2 ** -(deltaT / this.velocityHalfLifeMilliseconds);\n    const modelAlpha = 1 - 2 ** -(deltaT / this.modelHalfLifeMilliseconds);\n    const { velocity, prevPosition, mean, variance } = this;\n    for (let i = 0; i < rank; ++i) {\n      const curVelocitySample =\n        (position[i] - prevPosition[i]) / Math.max(deltaT, 1);\n      prevPosition[i] = position[i];\n      const prevVelocity = velocity[i];\n      const newVelocity = (velocity[i] =\n        prevVelocity + velocityAlpha * (curVelocitySample - prevVelocity));\n      if (numSamples === 1) {\n        mean[i] = newVelocity;\n      } else {\n        const meanPrev = mean[i];\n        const varPrev = variance[i];\n        const delta = newVelocity - meanPrev;\n        mean[i] = meanPrev + modelAlpha * delta;\n        variance[i] = (1 - modelAlpha) * (varPrev + modelAlpha * delta * delta);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkRequester } from \"#src/chunk_manager/backend.js\";\nimport {\n  ChunkPriorityTier,\n  PREFETCH_PRIORITY_MULTIPLIER,\n} from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\n/**\n * Mixin for adding a visibility shared property to a ChunkRequester.  Calls\n * `this.chunkManager.scheduleUpdateChunkPriorities()` when visibility changes.\n */\nexport function withSharedVisibility<\n  T extends { new (...args: any[]): ChunkRequester },\n>(Base: T) {\n  return class extends Base {\n    visibility: SharedWatchableValue<number>;\n\n    constructor(...args: any[]) {\n      super(...args);\n      const rpc: RPC = args[0];\n      const options: any = args[1];\n      this.visibility = rpc.get(options.visibility);\n      this.registerDisposer(\n        this.visibility.changed.add(() =>\n          this.chunkManager.scheduleUpdateChunkPriorities(),\n        ),\n      );\n    }\n  };\n}\n\n/**\n * Computes the ChunkPriorityTier for the given `visibility` value.\n *\n * A value of `Number.POSITIVE_INFINITY` means `VISIBLE`.  Any other value means `PREFETCH`.\n */\nexport function getPriorityTier(visibility: number): ChunkPriorityTier {\n  return visibility === Number.POSITIVE_INFINITY\n    ? ChunkPriorityTier.VISIBLE\n    : ChunkPriorityTier.PREFETCH;\n}\n\n/**\n * Computes the base priority for the given `visibility` value.  If the value is\n * `Number.POSTIVE_INFINITY`, corresponding to actual visibility, the base priority is 0.\n * Otherwise, the value is interpreted as the prefetch priority (higher means higher priority), and\n * the base priority is equal to the product of this value and `PREFETCH_PRIORITY_MULTIPLIER`.\n */\nexport function getBasePriority(visibility: number): number {\n  return visibility === Number.POSITIVE_INFINITY\n    ? 0\n    : visibility * PREFETCH_PRIORITY_MULTIPLIER;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/render_layer_backend.js\";\n\nimport type {\n  ChunkConstructor,\n  ChunkRenderLayerBackend,\n} from \"#src/chunk_manager/backend.js\";\nimport {\n  Chunk,\n  ChunkSource,\n  getNextMarkGeneration,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  SliceViewChunkSource as SliceViewChunkSourceInterface,\n  SliceViewChunkSpecification,\n  SliceViewRenderLayer as SliceViewRenderLayerInterface,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport {\n  filterVisibleSources,\n  forEachPlaneIntersectingVolumetricChunk,\n  getNormalizedChunkLayout,\n  SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID,\n  SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID,\n  SLICEVIEW_RENDERLAYER_RPC_ID,\n  SLICEVIEW_REQUEST_CHUNK_RPC_ID,\n  SLICEVIEW_RPC_ID,\n  SliceViewBase,\n} from \"#src/sliceview/base.js\";\nimport { ChunkLayout } from \"#src/sliceview/chunk_layout.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { raceWithAbort } from \"#src/util/abort.js\";\nimport { erf } from \"#src/util/erf.js\";\nimport { vec3, vec3Key } from \"#src/util/geom.js\";\nimport { VelocityEstimator } from \"#src/util/velocity_estimation.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC, RPCPromise } from \"#src/worker_rpc.js\";\nimport {\n  registerPromiseRPC,\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\nimport type { DisplayDimensionRenderInfo } from \"src/navigation_state\";\n\nexport const BASE_PRIORITY = -1e12;\nexport const SCALE_PRIORITY_MULTIPLIER = 1e9;\n\n// Temporary values used by SliceView.updateVisibleChunk\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\n\nclass SliceViewCounterpartBase extends SliceViewBase<\n  SliceViewChunkSourceBackend,\n  SliceViewRenderLayerBackend\n> {\n  constructor(rpc: RPC, options: any) {\n    super(rpc.get(options.projectionParameters));\n    this.initializeSharedObject(rpc, options.id);\n  }\n}\n\nfunction disposeTransformedSources(\n  allSources: TransformedSource<\n    SliceViewRenderLayerBackend,\n    SliceViewChunkSourceBackend\n  >[][],\n) {\n  for (const scales of allSources) {\n    for (const tsource of scales) {\n      tsource.source.dispose();\n    }\n  }\n}\n\nconst SliceViewIntermediateBase = withSharedVisibility(\n  withChunkManager(SliceViewCounterpartBase),\n);\n@registerSharedObject(SLICEVIEW_RPC_ID)\nexport class SliceViewBackend extends SliceViewIntermediateBase {\n  velocityEstimator = new VelocityEstimator();\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateVisibleChunks();\n      }),\n    );\n    this.registerDisposer(\n      this.projectionParameters.changed.add(() => {\n        this.velocityEstimator.addSample(\n          this.projectionParameters.value.globalPosition,\n        );\n      }),\n    );\n  }\n\n  invalidateVisibleChunks() {\n    super.invalidateVisibleChunks();\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  }\n\n  handleLayerChanged = () => {\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  };\n\n  updateVisibleChunks() {\n    const projectionParameters = this.projectionParameters.value;\n    const chunkManager = this.chunkManager;\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.updateVisibleSources();\n    const { centerDataPosition } = projectionParameters;\n    const priorityTier = getPriorityTier(visibility);\n    let basePriority = getBasePriority(visibility);\n    basePriority += BASE_PRIORITY;\n\n    const localCenter = tempCenter;\n\n    const chunkSize = tempChunkSize;\n\n    const curVisibleChunks: SliceViewChunk[] = [];\n    this.velocityEstimator.addSample(\n      this.projectionParameters.value.globalPosition,\n    );\n    for (const [layer, visibleLayerSources] of this.visibleLayers) {\n      chunkManager.registerLayer(layer);\n      const { visibleSources } = visibleLayerSources;\n      for (\n        let i = 0, numVisibleSources = visibleSources.length;\n        i < numVisibleSources;\n        ++i\n      ) {\n        const tsource = visibleSources[i];\n        const prefetchOffsets = chunkManager.queueManager.enablePrefetch.value\n          ? getPrefetchChunkOffsets(this.velocityEstimator, tsource)\n          : [];\n        const { chunkLayout } = tsource;\n        chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n        const { size, finiteRank } = chunkLayout;\n        vec3.copy(chunkSize, size);\n        for (let i = finiteRank; i < 3; ++i) {\n          chunkSize[i] = 0;\n          localCenter[i] = 0;\n        }\n        const priorityIndex = i;\n        const sourceBasePriority =\n          basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;\n        curVisibleChunks.length = 0;\n        const curMarkGeneration = getNextMarkGeneration();\n        forEachPlaneIntersectingVolumetricChunk(\n          projectionParameters,\n          tsource.renderLayer.localPosition.value,\n          tsource,\n          getNormalizedChunkLayout(projectionParameters, tsource.chunkLayout),\n          (positionInChunks) => {\n            vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n            const priority = -vec3.distance(localCenter, tempChunkPosition);\n            const { curPositionInChunks } = tsource;\n            const chunk = tsource.source.getChunk(curPositionInChunks);\n            chunkManager.requestChunk(\n              chunk,\n              priorityTier,\n              sourceBasePriority + priority,\n            );\n            ++layer.numVisibleChunksNeeded;\n            if (chunk.state === ChunkState.GPU_MEMORY) {\n              ++layer.numVisibleChunksAvailable;\n            }\n            curVisibleChunks.push(chunk);\n            // Mark visible chunks to avoid duplicate work when prefetching.  Once we hit a\n            // visible chunk, we don't continue prefetching in the same direction.\n            chunk.markGeneration = curMarkGeneration;\n          },\n        );\n        if (prefetchOffsets.length !== 0) {\n          const { curPositionInChunks } = tsource;\n          for (const visibleChunk of curVisibleChunks) {\n            curPositionInChunks.set(visibleChunk.chunkGridPosition);\n            for (let j = 0, length = prefetchOffsets.length; j < length; ) {\n              const chunkDim = prefetchOffsets[j];\n              const minChunk = prefetchOffsets[j + 2];\n              const maxChunk = prefetchOffsets[j + 3];\n              const newPriority = prefetchOffsets[j + 4];\n              const jumpOffset = prefetchOffsets[j + 5];\n              const oldIndex = curPositionInChunks[chunkDim];\n              const newIndex = oldIndex + prefetchOffsets[j + 1];\n              if (newIndex < minChunk || newIndex > maxChunk) {\n                j = jumpOffset;\n                continue;\n              }\n              curPositionInChunks[chunkDim] = newIndex;\n              const chunk = tsource.source.getChunk(curPositionInChunks);\n              curPositionInChunks[chunkDim] = oldIndex;\n              if (chunk.markGeneration === curMarkGeneration) {\n                j = jumpOffset;\n                continue;\n              }\n              chunkManager.requestChunk(\n                chunk,\n                ChunkPriorityTier.PREFETCH,\n                sourceBasePriority + newPriority,\n              );\n              ++layer.numPrefetchChunksNeeded;\n              if (chunk.state === ChunkState.GPU_MEMORY) {\n                ++layer.numPrefetchChunksAvailable;\n              }\n              j += PREFETCH_ENTRY_SIZE;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  removeVisibleLayer(layer: SliceViewRenderLayerBackend) {\n    const { visibleLayers } = this;\n    const layerInfo = visibleLayers.get(layer)!;\n    visibleLayers.delete(layer);\n    disposeTransformedSources(layerInfo.allSources);\n    layer.renderScaleTarget.changed.remove(this.invalidateVisibleSources);\n    layer.localPosition.changed.remove(this.handleLayerChanged);\n    this.invalidateVisibleSources();\n  }\n\n  addVisibleLayer(\n    layer: SliceViewRenderLayerBackend,\n    allSources: TransformedSource<\n      SliceViewRenderLayerBackend,\n      SliceViewChunkSourceBackend\n    >[][],\n    displayDimensionRenderInfo: DisplayDimensionRenderInfo,\n  ) {\n    let layerInfo = this.visibleLayers.get(layer);\n    if (layerInfo === undefined) {\n      layerInfo = {\n        allSources,\n        visibleSources: [],\n        displayDimensionRenderInfo: displayDimensionRenderInfo,\n      };\n      this.visibleLayers.set(layer, layerInfo);\n      layer.renderScaleTarget.changed.add(() =>\n        this.invalidateVisibleSources(),\n      );\n      layer.localPosition.changed.add(this.handleLayerChanged);\n    } else {\n      disposeTransformedSources(layerInfo.allSources);\n      layerInfo.allSources = allSources;\n      layerInfo.visibleSources.length = 0;\n      layerInfo.displayDimensionRenderInfo = displayDimensionRenderInfo;\n    }\n    this.invalidateVisibleSources();\n  }\n\n  disposed() {\n    for (const layer of this.visibleLayers.keys()) {\n      this.removeVisibleLayer(layer);\n    }\n    super.disposed();\n  }\n\n  invalidateVisibleSources() {\n    super.invalidateVisibleSources();\n    this.chunkManager.scheduleUpdateChunkPriorities();\n  }\n}\n\nexport function deserializeTransformedSources<\n  Source extends SliceViewChunkSourceBackend,\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n>(rpc: RPC, serializedSources: any[][], layer: any) {\n  const sources = serializedSources.map((scales) =>\n    scales.map((serializedSource): TransformedSource<RLayer, Source> => {\n      const source = rpc.getRef<Source>(serializedSource.source);\n      const chunkLayout = serializedSource.chunkLayout;\n      const { rank } = source.spec;\n      const tsource: TransformedSource<RLayer, Source> = {\n        renderLayer: layer,\n        source,\n        chunkLayout: ChunkLayout.fromObject(chunkLayout),\n        layerRank: serializedSource.layerRank,\n        nonDisplayLowerClipBound: serializedSource.nonDisplayLowerClipBound,\n        nonDisplayUpperClipBound: serializedSource.nonDisplayUpperClipBound,\n        lowerClipBound: serializedSource.lowerClipBound,\n        upperClipBound: serializedSource.upperClipBound,\n        lowerClipDisplayBound: serializedSource.lowerClipDisplayBound,\n        upperClipDisplayBound: serializedSource.upperClipDisplayBound,\n        lowerChunkDisplayBound: serializedSource.lowerChunkDisplayBound,\n        upperChunkDisplayBound: serializedSource.upperChunkDisplayBound,\n        effectiveVoxelSize: serializedSource.effectiveVoxelSize,\n        chunkDisplayDimensionIndices:\n          serializedSource.chunkDisplayDimensionIndices,\n        fixedLayerToChunkTransform: serializedSource.fixedLayerToChunkTransform,\n        combinedGlobalLocalToChunkTransform:\n          serializedSource.combinedGlobalLocalToChunkTransform,\n        curPositionInChunks: new Float32Array(rank),\n        fixedPositionWithinChunk: new Uint32Array(rank),\n      };\n      return tsource;\n    }),\n  );\n  return sources;\n}\nregisterRPC(SLICEVIEW_ADD_VISIBLE_LAYER_RPC_ID, function (x) {\n  const obj = <SliceViewBackend>this.get(x.id);\n  const layer = <SliceViewRenderLayerBackend>this.get(x.layerId);\n  const sources = deserializeTransformedSources<\n    SliceViewChunkSourceBackend,\n    SliceViewRenderLayerBackend\n  >(this, x.sources, layer);\n  obj.addVisibleLayer(layer, sources, x.displayDimensionRenderInfo);\n});\nregisterRPC(SLICEVIEW_REMOVE_VISIBLE_LAYER_RPC_ID, function (x) {\n  const obj = <SliceViewBackend>this.get(x.id);\n  const layer = <SliceViewRenderLayerBackend>this.get(x.layerId);\n  obj.removeVisibleLayer(layer);\n});\n\nexport class SliceViewChunk extends Chunk {\n  chunkGridPosition: Float32Array;\n  source: SliceViewChunkSourceBackend | null = null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: Float32Array) {\n    super.initialize(key);\n    this.chunkGridPosition = Float32Array.from(chunkGridPosition);\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.chunkGridPosition = this.chunkGridPosition;\n  }\n\n  downloadSucceeded() {\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {}\n\n  toString() {\n    return this.source!.toString() + \":\" + vec3Key(this.chunkGridPosition);\n  }\n}\n\nexport interface SliceViewChunkSourceBackend<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n  ChunkType extends SliceViewChunk = SliceViewChunk,\n> {\n  // TODO(jbms): Move this declaration to the class definition below and declare abstract once\n  // TypeScript supports mixins with abstact classes.\n  getChunk(chunkGridPosition: vec3): ChunkType;\n\n  chunkConstructor: ChunkConstructor<SliceViewChunk>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class SliceViewChunkSourceBackend<\n    Spec extends SliceViewChunkSpecification = SliceViewChunkSpecification,\n    ChunkType extends SliceViewChunk = SliceViewChunk,\n  >\n  extends ChunkSource\n  implements SliceViewChunkSourceInterface\n{\n  spec: Spec;\n  declare chunks: Map<string, ChunkType>;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.spec = options.spec;\n  }\n\n  getChunk(chunkGridPosition: Float32Array) {\n    const key = chunkGridPosition.join();\n    let chunk = this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(this.chunkConstructor) as ChunkType;\n      chunk.initializeVolumeChunk(key, chunkGridPosition);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(SLICEVIEW_RENDERLAYER_RPC_ID)\nexport class SliceViewRenderLayerBackend\n  extends SharedObjectCounterpart\n  implements SliceViewRenderLayerInterface, ChunkRenderLayerBackend\n{\n  declare rpcId: number;\n  renderScaleTarget: SharedWatchableValue<number>;\n  localPosition: WatchableValueInterface<Float32Array>;\n\n  numVisibleChunksNeeded: number;\n  numVisibleChunksAvailable: number;\n  numPrefetchChunksNeeded: number;\n  numPrefetchChunksAvailable: number;\n  chunkManagerGeneration: number;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    this.numVisibleChunksNeeded = 0;\n    this.numVisibleChunksAvailable = 0;\n    this.numPrefetchChunksAvailable = 0;\n    this.numPrefetchChunksNeeded = 0;\n    this.chunkManagerGeneration = -1;\n  }\n\n  filterVisibleSources(\n    sliceView: SliceViewBase,\n    sources: readonly TransformedSource[],\n  ): Iterable<TransformedSource> {\n    return filterVisibleSources(sliceView, this, sources);\n  }\n}\n\nconst PREFETCH_MS = 2000;\nconst MAX_PREFETCH_VELOCITY = 0.1; // voxels per millisecond\nconst MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS = 32; // Maximum number of chunks to prefetch in a single direction.\n\n// If the probability under the model of needing a chunk within `PREFETCH_MS` is less than this\n// probability, skip prefetching it.\nconst PREFETCH_PROBABILITY_CUTOFF = 0.05;\n\nconst PREFETCH_ENTRY_SIZE = 6;\n\nfunction getPrefetchChunkOffsets(\n  velocityEstimator: VelocityEstimator,\n  tsource: TransformedSource,\n): number[] {\n  const offsets: number[] = [];\n  const globalRank = velocityEstimator.rank;\n  const { combinedGlobalLocalToChunkTransform, layerRank } = tsource;\n\n  const { rank: chunkRank, chunkDataSize } = tsource.source.spec;\n  const { mean: meanVec, variance: varianceVec } = velocityEstimator;\n  for (let chunkDim = 0; chunkDim < chunkRank; ++chunkDim) {\n    const isDisplayDimension =\n      tsource.chunkDisplayDimensionIndices.includes(chunkDim);\n    let mean = 0;\n    let variance = 0;\n    for (let globalDim = 0; globalDim < globalRank; ++globalDim) {\n      const meanValue = meanVec[globalDim];\n      const varianceValue = varianceVec[globalDim];\n      const coeff =\n        combinedGlobalLocalToChunkTransform[globalDim * layerRank + chunkDim];\n      mean += coeff * meanValue;\n      variance += coeff * coeff * varianceValue;\n    }\n    if (mean > MAX_PREFETCH_VELOCITY) {\n      continue;\n    }\n    const chunkSize = chunkDataSize[chunkDim];\n    const initialFraction = isDisplayDimension\n      ? 0\n      : tsource.fixedPositionWithinChunk[chunkDim] / chunkSize;\n    const adjustedMean = (mean / chunkSize) * PREFETCH_MS;\n    let adjustedStddevTimesSqrt2 =\n      (Math.sqrt(2 * variance) / chunkSize) * PREFETCH_MS;\n    if (Math.abs(adjustedMean) < 1e-3 && adjustedStddevTimesSqrt2 < 1e-3) {\n      continue;\n    }\n    adjustedStddevTimesSqrt2 = Math.max(1e-6, adjustedStddevTimesSqrt2);\n    const cdf = (x: number) =>\n      0.5 * (1 + erf((x - adjustedMean) / adjustedStddevTimesSqrt2));\n\n    const curChunk = tsource.curPositionInChunks[chunkDim];\n    const minChunk = Math.floor(tsource.lowerClipBound[chunkDim] / chunkSize);\n    const maxChunk =\n      Math.ceil(tsource.upperClipBound[chunkDim] / chunkSize) - 1;\n    let groupStart = offsets.length;\n    for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {\n      if (!isDisplayDimension && curChunk + i > maxChunk) break;\n      const probability = 1 - cdf(i - initialFraction);\n      // Probability that chunk `curChunk + i` will be needed within `PREFETCH_MS`.\n      if (probability < PREFETCH_PROBABILITY_CUTOFF) break;\n      offsets.push(chunkDim, i, minChunk, maxChunk, probability, 0);\n    }\n    let newGroupStart = offsets.length;\n    for (\n      let i = groupStart, end = offsets.length;\n      i < end;\n      i += PREFETCH_ENTRY_SIZE\n    ) {\n      offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;\n    }\n    groupStart = newGroupStart;\n\n    for (let i = 1; i <= MAX_SINGLE_DIRECTION_PREFETCH_CHUNKS; ++i) {\n      if (!isDisplayDimension && curChunk - i < minChunk) break;\n      const probability = cdf(-i + 1 - initialFraction);\n      // Probability that chunk `curChunk - i` will be needed within `PREFETCH_MS`.\n      if (probability < PREFETCH_PROBABILITY_CUTOFF) break;\n      offsets.push(chunkDim, -i, minChunk, maxChunk, probability, 0);\n    }\n    newGroupStart = offsets.length;\n    for (\n      let i = groupStart, end = offsets.length;\n      i < end;\n      i += PREFETCH_ENTRY_SIZE\n    ) {\n      offsets[i + PREFETCH_ENTRY_SIZE - 1] = newGroupStart;\n    }\n  }\n  return offsets;\n}\n\nregisterPromiseRPC(\n  SLICEVIEW_REQUEST_CHUNK_RPC_ID,\n  async function (\n    x: { this: RPC; source: number; chunkGridPosition: Float32Array },\n    progressOptions,\n  ): RPCPromise<void> {\n    const source = this.get(x.source) as SliceViewChunkSourceBackend;\n    const { chunkManager } = source;\n    const chunk = source.getChunk(x.chunkGridPosition);\n    const key = chunk.key!;\n    if (chunk.state <= ChunkState.SYSTEM_MEMORY) {\n      // Already available on frontend.\n      return { value: undefined };\n    }\n    if (chunk.state === ChunkState.FAILED) {\n      // Already failed\n      throw chunk.error;\n    }\n    const disposeRecompute = chunkManager.recomputeChunkPriorities.add(() => {\n      chunkManager.requestChunk(\n        chunk,\n        ChunkPriorityTier.VISIBLE,\n        Number.POSITIVE_INFINITY,\n        ChunkState.SYSTEM_MEMORY,\n      );\n    });\n    chunkManager.scheduleUpdateChunkPriorities();\n    let listener: (chunk: Chunk) => void;\n    const promise = new Promise<void>((resolve, reject) => {\n      listener = (chunk) => {\n        if (chunk.state === ChunkState.FAILED) {\n          reject(chunk.error);\n          return;\n        }\n        if (chunk.state <= ChunkState.SYSTEM_MEMORY) {\n          resolve();\n        }\n      };\n    });\n    source.registerChunkListener(key, listener!);\n    try {\n      await raceWithAbort(promise, progressOptions.signal);\n      return { value: undefined };\n    } finally {\n      source.unregisterChunkListener(key, listener!);\n      disposeRecompute();\n      chunkManager.scheduleUpdateChunkPriorities();\n    }\n  },\n);\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Simple implementation of the error function\n *\n * https://en.wikipedia.org/wiki/Error_function\n *\n * Precision is 2.5e-5\n */\nexport function erf(x: number) {\n  // Abramowitz and Stegun. Handbook of Mathematical Functions\n  // Formula 7.1.26\n  // http://people.math.sfu.ca/~cbm/aands/frameindex.htm\n  const a1 = 0.254829592;\n  const a2 = -0.284496736;\n  const a3 = 1.421413741;\n  const a4 = -1.453152027;\n  const a5 = 1.061405429;\n  const p = 0.3275911;\n\n  const t = 1 / (1 + p * Math.abs(x));\n  const y =\n    1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n  return Math.sign(x) * y;\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Backend component of PerspectivePanel.  This allows the optional backend component of a\n * PerspectiveViewRenderLayer to set chunk priorities based on the state of the perspective panel.\n */\n\nimport { PERSPECTIVE_VIEW_RPC_ID } from \"#src/perspective_view/base.js\";\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type { RenderedViewBackend } from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(PERSPECTIVE_VIEW_RPC_ID)\nexport class PerspectiveViewBackend\n  extends SharedObjectCounterpart\n  implements RenderedViewBackend\n{\n  visibility: SharedWatchableValue<number>;\n  projectionParameters: SharedWatchableValue<ProjectionParameters>;\n  constructor(...args: any[]) {\n    super(...args);\n    const rpc: RPC = args[0];\n    const options: any = args[1];\n    this.visibility = rpc.get(options.visibility);\n    this.projectionParameters = rpc.get(options.projectionParameters);\n  }\n}\nexport class PerspectiveViewRenderLayerBackend<\n  AttachmentState = unknown,\n> extends RenderLayerBackend<PerspectiveViewBackend, AttachmentState> {}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport { forEachVisibleVolumetricChunk } from \"#src/sliceview/base.js\";\nimport type { VolumeChunkSource } from \"#src/sliceview/volume/base.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport {\n  getViewFrustrumDepthRange,\n  mat3,\n  mat3FromMat4,\n  prod3,\n} from \"#src/util/geom.js\";\n\nexport const VOLUME_RENDERING_RENDER_LAYER_RPC_ID =\n  \"volume_rendering/VolumeRenderingRenderLayer\";\nexport const VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"volume_rendering/VolumeRenderingRenderLayer/update\";\n\nconst DEBUG_CHUNK_LEVEL = false;\n\nconst tempMat3 = mat3.create();\n// const tempMat4 = mat4.create();\n// const tempVisibleVolumetricClippingPlanes = new Float32Array(24);\n\nexport interface HistogramInformation {\n  spatialScales: Map<number, number>;\n  activeIndex: number;\n}\n\nexport function getVolumeRenderingNearFarBounds(\n  clippingPlanes: Float32Array,\n  displayLowerBound: Float32Array,\n  displayUpperBound: Float32Array,\n) {\n  let volumeMinZ = 0;\n  let volumeMaxZ = 0;\n  for (let i = 0; i < 3; ++i) {\n    const planeCoeff = clippingPlanes[16 + i];\n    const a = planeCoeff * displayLowerBound[i];\n    const b = planeCoeff * displayUpperBound[i];\n    volumeMinZ += Math.min(a, b);\n    volumeMaxZ += Math.max(a, b);\n  }\n  const near = -clippingPlanes[19];\n  const adjustedNear = Math.max(near, volumeMinZ);\n  const far = clippingPlanes[23];\n  const adjustedFar = Math.min(far, volumeMaxZ);\n  return { near, far, adjustedNear, adjustedFar };\n}\n\n// Returns target volume in \"world\" space.\n// function getTargetVolume(\n//     tsource: TransformedSource<MultiscaleVolumetricDataRenderLayer>,\n//     projectionParameters: ProjectionParameters) {\n//   const modelViewProjection = mat4.multiply(\n//       tempMat4, projectionParameters.viewProjectionMat, tsource.chunkLayout.transform);\n//   const clippingPlanes = tempVisibleVolumetricClippingPlanes;\n//   getFrustrumPlanes(clippingPlanes, modelViewProjection);\n//   const {near, far} = getVolumeRenderingNearFarBounds(\n//       clippingPlanes, tsource.lowerClipDisplayBound, tsource.upperClipDisplayBound);\n//   if (near === far) return -1;\n//   const depthRange = (far - near);\n//   const targetSpacing = depthRange / volumeRenderingDepthSamples;\n//   const targetVolume = targetSpacing ** 3;\n//   return targetVolume * tsource.chunkLayout.detTransform;\n// }\n\nexport function forEachVisibleVolumeRenderingChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends VolumeChunkSource,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  volumeRenderingDepthSamples: number,\n  transformedSources: readonly Transformed[],\n  beginScale: (\n    source: Transformed,\n    index: number,\n    physicalSpacing: number,\n    optimalSamples: number,\n    clippingPlanes: Float32Array,\n    histogramInformation: HistogramInformation,\n  ) => void,\n  callback: (\n    source: Transformed,\n    index: number,\n    positionInChunks: vec3,\n  ) => void,\n) {\n  if (transformedSources.length === 0) return;\n  const { viewMatrix, projectionMat, displayDimensionRenderInfo } =\n    projectionParameters;\n  const { voxelPhysicalScales } = displayDimensionRenderInfo;\n  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);\n\n  const depthRange = getViewFrustrumDepthRange(projectionMat);\n  // Target voxel spacing in view space\n  const targetViewSpacing = depthRange / volumeRenderingDepthSamples;\n  // Target voxel volume in view space.\n  const targetViewVolume = targetViewSpacing ** 3;\n  const viewDet = mat3.determinant(mat3FromMat4(tempMat3, viewMatrix));\n\n  // Target voxel volume in view space.\n  // const targetViewVolume = getTargetVolume(transformedSources[0], projectionParameters)\n  // *physicalSpacing viewDet;\n\n  const histogramInformation: HistogramInformation = {\n    spatialScales: new Map(),\n    activeIndex: -1,\n  };\n\n  // Returns volume of a single voxel of source `scaleIndex` in \"view\" space.\n  const getViewVolume = (scaleIndex: number) => {\n    const tsource = transformedSources[scaleIndex];\n    return Math.abs(tsource.chunkLayout.detTransform * viewDet);\n  };\n  // Index of high resolution source with voxel volume greater than `targetViewVolume`.\n  // This allows to find the highest resolution source that is not greatly under-sampled.\n  let bestScaleIndex = transformedSources.length - 1;\n  // Voxel volume in \"view\" space of source `bestScaleIndex`.\n  let bestViewVolume = getViewVolume(bestScaleIndex);\n  for (let scaleIndex = bestScaleIndex; scaleIndex >= 0; --scaleIndex) {\n    const viewVolume = getViewVolume(scaleIndex);\n    const physicalSpacing = Math.cbrt(\n      (viewVolume * canonicalToPhysicalScale) / viewDet,\n    );\n    const optimalSamples = depthRange / Math.cbrt(viewVolume);\n    histogramInformation.spatialScales.set(physicalSpacing, optimalSamples);\n    if (viewVolume - targetViewVolume >= 0) {\n      bestViewVolume = viewVolume;\n      bestScaleIndex = scaleIndex;\n    }\n    histogramInformation.activeIndex = bestScaleIndex;\n  }\n\n  if (DEBUG_CHUNK_LEVEL) {\n    console.log(transformedSources);\n    for (\n      let scaleIndex = 0;\n      scaleIndex < transformedSources.length;\n      ++scaleIndex\n    ) {\n      const viewVolume = getViewVolume(scaleIndex);\n      const desiredSamples = depthRange / Math.cbrt(viewVolume);\n      console.log(\n        `scaleIndex=${scaleIndex} viewVolume=${viewVolume} bestScaleIndex=${bestScaleIndex} actualViewVolume=${targetViewVolume}, desiredSamples=${desiredSamples}, difference=${\n          viewVolume - targetViewVolume\n        }`,\n      );\n    }\n  }\n\n  const physicalSpacing = Math.cbrt(\n    (bestViewVolume * canonicalToPhysicalScale) / viewDet,\n  );\n  const optimalSamples = depthRange / Math.cbrt(bestViewVolume);\n  let firstChunk = true;\n  const tsource = transformedSources[bestScaleIndex];\n  forEachVisibleVolumetricChunk(\n    projectionParameters,\n    localPosition,\n    tsource,\n    (positionInChunks, clippingPlanes) => {\n      if (firstChunk) {\n        beginScale(\n          tsource,\n          bestScaleIndex,\n          physicalSpacing,\n          optimalSamples,\n          clippingPlanes,\n          histogramInformation,\n        );\n        firstChunk = false;\n      }\n      callback(tsource, bestScaleIndex, positionInChunks);\n    },\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { withChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { ChunkState } from \"#src/chunk_manager/base.js\";\nimport {\n  type DisplayDimensionRenderInfo,\n  validateDisplayDimensionRenderInfoProperty,\n} from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport {\n  BASE_PRIORITY,\n  deserializeTransformedSources,\n  SCALE_PRIORITY_MULTIPLIER,\n} from \"#src/sliceview/backend.js\";\nimport type { TransformedSource } from \"#src/sliceview/base.js\";\nimport type { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n} from \"#src/visibility_priority/backend.js\";\nimport {\n  forEachVisibleVolumeRenderingChunk,\n  VOLUME_RENDERING_RENDER_LAYER_RPC_ID,\n  VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n} from \"#src/volume_rendering/base.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerRPC, registerSharedObject } from \"#src/worker_rpc.js\";\n\ninterface VolumeRenderingRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSources: TransformedSource<\n    VolumeRenderingRenderLayerBackend,\n    VolumeChunkSource\n  >[][];\n}\n\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\nconst tempCenterDataPosition = vec3.create();\n\n@registerSharedObject(VOLUME_RENDERING_RENDER_LAYER_RPC_ID)\nclass VolumeRenderingRenderLayerBackend extends withChunkManager(\n  RenderLayerBackend,\n) {\n  localPosition: SharedWatchableValue<Float32Array>;\n  // The render scale target for volume rendering is the number of depth samples\n  renderScaleTarget: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      this.localPosition.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      VolumeRenderingRenderLayerAttachmentState\n    >,\n  ) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n      transformedSources: [],\n    };\n  }\n\n  private recomputeChunkPriorities() {\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const state =\n        attachment.state as VolumeRenderingRenderLayerAttachmentState;\n      const { transformedSources } = state;\n\n      if (\n        transformedSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          state,\n          view.projectionParameters.value.displayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n\n      const projectionParameters = view.projectionParameters.value;\n      const priorityTier = getPriorityTier(visibility);\n      let basePriority = getBasePriority(visibility);\n      basePriority += BASE_PRIORITY;\n      const localCenter = tempCenter;\n      const chunkSize = tempChunkSize;\n      const centerDataPosition = tempCenterDataPosition;\n      const {\n        globalPosition,\n        displayDimensionRenderInfo: { displayDimensionIndices },\n      } = projectionParameters;\n      for (let displayDim = 0; displayDim < 3; ++displayDim) {\n        const globalDim = displayDimensionIndices[displayDim];\n        centerDataPosition[displayDim] =\n          globalDim === -1 ? 0 : globalPosition[globalDim];\n      }\n      let sourceBasePriority: number;\n      const { chunkManager } = this;\n      chunkManager.registerLayer(this);\n      forEachVisibleVolumeRenderingChunk(\n        projectionParameters,\n        this.localPosition.value,\n        this.renderScaleTarget.value,\n        transformedSources[0],\n        (tsource, scaleIndex) => {\n          const { chunkLayout } = tsource;\n          chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n          const { size, finiteRank } = chunkLayout;\n          vec3.copy(chunkSize, size);\n          for (let i = finiteRank; i < 3; ++i) {\n            chunkSize[i] = 0;\n            localCenter[i] = 0;\n          }\n          const priorityIndex = transformedSources[0].length - 1 - scaleIndex;\n          sourceBasePriority =\n            basePriority + SCALE_PRIORITY_MULTIPLIER * priorityIndex;\n        },\n        (tsource, _, positionInChunks) => {\n          vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n          const priority = -vec3.distance(localCenter, tempChunkPosition);\n          const chunk = tsource.source.getChunk(tsource.curPositionInChunks);\n          ++this.numVisibleChunksNeeded;\n          chunkManager.requestChunk(\n            chunk,\n            priorityTier,\n            sourceBasePriority + priority,\n          );\n          if (chunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n        },\n      );\n    }\n  }\n}\nVolumeRenderingRenderLayerBackend;\n\nregisterRPC(VOLUME_RENDERING_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {\n  const view = this.get(x.view) as RenderedViewBackend;\n  const layer = this.get(x.layer) as VolumeRenderingRenderLayerBackend;\n  const attachment = layer.attachments.get(\n    view,\n  )! as RenderLayerBackendAttachment<\n    RenderedViewBackend,\n    VolumeRenderingRenderLayerAttachmentState\n  >;\n  attachment.state!.transformedSources = deserializeTransformedSources<\n    VolumeChunkSource,\n    VolumeRenderingRenderLayerBackend\n  >(this, x.sources, layer);\n  attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n  layer.chunkManager.scheduleUpdateChunkPriorities();\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ProjectionParameters } from \"#src/projection_parameters.js\";\nimport type {\n  MultiscaleVolumetricDataRenderLayer,\n  SliceViewChunkSource,\n  SliceViewChunkSpecification,\n  TransformedSource,\n} from \"#src/sliceview/base.js\";\nimport { forEachVisibleVolumetricChunk } from \"#src/sliceview/base.js\";\nimport {\n  getViewFrustrumVolume,\n  mat3,\n  mat3FromMat4,\n  prod3,\n} from \"#src/util/geom.js\";\n\nexport const ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID =\n  \"annotation.MetadataChunkSource\";\nexport const ANNOTATION_GEOMETRY_CHUNK_SOURCE_RPC_ID =\n  \"annotation.GeometryChunkSource\";\nexport const ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID =\n  \"annotation.SubsetGeometryChunkSource\";\nexport const ANNOTATION_REFERENCE_ADD_RPC_ID = \"annotation.reference.add\";\nexport const ANNOTATION_REFERENCE_DELETE_RPC_ID = \"annotation.reference.delete\";\nexport const ANNOTATION_COMMIT_UPDATE_RPC_ID = \"annotation.commit\";\nexport const ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID = \"annotation.commit\";\n\nexport interface AnnotationGeometryChunkSpecification\n  extends SliceViewChunkSpecification {\n  /**\n   * Must equal the `chunkToMultiscaleTransform` in the `SliceViewSingleResolutionSource`.\n   */\n  chunkToMultiscaleTransform: Float32Array;\n\n  /**\n   * Specifies the maximum density of annotations provided by this chunk source, as `limit` per the\n   * chunk volume.  The higher the value, the sooner chunks from this source will be subsampled.  To\n   * disable subsampling completely, set `limit` to 0.\n   */\n  limit: number;\n}\n\nexport const ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID =\n  \"annotation/SpatiallyIndexedRenderLayer\";\nexport const ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"annotation/PerspectiveRenderLayer:updateSources\";\nexport const ANNOTATION_RENDER_LAYER_RPC_ID = \"annotation/RenderLayer\";\nexport const ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID =\n  \"annotation/RenderLayer.updateSegmentation\";\n\nconst tempMat3 = mat3.create();\n\nexport function forEachVisibleAnnotationChunk<\n  RLayer extends MultiscaleVolumetricDataRenderLayer,\n  Source extends SliceViewChunkSource<AnnotationGeometryChunkSpecification>,\n  Transformed extends TransformedSource<RLayer, Source>,\n>(\n  projectionParameters: ProjectionParameters,\n  localPosition: Float32Array,\n  renderScaleTarget: number,\n  transformedSources: readonly Transformed[],\n  beginScale: (source: Transformed, index: number) => void,\n  callback: (\n    source: Transformed,\n    index: number,\n    drawFraction: number,\n    physicalSpacing: number,\n    pixelSpacing: number,\n  ) => void,\n) {\n  const {\n    displayDimensionRenderInfo,\n    viewMatrix,\n    projectionMat,\n    width,\n    height,\n  } = projectionParameters;\n  const { voxelPhysicalScales } = displayDimensionRenderInfo;\n  const viewDet = Math.abs(\n    mat3.determinant(mat3FromMat4(tempMat3, viewMatrix)),\n  );\n  const canonicalToPhysicalScale = prod3(voxelPhysicalScales);\n  const viewFrustrumVolume =\n    (getViewFrustrumVolume(projectionMat) / viewDet) * canonicalToPhysicalScale;\n\n  if (transformedSources.length === 0) return;\n  const baseSource = transformedSources[0];\n  let sourceVolume =\n    Math.abs(baseSource.chunkLayout.detTransform) * canonicalToPhysicalScale;\n  const { lowerClipDisplayBound, upperClipDisplayBound } = baseSource;\n  for (let i = 0; i < 3; ++i) {\n    sourceVolume *= upperClipDisplayBound[i] - lowerClipDisplayBound[i];\n  }\n\n  const effectiveVolume = Math.min(sourceVolume, viewFrustrumVolume);\n  const viewportArea = width * height;\n  const targetNumAnnotations = viewportArea / renderScaleTarget ** 2;\n  const physicalDensityTarget = targetNumAnnotations / effectiveVolume;\n\n  // Target density in annotations per physical volume.\n  let totalPhysicalDensity = 0;\n  for (\n    let scaleIndex = transformedSources.length - 1;\n    scaleIndex >= 0 && totalPhysicalDensity < physicalDensityTarget;\n    --scaleIndex\n  ) {\n    const transformedSource = transformedSources[scaleIndex];\n    const spec = transformedSource.source\n      .spec as AnnotationGeometryChunkSpecification;\n    const { chunkLayout } = transformedSource;\n    const physicalVolume =\n      prod3(chunkLayout.size) *\n      Math.abs(chunkLayout.detTransform) *\n      canonicalToPhysicalScale;\n    const { limit, rank } = spec;\n    const { nonDisplayLowerClipBound, nonDisplayUpperClipBound } =\n      transformedSource;\n    let sliceFraction = 1;\n    for (let i = 0; i < rank; ++i) {\n      const b = nonDisplayUpperClipBound[i] - nonDisplayLowerClipBound[i];\n      if (Number.isFinite(b)) sliceFraction /= b;\n    }\n    const physicalDensity = (limit * sliceFraction) / physicalVolume;\n\n    let firstChunk = true;\n    const newTotalPhysicalDensity = totalPhysicalDensity + physicalDensity;\n    const totalPhysicalSpacing = (1 / newTotalPhysicalDensity) ** (1 / 3);\n    const totalPixelSpacing = Math.sqrt(\n      viewportArea / (newTotalPhysicalDensity * effectiveVolume),\n    );\n    const desiredCount =\n      ((physicalDensityTarget - totalPhysicalDensity) * physicalVolume) /\n      sliceFraction;\n    const drawFraction = Math.min(1, desiredCount / spec.limit);\n    forEachVisibleVolumetricChunk(\n      projectionParameters,\n      localPosition,\n      transformedSource,\n      () => {\n        if (firstChunk) {\n          beginScale(transformedSource, scaleIndex);\n          firstChunk = false;\n        }\n        callback(\n          transformedSource,\n          scaleIndex,\n          drawFraction,\n          totalPhysicalSpacing,\n          totalPixelSpacing,\n        );\n      },\n    );\n    totalPhysicalDensity = newTotalPhysicalDensity;\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { VisibleSegmentEquivalencePolicy } from \"#src/segmentation_graph/segment_id.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { DisjointUint64Sets } from \"#src/util/disjoint_sets.js\";\nimport { parseArray, parseUint64 } from \"#src/util/json.js\";\nimport { NullarySignal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst RPC_TYPE_ID = \"DisjointUint64Sets\";\nconst ADD_METHOD_ID = \"DisjointUint64Sets.add\";\nconst CLEAR_METHOD_ID = \"DisjointUint64Sets.clear\";\nconst HIGH_BIT_REPRESENTATIVE_CHANGED_ID =\n  \"DisjointUint64Sets.highBitRepresentativeChanged\";\nconst DELETE_SET_METHOD_ID = \"DisjointUint64Sets.deleteSet\";\n\n@registerSharedObject(RPC_TYPE_ID)\nexport class SharedDisjointUint64Sets\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<SharedDisjointUint64Sets>\n{\n  disjointSets = new DisjointUint64Sets();\n  changed = new NullarySignal();\n\n  /**\n   * For compatibility with `WatchableValueInterface`.\n   */\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(\n    rpc: RPC,\n    highBitRepresentative: WatchableValueInterface<VisibleSegmentEquivalencePolicy>,\n  ) {\n    const obj = new SharedDisjointUint64Sets();\n    obj.disjointSets.visibleSegmentEquivalencePolicy = highBitRepresentative;\n    obj.registerDisposer(\n      highBitRepresentative.changed.add(() => {\n        updateHighBitRepresentative(obj);\n      }),\n    );\n    obj.initializeCounterpart(rpc);\n    if (highBitRepresentative.value) {\n      updateHighBitRepresentative(obj);\n    }\n    return obj;\n  }\n\n  link(a: bigint, b: bigint) {\n    if (this.disjointSets.link(a, b)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(ADD_METHOD_ID, {\n          id: this.rpcId,\n          a: a,\n          b: b,\n        });\n      }\n      this.changed.dispatch();\n      return true;\n    }\n    return false;\n  }\n\n  linkAll(ids: bigint[]) {\n    for (let i = 1, length = ids.length; i < length; ++i) {\n      this.link(ids[0], ids[i]);\n    }\n  }\n\n  has(x: bigint): boolean {\n    return this.disjointSets.has(x);\n  }\n\n  get(x: bigint): bigint {\n    return this.disjointSets.get(x);\n  }\n\n  clear() {\n    if (this.disjointSets.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(CLEAR_METHOD_ID, { id: this.rpcId });\n      }\n      this.changed.dispatch();\n    }\n  }\n\n  setElements(a: bigint) {\n    return this.disjointSets.setElements(a);\n  }\n\n  deleteSet(x: bigint) {\n    if (this.disjointSets.deleteSet(x)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(DELETE_SET_METHOD_ID, {\n          id: this.rpcId,\n          x,\n        });\n      }\n      this.changed.dispatch();\n    }\n  }\n\n  get size() {\n    return this.disjointSets.size;\n  }\n\n  toJSON() {\n    return this.disjointSets.toJSON();\n  }\n\n  /**\n   * Restores the state from a JSON representation.\n   */\n  restoreState(obj: any) {\n    if (obj !== undefined) {\n      parseArray(obj, (z) => {\n        let prev: bigint | undefined;\n        parseArray(z, (s) => {\n          const cur = parseUint64(s);\n          if (prev !== undefined) {\n            this.link(prev, cur);\n          }\n          prev = cur;\n        });\n      });\n    }\n  }\n\n  assignFrom(other: SharedDisjointUint64Sets | DisjointUint64Sets) {\n    this.clear();\n    if (other instanceof SharedDisjointUint64Sets) {\n      other = other.disjointSets;\n    }\n    for (const [a, b] of other) {\n      this.link(a, b);\n    }\n  }\n}\n\nregisterRPC(ADD_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  if (obj.disjointSets.link(x.a, x.b)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(CLEAR_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  if (obj.disjointSets.clear()) {\n    obj.changed.dispatch();\n  }\n});\n\nfunction updateHighBitRepresentative(obj: SharedDisjointUint64Sets) {\n  obj.rpc!.invoke(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, {\n    id: obj.rpcId,\n    value: obj.disjointSets.visibleSegmentEquivalencePolicy.value,\n  });\n}\n\nregisterRPC(HIGH_BIT_REPRESENTATIVE_CHANGED_ID, function (x) {\n  const obj = this.get(x.id) as SharedDisjointUint64Sets;\n  obj.disjointSets.visibleSegmentEquivalencePolicy.value = x.value;\n});\n\nregisterRPC(DELETE_SET_METHOD_ID, function (x) {\n  const obj = <SharedDisjointUint64Sets>this.get(x.id);\n  if (obj.disjointSets.deleteSet(x.x)) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { hashCombine } from \"#src/gpu_hash/hash_function.js\";\nimport { randomUint64 } from \"#src/util/bigint.js\";\nimport { getRandomValues } from \"#src/util/random.js\";\n\nexport const NUM_ALTERNATIVES = 3;\n\n// For 3 hash functions, a DEFAULT_LOAD_FACTOR of 0.8 reliably avoids\n// expensive rehashing caused by unresolvable collisions.\nconst DEFAULT_LOAD_FACTOR = 0.8;\n\nconst DEBUG = false;\n\n// Key that needs to be inserted.  Temporary variables used during insert.  These can safely be\n// global because control never leaves functions defined in this module while these are in use.\nlet pending = 0n;\nlet backupPending = 0n;\n\nexport abstract class HashTableBase {\n  loadFactor = DEFAULT_LOAD_FACTOR;\n  size = 0;\n  table: BigUint64Array;\n  tableSize: number;\n  empty = 0xffffffffffffffffn;\n  maxRehashAttempts = 5;\n  maxAttempts = 5;\n  capacity: number;\n\n  /**\n   * Number of uint64 elements per entry in hash table.\n   */\n  declare entryStride: number;\n\n  generation = 0;\n\n  mungedEmptyKey: bigint | undefined;\n\n  constructor(\n    public hashSeeds = HashTableBase.generateHashSeeds(NUM_ALTERNATIVES),\n  ) {\n    // Minimum size must be greater than 2 * hashSeeds.length.  Otherwise, tableWithMungedEmptyKey\n    // may loop infinitely.\n    let initialSize = 8;\n    while (initialSize < 2 * hashSeeds.length) {\n      initialSize *= 2;\n    }\n    this.allocate(initialSize);\n  }\n\n  private updateHashFunctions(numHashes: number) {\n    this.hashSeeds = HashTableBase.generateHashSeeds(numHashes);\n    this.mungedEmptyKey = undefined;\n  }\n\n  /**\n   * Invokes callback with a modified version of the hash table data array.\n   *\n   * Replaces all slots that appear to be valid entries for `empty`, i.e. slots that\n   * contain `empty` and to which `empty` hashes, with `mungedEmptyKey`.\n   *\n   * mungedEmptyKey is chosen such that it does not to any of the same slots as `empty`.\n   *\n   * This allows the modified data array to be used for lookups without special casing the empty\n   * key.\n   */\n  tableWithMungedEmptyKey(callback: (table: BigUint64Array) => void) {\n    const numHashes = this.hashSeeds.length;\n    const emptySlots = new Array<number>(numHashes);\n    for (let i = 0; i < numHashes; ++i) {\n      emptySlots[i] = this.getHash(i, this.empty);\n    }\n    let { mungedEmptyKey } = this;\n    if (mungedEmptyKey === undefined) {\n      chooseMungedEmptyKey: while (true) {\n        mungedEmptyKey = randomUint64();\n        for (let i = 0; i < numHashes; ++i) {\n          const h = this.getHash(i, mungedEmptyKey);\n          for (let j = 0; j < numHashes; ++j) {\n            if (emptySlots[j] === h) {\n              continue chooseMungedEmptyKey;\n            }\n          }\n        }\n        this.mungedEmptyKey = mungedEmptyKey;\n        break;\n      }\n    }\n    const { table, empty } = this;\n    for (let i = 0; i < numHashes; ++i) {\n      const h = emptySlots[i];\n      if (table[h] === empty) {\n        table[h] = mungedEmptyKey;\n      }\n    }\n    try {\n      callback(table);\n    } finally {\n      for (let i = 0; i < numHashes; ++i) {\n        const h = emptySlots[i];\n        if (table[h] === mungedEmptyKey) {\n          table[h] = empty;\n        }\n      }\n    }\n  }\n\n  static generateHashSeeds(numAlternatives = NUM_ALTERNATIVES) {\n    return getRandomValues(new Uint32Array(numAlternatives));\n  }\n\n  getHash(hashIndex: number, x: bigint) {\n    let hash = this.hashSeeds[hashIndex];\n    hash = hashCombine(hash, Number(x & 0xffffffffn));\n    hash = hashCombine(hash, Number(x >> 32n));\n    return this.entryStride * (hash & (this.tableSize - 1));\n  }\n\n  /**\n   * Iterates over the uint64 keys contained in the hash set.\n   */\n  *keys(): IterableIterator<bigint> {\n    const { empty, entryStride } = this;\n    const { table } = this;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const key = table[i];\n      if (key !== empty) {\n        yield key;\n      }\n    }\n  }\n\n  /**\n   * Returns the offset into the hash table of the specified element, or -1 if the element is not\n   * present.\n   */\n  indexOf(x: bigint) {\n    const { table, empty } = this;\n    if (x === empty) {\n      return -1;\n    }\n    for (let i = 0, numHashes = this.hashSeeds.length; i < numHashes; ++i) {\n      const h = this.getHash(i, x);\n      if (table[h] === x) {\n        return h;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Changes the empty key to a value that is not equal to the current empty key and is not present\n   * in the table.\n   *\n   * This is called when an attempt is made to insert the empty key.\n   */\n  private chooseAnotherEmptyKey() {\n    const { empty, table, entryStride } = this;\n    let newKey: bigint;\n    while (true) {\n      newKey = randomUint64();\n      if (newKey === empty) {\n        continue;\n      }\n      if (this.has(newKey)) {\n        continue;\n      }\n      break;\n    }\n\n    this.empty = newKey;\n\n    // Replace empty keys in the table.\n    for (let h = 0, length = table.length; h < length; h += entryStride) {\n      if (table[h] === empty) {\n        table[h] = newKey;\n      }\n    }\n  }\n\n  /**\n   * Returns true iff the specified element is present.\n   */\n  has(x: bigint) {\n    return this.indexOf(x) !== -1;\n  }\n\n  delete(x: bigint) {\n    const index = this.indexOf(x);\n    if (index !== -1) {\n      const { table } = this;\n      table[index] = this.empty;\n      ++this.generation;\n      this.size--;\n      return true;\n    }\n    return false;\n  }\n\n  private clearTable() {\n    const { table, empty } = this;\n    table.fill(empty);\n  }\n\n  clear() {\n    if (this.size === 0) {\n      return false;\n    }\n    this.size = 0;\n    ++this.generation;\n    this.clearTable();\n    return true;\n  }\n\n  reserve(x: number) {\n    if (x > this.capacity) {\n      this.backupPending();\n      this.grow(x);\n      this.restorePending();\n      return true;\n    }\n    return false;\n  }\n\n  protected swapPending(table: BigUint64Array, offset: number) {\n    const temp = pending;\n    this.storePending(table, offset);\n    table[offset] = temp;\n  }\n\n  protected storePending(table: BigUint64Array, offset: number) {\n    pending = table[offset];\n  }\n\n  protected backupPending() {\n    backupPending = pending;\n  }\n\n  protected restorePending() {\n    pending = backupPending;\n  }\n\n  private tryToInsert() {\n    if (DEBUG) {\n      console.log(`tryToInsert: ${pending}`);\n    }\n    let attempt = 0;\n    const { empty, maxAttempts, table } = this;\n    const numHashes = this.hashSeeds.length;\n\n    let tableIndex = Math.floor(Math.random() * numHashes);\n    while (true) {\n      const h = this.getHash(tableIndex, pending);\n      this.swapPending(table, h);\n      if (pending === empty) {\n        return true;\n      }\n      if (++attempt === maxAttempts) {\n        break;\n      }\n      tableIndex =\n        (tableIndex + Math.floor(Math.random() * (numHashes - 1)) + 1) %\n        numHashes;\n    }\n    return false;\n  }\n\n  private allocate(tableSize: number) {\n    this.tableSize = tableSize;\n    const { entryStride } = this;\n    this.table = new BigUint64Array(tableSize * entryStride);\n    this.maxAttempts = tableSize;\n    this.clearTable();\n    this.capacity = tableSize * this.loadFactor;\n    this.mungedEmptyKey = undefined;\n  }\n\n  private rehash(oldTable: BigUint64Array, tableSize: number) {\n    if (DEBUG) {\n      console.log(\"rehash begin\");\n    }\n    this.allocate(tableSize);\n    this.updateHashFunctions(this.hashSeeds.length);\n    const { empty, entryStride } = this;\n    for (let h = 0, length = oldTable.length; h < length; h += entryStride) {\n      const key = oldTable[h];\n      if (key !== empty) {\n        this.storePending(oldTable, h);\n        if (!this.tryToInsert()) {\n          if (DEBUG) {\n            console.log(\"rehash failed\");\n          }\n          return false;\n        }\n      }\n    }\n    if (DEBUG) {\n      console.log(\"rehash end\");\n    }\n    return true;\n  }\n\n  private grow(desiredTableSize: number) {\n    if (DEBUG) {\n      console.log(`grow: ${desiredTableSize}`);\n    }\n    const oldTable = this.table;\n    let { tableSize } = this;\n    while (tableSize < desiredTableSize) {\n      tableSize *= 2;\n    }\n    while (true) {\n      for (\n        let rehashAttempt = 0;\n        rehashAttempt < this.maxRehashAttempts;\n        ++rehashAttempt\n      ) {\n        if (this.rehash(oldTable, tableSize)) {\n          if (DEBUG) {\n            console.log(\"grow end\");\n          }\n          return;\n        }\n      }\n      tableSize *= 2;\n    }\n  }\n\n  protected insertInternal() {\n    ++this.generation;\n\n    if (pending === this.empty) {\n      this.chooseAnotherEmptyKey();\n    }\n\n    if (++this.size > this.capacity) {\n      this.backupPending();\n      this.grow(this.tableSize * 2);\n      this.restorePending();\n    }\n\n    while (!this.tryToInsert()) {\n      this.backupPending();\n      this.grow(this.tableSize);\n      this.restorePending();\n    }\n  }\n}\n\nexport class HashSetUint64 extends HashTableBase {\n  add(x: bigint) {\n    if (this.has(x)) {\n      return false;\n    }\n    if (DEBUG) {\n      console.log(`add: ${x}`);\n    }\n    pending = x;\n    this.insertInternal();\n    return true;\n  }\n\n  /**\n   * Iterates over the keys.\n   */\n  [Symbol.iterator]() {\n    return this.keys();\n  }\n}\nHashSetUint64.prototype.entryStride = 1;\n\n// Value that needs to be inserted.  Temporary variables used during insert.  These can safely be\n// global because control never leaves functions defined in this module while these are in use.\nlet pendingValue = 0n;\nlet backupPendingValue = 0n;\n\nexport class HashMapUint64 extends HashTableBase {\n  set(key: bigint, value: bigint) {\n    if (this.has(key)) {\n      return false;\n    }\n    if (DEBUG) {\n      console.log(`add: ${key} -> ${value}`);\n    }\n    pending = key;\n    pendingValue = value;\n    this.insertInternal();\n    return true;\n  }\n\n  get(key: bigint): bigint | undefined {\n    const h = this.indexOf(key);\n    if (h === -1) {\n      return undefined;\n    }\n    return this.table[h + 1];\n  }\n\n  protected swapPending(table: BigUint64Array, offset: number) {\n    const temp = pendingValue;\n    super.swapPending(table, offset);\n    table[offset + 1] = temp;\n  }\n\n  protected storePending(table: BigUint64Array, offset: number) {\n    super.storePending(table, offset);\n    pendingValue = table[offset + 1];\n  }\n\n  protected backupPending() {\n    super.backupPending();\n    backupPendingValue = pendingValue;\n  }\n\n  protected restorePending() {\n    super.restorePending();\n    pendingValue = backupPendingValue;\n  }\n\n  /**\n   * Iterates over entries.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Iterates over entries.\n   */\n  *entries() {\n    const { empty, entryStride } = this;\n    const { table } = this;\n    for (let i = 0, length = table.length; i < length; i += entryStride) {\n      const key = table[i];\n      if (key !== empty) {\n        const value = table[i + 1];\n        yield [key, value];\n      }\n    }\n  }\n}\nHashMapUint64.prototype.entryStride = 2;\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2019 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HashMapUint64 } from \"#src/gpu_hash/hash_table.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(\"Uint64Map\")\nexport class Uint64Map\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<Uint64Map>\n{\n  hashTable = new HashMapUint64();\n  changed = new Signal<(x: bigint | null, add: boolean) => void>();\n\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(rpc: RPC) {\n    const obj = new Uint64Map();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  set_(key: bigint, value: bigint) {\n    return this.hashTable.set(key, value);\n  }\n\n  set(key: bigint, value: bigint) {\n    if (this.set_(key, value)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.set\", { id: this.rpcId, key: key, value: value });\n      }\n      this.changed.dispatch(key, true);\n    }\n  }\n\n  has(key: bigint) {\n    return this.hashTable.has(key);\n  }\n\n  get(key: bigint): bigint | undefined {\n    return this.hashTable.get(key);\n  }\n\n  [Symbol.iterator]() {\n    return this.hashTable.entries();\n  }\n\n  delete_(key: bigint) {\n    return this.hashTable.delete(key);\n  }\n\n  delete(key: bigint) {\n    if (this.delete_(key)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.delete\", { id: this.rpcId, key: key });\n      }\n      this.changed.dispatch(key, false);\n    }\n  }\n\n  get size() {\n    return this.hashTable.size;\n  }\n\n  assignFrom(other: Uint64Map) {\n    this.clear();\n    for (const [key, value] of other) {\n      this.set(key, value);\n    }\n  }\n\n  clear() {\n    if (this.hashTable.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Map.clear\", { id: this.rpcId });\n      }\n      this.changed.dispatch(null, false);\n    }\n  }\n\n  toJSON() {\n    const result: { [key: string]: string } = {};\n    for (const [key, value] of this.hashTable.entries()) {\n      result[key.toString()] = value.toString();\n    }\n    return result;\n  }\n}\n\nregisterRPC(\"Uint64Map.set\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.set_(x.key, x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Map.delete\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.delete_(x.key)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Map.clear\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.hashTable.clear()) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HashSetUint64 } from \"#src/gpu_hash/hash_table.js\";\nimport type { WatchableValueInterface } from \"#src/trackable_value.js\";\nimport { Signal } from \"#src/util/signal.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\n@registerSharedObject(\"Uint64Set\")\nexport class Uint64Set\n  extends SharedObjectCounterpart\n  implements WatchableValueInterface<Uint64Set>\n{\n  hashTable = new HashSetUint64();\n  changed = new Signal<\n    (x: bigint | bigint[] | BigUint64Array | null, add: boolean) => void\n  >();\n\n  get value() {\n    return this;\n  }\n\n  static makeWithCounterpart(rpc: RPC) {\n    const obj = new Uint64Set();\n    obj.initializeCounterpart(rpc);\n    return obj;\n  }\n\n  set(x: bigint | bigint[] | BigUint64Array, value: boolean) {\n    if (!value) {\n      this.delete(x);\n    } else {\n      this.add(x);\n    }\n  }\n\n  reserve_(x: number) {\n    return this.hashTable.reserve(x);\n  }\n\n  reserve(x: number) {\n    if (this.reserve_(x)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.reserve\", { id: this.rpcId, value: x });\n      }\n    }\n  }\n\n  add_(x: bigint[] | BigUint64Array) {\n    let changed = false;\n    for (const v of x) {\n      changed = this.hashTable.add(v) || changed;\n    }\n    return changed;\n  }\n\n  add(x: bigint | bigint[] | BigUint64Array) {\n    const tmp = typeof x === \"bigint\" ? [x] : x;\n    if (this.add_(tmp)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.add\", { id: this.rpcId, value: tmp });\n      }\n      this.changed.dispatch(x, true);\n    }\n  }\n\n  has(x: bigint) {\n    return this.hashTable.has(x);\n  }\n\n  [Symbol.iterator]() {\n    return this.hashTable.keys();\n  }\n\n  keys() {\n    return this.hashTable.keys();\n  }\n\n  delete_(x: bigint[] | BigUint64Array) {\n    let changed = false;\n    for (const v of x) {\n      changed = this.hashTable.delete(v) || changed;\n    }\n    return changed;\n  }\n\n  delete(x: bigint | bigint[] | BigUint64Array) {\n    const tmp = typeof x === \"bigint\" ? [x] : x;\n    if (this.delete_(tmp)) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.delete\", { id: this.rpcId, value: tmp });\n      }\n      this.changed.dispatch(x, false);\n    }\n  }\n\n  get size() {\n    return this.hashTable.size;\n  }\n\n  clear() {\n    if (this.hashTable.clear()) {\n      const { rpc } = this;\n      if (rpc) {\n        rpc.invoke(\"Uint64Set.clear\", { id: this.rpcId });\n      }\n      this.changed.dispatch(null, false);\n    }\n  }\n\n  toJSON() {\n    const result = new Array<string>();\n    for (const id of this.keys()) {\n      result.push(id.toString());\n    }\n    // Need to sort entries, otherwise serialization changes every time.\n    result.sort();\n    return result;\n  }\n\n  assignFrom(other: Uint64Set) {\n    this.clear();\n    for (const key of other.keys()) {\n      this.add(key);\n    }\n  }\n}\n\nregisterRPC(\"Uint64Set.reserve\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.reserve_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.add\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.add_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.delete\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.delete_(x.value)) {\n    obj.changed.dispatch();\n  }\n});\n\nregisterRPC(\"Uint64Set.clear\", function (x) {\n  const obj = this.get(x.id);\n  if (obj.hashTable.clear()) {\n    obj.changed.dispatch();\n  }\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VisibleSegmentEquivalencePolicy } from \"#src/segmentation_graph/segment_id.js\";\nimport type { SharedDisjointUint64Sets } from \"#src/shared_disjoint_sets.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { Uint64OrderedSet } from \"#src/uint64_ordered_set.js\";\nimport type { Uint64Set } from \"#src/uint64_set.js\";\nimport type { RefCounted } from \"#src/util/disposable.js\";\n\nexport interface VisibleSegmentsState {\n  visibleSegments: Uint64Set;\n  selectedSegments: Uint64OrderedSet;\n  segmentEquivalences: SharedDisjointUint64Sets;\n\n  // Specifies a temporary/alternative set of segments/equivalences to use for display purposes,\n  // used for previewing a merge/split.\n  temporaryVisibleSegments: Uint64Set;\n  temporarySegmentEquivalences: SharedDisjointUint64Sets;\n  useTemporaryVisibleSegments: SharedWatchableValue<boolean>;\n  useTemporarySegmentEquivalences: SharedWatchableValue<boolean>;\n}\n\nexport const VISIBLE_SEGMENTS_STATE_PROPERTIES = [\n  \"visibleSegments\",\n  \"segmentEquivalences\",\n  \"temporaryVisibleSegments\",\n  \"temporarySegmentEquivalences\",\n  \"useTemporaryVisibleSegments\",\n  \"useTemporarySegmentEquivalences\",\n] as const;\n\nexport function onVisibleSegmentsStateChanged(\n  context: RefCounted,\n  state: VisibleSegmentsState,\n  callback: () => void,\n) {\n  context.registerDisposer(state.visibleSegments.changed.add(callback));\n  context.registerDisposer(state.segmentEquivalences.changed.add(callback));\n}\n\nexport function onTemporaryVisibleSegmentsStateChanged(\n  context: RefCounted,\n  state: VisibleSegmentsState,\n  callback: () => void,\n) {\n  context.registerDisposer(\n    state.temporaryVisibleSegments.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.temporarySegmentEquivalences.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.useTemporaryVisibleSegments.changed.add(callback),\n  );\n  context.registerDisposer(\n    state.useTemporarySegmentEquivalences.changed.add(callback),\n  );\n}\n\n/**\n * Returns a string key for identifying a uint64 object id.\n */\nexport function getObjectKey(objectId: bigint): string {\n  return objectId.toString();\n}\n\nfunction isHighBitSegment(segmentId: bigint): boolean {\n  return (segmentId & 0x8000000000000000n) !== 0n;\n}\n\nexport function getVisibleSegments(state: VisibleSegmentsState) {\n  return state.useTemporaryVisibleSegments.value\n    ? state.temporaryVisibleSegments\n    : state.visibleSegments;\n}\n\nexport function getSegmentEquivalences(state: VisibleSegmentsState) {\n  return state.useTemporarySegmentEquivalences.value\n    ? state.temporarySegmentEquivalences\n    : state.segmentEquivalences;\n}\n\nexport function forEachVisibleSegment(\n  state: VisibleSegmentsState,\n  callback: (objectId: bigint, rootObjectId: bigint) => void,\n) {\n  const visibleSegments = getVisibleSegments(state);\n  const segmentEquivalences = getSegmentEquivalences(state);\n  const equivalencePolicy =\n    segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy.value;\n  for (const rootObjectId of visibleSegments.keys()) {\n    if (\n      equivalencePolicy &\n      VisibleSegmentEquivalencePolicy.NONREPRESENTATIVE_EXCLUDED\n    ) {\n      const rootObjectId2 = segmentEquivalences.get(rootObjectId);\n      callback(rootObjectId, rootObjectId2);\n    } else {\n      // TODO(jbms): Remove this check if logic is added to ensure that it always holds.\n      if (!segmentEquivalences.disjointSets.isMinElement(rootObjectId)) {\n        continue;\n      }\n      for (const objectId of segmentEquivalences.setElements(rootObjectId)) {\n        if (\n          equivalencePolicy &\n            VisibleSegmentEquivalencePolicy.REPRESENTATIVE_EXCLUDED &&\n          equivalencePolicy &\n            VisibleSegmentEquivalencePolicy.MAX_REPRESENTATIVE &&\n          isHighBitSegment(objectId)\n        ) {\n          continue;\n        }\n        callback(objectId, rootObjectId);\n      }\n    }\n  }\n}\n\nexport interface IndexedSegmentProperty {\n  id: string;\n  type: \"string\";\n  description: string | undefined;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Import to register the shared object types.\nimport \"#src/shared_disjoint_sets.js\";\nimport \"#src/uint64_map.js\";\nimport \"#src/uint64_set.js\";\n\nimport type { ChunkRequester } from \"#src/chunk_manager/backend.js\";\nimport { ChunkSource } from \"#src/chunk_manager/backend.js\";\nimport type { RenderLayerTransformOrError } from \"#src/render_coordinate_transform.js\";\nimport type {\n  IndexedSegmentProperty,\n  VisibleSegmentsState,\n} from \"#src/segmentation_display_state/base.js\";\nimport {\n  onTemporaryVisibleSegmentsStateChanged,\n  onVisibleSegmentsStateChanged,\n  VISIBLE_SEGMENTS_STATE_PROPERTIES,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { SharedDisjointUint64Sets } from \"#src/shared_disjoint_sets.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { Uint64OrderedSet } from \"#src/uint64_ordered_set.js\";\nimport type { Uint64Set } from \"#src/uint64_set.js\";\nimport type { AnyConstructor } from \"#src/util/mixin.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\nexport function receiveVisibleSegmentsState(\n  rpc: RPC,\n  options: any,\n  target: VisibleSegmentsState = {} as VisibleSegmentsState,\n): VisibleSegmentsState {\n  // No need to increase the reference count of these properties since our owner will hold a\n  // reference to their owners.\n  for (const property of VISIBLE_SEGMENTS_STATE_PROPERTIES) {\n    target[property] = rpc.get(options[property]);\n  }\n  return target;\n}\n\nexport const withSegmentationLayerBackendState = <\n  TBase extends AnyConstructor<ChunkRequester>,\n>(\n  Base: TBase,\n) =>\n  class SegmentationLayerState extends Base implements VisibleSegmentsState {\n    visibleSegments: Uint64Set;\n    selectedSegments: Uint64OrderedSet;\n    segmentEquivalences: SharedDisjointUint64Sets;\n    temporaryVisibleSegments: Uint64Set;\n    temporarySegmentEquivalences: SharedDisjointUint64Sets;\n    useTemporaryVisibleSegments: SharedWatchableValue<boolean>;\n    useTemporarySegmentEquivalences: SharedWatchableValue<boolean>;\n    transform: SharedWatchableValue<RenderLayerTransformOrError>;\n    renderScaleTarget: SharedWatchableValue<number>;\n    constructor(...args: any[]) {\n      const [rpc, options] = args as [RPC, any];\n      super(rpc, options);\n      receiveVisibleSegmentsState(rpc, options, this);\n      this.transform = rpc.get(options.transform);\n      this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n\n      const scheduleUpdateChunkPriorities = () => {\n        this.chunkManager.scheduleUpdateChunkPriorities();\n      };\n      onTemporaryVisibleSegmentsStateChanged(\n        this,\n        this,\n        scheduleUpdateChunkPriorities,\n      );\n      onVisibleSegmentsStateChanged(this, this, scheduleUpdateChunkPriorities);\n      this.registerDisposer(\n        this.transform.changed.add(scheduleUpdateChunkPriorities),\n      );\n      this.registerDisposer(\n        this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n      );\n    }\n  };\n\nexport class IndexedSegmentPropertySourceBackend extends ChunkSource {\n  properties: readonly Readonly<IndexedSegmentProperty>[];\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.properties = options.properties;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AnnotationGeometryChunkSpecification } from \"#src/annotation/base.js\";\nimport {\n  ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID,\n  ANNOTATION_COMMIT_UPDATE_RPC_ID,\n  ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID,\n  ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  ANNOTATION_REFERENCE_ADD_RPC_ID,\n  ANNOTATION_REFERENCE_DELETE_RPC_ID,\n  ANNOTATION_RENDER_LAYER_RPC_ID,\n  ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID,\n  ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID,\n  ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID,\n  forEachVisibleAnnotationChunk,\n} from \"#src/annotation/base.js\";\nimport type {\n  Annotation,\n  AnnotationId,\n  SerializedAnnotations,\n} from \"#src/annotation/index.js\";\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport {\n  Chunk,\n  ChunkRenderLayerBackend,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport { validateDisplayDimensionRenderInfoProperty } from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport { receiveVisibleSegmentsState } from \"#src/segmentation_display_state/backend.js\";\nimport type { VisibleSegmentsState } from \"#src/segmentation_display_state/base.js\";\nimport {\n  forEachVisibleSegment,\n  getObjectKey,\n  onTemporaryVisibleSegmentsStateChanged,\n  onVisibleSegmentsStateChanged,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport {\n  deserializeTransformedSources,\n  SCALE_PRIORITY_MULTIPLIER,\n  SliceViewChunk,\n  SliceViewChunkSourceBackend,\n} from \"#src/sliceview/backend.js\";\nimport type { TransformedSource } from \"#src/sliceview/base.js\";\nimport { registerNested, WatchableValue } from \"#src/trackable_value.js\";\nimport type { Borrowed } from \"#src/util/disposable.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport {\n  registerRPC,\n  registerSharedObject,\n  SharedObjectCounterpart,\n} from \"#src/worker_rpc.js\";\n\nconst ANNOTATION_METADATA_CHUNK_PRIORITY = 200;\nconst ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY = 60;\n\nexport class AnnotationMetadataChunk extends Chunk {\n  annotation: Annotation | undefined | null;\n  freeSystemMemory() {\n    this.annotation = undefined;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.annotation = this.annotation;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n  }\n}\n\nexport class AnnotationGeometryData implements SerializedAnnotations {\n  data: Uint8Array<ArrayBuffer>;\n  typeToOffset: number[];\n  typeToIds: string[][];\n  typeToIdMaps: Map<string, number>[];\n\n  serialize(msg: any, transfers: any[]) {\n    msg.data = this.data;\n    msg.typeToOffset = this.typeToOffset;\n    msg.typeToIds = this.typeToIds;\n    msg.typeToIdMaps = this.typeToIdMaps;\n    transfers.push(this.data.buffer);\n  }\n\n  get numBytes() {\n    return this.data.byteLength;\n  }\n}\n\nfunction GeometryChunkMixin<TBase extends { new (...args: any[]): Chunk }>(\n  Base: TBase,\n) {\n  class C extends Base {\n    data: AnnotationGeometryData | undefined;\n    serialize(msg: any, transfers: any[]) {\n      super.serialize(msg, transfers);\n      const { data } = this;\n      if (data !== undefined) {\n        data.serialize(msg, transfers);\n        this.data = undefined;\n      }\n    }\n\n    downloadSucceeded() {\n      const { data } = this;\n      this.systemMemoryBytes = this.gpuMemoryBytes =\n        data === undefined ? 0 : data.numBytes;\n      super.downloadSucceeded();\n    }\n\n    freeSystemMemory() {\n      this.data = undefined;\n    }\n  }\n  return C;\n}\n\nexport class AnnotationGeometryChunk extends GeometryChunkMixin(\n  SliceViewChunk,\n) {\n  declare source: AnnotationGeometryChunkSourceBackend;\n}\n\nexport class AnnotationSubsetGeometryChunk extends GeometryChunkMixin(Chunk) {\n  declare source: AnnotationSubsetGeometryChunkSource;\n  objectId: bigint;\n}\n\n@registerSharedObject(ANNOTATION_METADATA_CHUNK_SOURCE_RPC_ID)\nclass AnnotationMetadataChunkSource extends ChunkSource {\n  parent: Borrowed<AnnotationSource> | undefined = undefined;\n  getChunk(id: string) {\n    const { chunks } = this;\n    let chunk = chunks.get(id);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(AnnotationMetadataChunk);\n      chunk.initialize(id);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  download(chunk: AnnotationMetadataChunk, signal: AbortSignal) {\n    return this.parent!.downloadMetadata(chunk, signal);\n  }\n}\n\nexport class AnnotationGeometryChunkSourceBackend extends SliceViewChunkSourceBackend<\n  AnnotationGeometryChunkSpecification,\n  AnnotationGeometryChunk\n> {\n  parent: Borrowed<AnnotationSource>;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.parent = rpc.get(options.parent);\n  }\n}\nAnnotationGeometryChunkSourceBackend.prototype.chunkConstructor =\n  AnnotationGeometryChunk;\n\n@registerSharedObject(ANNOTATION_SUBSET_GEOMETRY_CHUNK_SOURCE_RPC_ID)\nclass AnnotationSubsetGeometryChunkSource extends ChunkSource {\n  parent: Borrowed<AnnotationSource> | undefined = undefined;\n  declare chunks: Map<string, AnnotationSubsetGeometryChunk>;\n  relationshipIndex: number;\n  getChunk(objectId: bigint) {\n    const key = getObjectKey(objectId);\n    const { chunks } = this;\n    let chunk = chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(AnnotationSubsetGeometryChunk);\n      chunk.initialize(key);\n      chunk.objectId = objectId;\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n  download(chunk: AnnotationSubsetGeometryChunk, signal: AbortSignal) {\n    return this.parent!.downloadSegmentFilteredGeometry(\n      chunk,\n      this.relationshipIndex,\n      signal,\n    );\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface AnnotationSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadMetadata(\n    chunk: AnnotationMetadataChunk,\n    signal: AbortSignal,\n  ): Promise<void>;\n  downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    relationshipIndex: number,\n    signal: AbortSignal,\n  ): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class AnnotationSource extends SharedObjectCounterpart {\n  references = new Set<AnnotationId>();\n  chunkManager: Borrowed<ChunkManager>;\n  metadataChunkSource: AnnotationMetadataChunkSource;\n  segmentFilteredSources: AnnotationSubsetGeometryChunkSource[];\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const chunkManager = (this.chunkManager = <ChunkManager>(\n      rpc.get(options.chunkManager)\n    ));\n    const metadataChunkSource = (this.metadataChunkSource =\n      this.registerDisposer(\n        rpc.getRef<AnnotationMetadataChunkSource>(options.metadataChunkSource),\n      ));\n    this.segmentFilteredSources = (options.segmentFilteredSource as any[]).map(\n      (x, i) => {\n        const source = this.registerDisposer(\n          rpc.getRef<AnnotationSubsetGeometryChunkSource>(x),\n        );\n        source.parent = this;\n        source.relationshipIndex = i;\n        return source;\n      },\n    );\n    metadataChunkSource.parent = this;\n    this.registerDisposer(\n      chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  private recomputeChunkPriorities() {\n    const { chunkManager, metadataChunkSource } = this;\n    for (const id of this.references) {\n      chunkManager.requestChunk(\n        metadataChunkSource.getChunk(id),\n        ChunkPriorityTier.VISIBLE,\n        ANNOTATION_METADATA_CHUNK_PRIORITY,\n      );\n    }\n  }\n\n  add(annotation: Annotation): Promise<AnnotationId> {\n    annotation;\n    throw new Error(\"Not implemented\");\n  }\n  delete(id: AnnotationId): Promise<void> {\n    id;\n    throw new Error(\"Not implemented\");\n  }\n  update(id: AnnotationId, newAnnotation: Annotation): Promise<void> {\n    id;\n    newAnnotation;\n    throw new Error(\"Not implemented\");\n  }\n}\n\nregisterRPC(ANNOTATION_REFERENCE_ADD_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  obj.references.add(x.annotation);\n  obj.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(ANNOTATION_REFERENCE_DELETE_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  obj.references.delete(x.annotation);\n  obj.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(ANNOTATION_COMMIT_UPDATE_RPC_ID, function (x: any) {\n  const obj = <AnnotationSource>this.get(x.id);\n  const annotationId: AnnotationId | undefined = x.annotationId;\n  const newAnnotation: Annotation | null = x.newAnnotation;\n\n  let promise: Promise<Annotation | null>;\n  if (annotationId === undefined) {\n    promise = obj.add(newAnnotation!).then((id) => ({ ...newAnnotation!, id }));\n  } else if (newAnnotation === null) {\n    promise = obj.delete(annotationId).then(() => null);\n  } else {\n    promise = obj.update(annotationId, newAnnotation).then(() => newAnnotation);\n  }\n  // FIXME: Handle new chunks requested prior to update but not yet sent to frontend.\n  promise.then(\n    (result) => {\n      if (!obj.wasDisposed) {\n        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {\n          id: obj.rpcId,\n          annotationId: annotationId || newAnnotation!.id,\n          newAnnotation: result,\n        });\n      }\n    },\n    (error: Error) => {\n      if (!obj.wasDisposed) {\n        this.invoke(ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID, {\n          id: obj.rpcId,\n          annotationId: annotationId || newAnnotation?.id,\n          error: error.message,\n        });\n      }\n    },\n  );\n});\n\ninterface AnnotationRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSources: TransformedSource<\n    AnnotationSpatiallyIndexedRenderLayerBackend,\n    AnnotationGeometryChunkSourceBackend\n  >[][];\n}\n\n@registerSharedObject(ANNOTATION_SPATIALLY_INDEXED_RENDER_LAYER_RPC_ID)\nclass AnnotationSpatiallyIndexedRenderLayerBackend extends withChunkManager(\n  RenderLayerBackend,\n) {\n  localPosition: SharedWatchableValue<Float32Array>;\n  renderScaleTarget: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.renderScaleTarget = rpc.get(options.renderScaleTarget);\n    this.localPosition = rpc.get(options.localPosition);\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      this.localPosition.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.renderScaleTarget.changed.add(scheduleUpdateChunkPriorities),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      AnnotationRenderLayerAttachmentState\n    >,\n  ) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n      transformedSources: [],\n    };\n  }\n\n  private recomputeChunkPriorities() {\n    this.chunkManager.registerLayer(this);\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const attachmentState =\n        attachment.state! as AnnotationRenderLayerAttachmentState;\n      const { transformedSources } = attachmentState;\n      if (\n        transformedSources.length === 0 ||\n        !validateDisplayDimensionRenderInfoProperty(\n          attachmentState,\n          view.projectionParameters.value.displayDimensionRenderInfo,\n        )\n      ) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n\n      const projectionParameters = view.projectionParameters.value;\n\n      const { chunkManager } = this;\n      forEachVisibleAnnotationChunk(\n        projectionParameters,\n        this.localPosition.value,\n        this.renderScaleTarget.value,\n        transformedSources[0],\n        () => {},\n        (tsource, scaleIndex) => {\n          const chunk = (\n            tsource.source as AnnotationGeometryChunkSourceBackend\n          ).getChunk(tsource.curPositionInChunks);\n          ++this.numVisibleChunksNeeded;\n          // FIXME: calculate priority\n          if (chunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n          const priority = 0;\n          chunkManager.requestChunk(\n            chunk,\n            priorityTier,\n            basePriority + priority + SCALE_PRIORITY_MULTIPLIER * scaleIndex,\n          );\n        },\n      );\n    }\n  }\n}\nAnnotationSpatiallyIndexedRenderLayerBackend;\n\nregisterRPC(\n  ANNOTATION_PERSPECTIVE_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  function (x) {\n    const view = this.get(x.view) as RenderedViewBackend;\n    const layer = this.get(\n      x.layer,\n    ) as AnnotationSpatiallyIndexedRenderLayerBackend;\n    const attachment = layer.attachments.get(\n      view,\n    )! as RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      AnnotationRenderLayerAttachmentState\n    >;\n    attachment.state!.transformedSources = deserializeTransformedSources<\n      AnnotationGeometryChunkSourceBackend,\n      AnnotationSpatiallyIndexedRenderLayerBackend\n    >(this, x.sources, layer);\n    attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n    layer.chunkManager.scheduleUpdateChunkPriorities();\n  },\n);\n\ntype AnnotationLayerSegmentationState = VisibleSegmentsState | undefined | null;\n\n@registerSharedObject(ANNOTATION_RENDER_LAYER_RPC_ID)\nclass AnnotationLayerSharedObjectCounterpart extends withSharedVisibility(\n  withChunkManager(ChunkRenderLayerBackend),\n) {\n  source: AnnotationSource;\n\n  segmentationStates: WatchableValue<\n    AnnotationLayerSegmentationState[] | undefined\n  >;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = rpc.get(options.source);\n    this.segmentationStates = new WatchableValue(\n      this.getSegmentationState(options.segmentationStates),\n    );\n\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    this.registerDisposer(\n      registerNested((context, states) => {\n        if (states === undefined) return;\n        for (const state of states) {\n          if (state == null) continue;\n          onVisibleSegmentsStateChanged(\n            context,\n            state,\n            scheduleUpdateChunkPriorities,\n          );\n          onTemporaryVisibleSegmentsStateChanged(\n            context,\n            state,\n            scheduleUpdateChunkPriorities,\n          );\n        }\n        scheduleUpdateChunkPriorities();\n      }, this.segmentationStates),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() =>\n        this.recomputeChunkPriorities(),\n      ),\n    );\n  }\n\n  private recomputeChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const {\n      segmentationStates: { value: states },\n      source: { segmentFilteredSources },\n    } = this;\n    if (states === undefined) return;\n    const { chunkManager } = this;\n    chunkManager.registerLayer(this);\n    const numRelationships = states.length;\n    for (let i = 0; i < numRelationships; ++i) {\n      const state = states[i];\n      if (state == null) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n      const source = segmentFilteredSources[i];\n      forEachVisibleSegment(state, (objectId) => {\n        const chunk = source.getChunk(objectId);\n        ++this.numVisibleChunksNeeded;\n        if (chunk.state === ChunkState.GPU_MEMORY) {\n          ++this.numVisibleChunksAvailable;\n        }\n        chunkManager.requestChunk(\n          chunk,\n          priorityTier,\n          basePriority + ANNOTATION_SEGMENT_FILTERED_CHUNK_PRIORITY,\n        );\n      });\n    }\n  }\n\n  getSegmentationState(\n    msg: any[] | undefined,\n  ): AnnotationLayerSegmentationState[] | undefined {\n    if (msg === undefined) return undefined;\n    return msg.map((x) => {\n      if (x == null) {\n        return x as undefined | null;\n      }\n      return receiveVisibleSegmentsState(this.rpc!, x);\n    });\n  }\n}\nAnnotationLayerSharedObjectCounterpart;\n\nregisterRPC(ANNOTATION_RENDER_LAYER_UPDATE_SEGMENTATION_RPC_ID, function (x) {\n  const obj = <AnnotationLayerSharedObjectCounterpart>this.get(x.id);\n  obj.segmentationStates.value = obj.getSegmentationState(x.segmentationStates);\n});\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchOkWithCredentials } from \"#src/credentials_provider/http_request.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport { fetchOk } from \"#src/util/http_request.js\";\n\nexport type BossToken = string;\n\n/**\n * Key used for retrieving the CredentialsProvider from a CredentialsManager.\n */\nexport const credentialsKey = \"boss\";\n\nexport async function fetchWithBossCredentials(\n  credentialsProvider: CredentialsProvider<BossToken>,\n  input: RequestInfo,\n  init: RequestInit,\n): Promise<Response> {\n  return fetchOk(input, init).catch((error) => {\n    if (\n      error.status !== 500 &&\n      error.status !== 401 &&\n      error.status !== 403 &&\n      error.status !== 504\n    ) {\n      // Prevent an infinite loop of error = 0 where the request\n      // has been cancelled\n      throw error;\n    }\n    return fetchOkWithCredentials(\n      credentialsProvider,\n      input,\n      init,\n      (credentials) => {\n        const headers = new Headers(init.headers);\n        headers.set(\"Authorization\", `Bearer ${credentials}`);\n        return { ...init, headers };\n      },\n      (error) => {\n        const { status } = error;\n        if (status === 403 || status === 401) {\n          // Authorization needed.  Retry with refreshed token.\n          return \"refresh\";\n        }\n        throw error;\n      },\n    );\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TypedNumberArray } from \"#src/util/array.js\";\n\nexport function getOctreeChildIndex(x: number, y: number, z: number) {\n  return (x & 1) | ((y << 1) & 2) | ((z << 2) & 4);\n}\n\n/**\n * Decodes a \"compressed\" 3-d morton index.\n *\n * Decoded bit `i` of `x`, `y`, and `z` is at bit `i + min(i, yBits) + min(i, zBits)`, `i + min(i +\n * 1, xBits) + min(i, zBits)`, and `i + min(i + 1, xBits) + min(i + 1, zBits)` of `zindex`,\n * respectively, for `i` in `[0, xBits)`, `[0, yBits)`, `[0, zBits)`, respectively.\n */\nexport function decodeZIndexCompressed(\n  zindex: bigint,\n  xBits: number,\n  yBits: number,\n  zBits: number,\n): Uint32Array {\n  const maxCoordBits = Math.max(xBits, yBits, zBits);\n  let inputBit = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  for (let coordBit = 0; coordBit < maxCoordBits; ++coordBit) {\n    if (coordBit < xBits) {\n      const bit = Number((zindex >> BigInt(inputBit++)) & BigInt(1));\n      x |= bit << coordBit;\n    }\n    if (coordBit < yBits) {\n      const bit = Number((zindex >> BigInt(inputBit++)) & BigInt(1));\n      y |= bit << coordBit;\n    }\n    if (coordBit < zBits) {\n      const bit = Number((zindex >> BigInt(inputBit++)) & BigInt(1));\n      z |= bit << coordBit;\n    }\n  }\n  return Uint32Array.of(x, y, z);\n}\n\nexport function encodeZIndexCompressed3d(\n  xBits: number,\n  yBits: number,\n  zBits: number,\n  x: number,\n  y: number,\n  z: number,\n): bigint {\n  const maxBits = Math.max(xBits, yBits, zBits);\n  let outputBit = 0;\n  let zIndex = 0n;\n  function writeBit(b: number): void {\n    zIndex |= BigInt(b) << BigInt(outputBit++);\n  }\n  for (let bit = 0; bit < maxBits; ++bit) {\n    if (bit < xBits) {\n      writeBit((x >> bit) & 1);\n    }\n    if (bit < yBits) {\n      writeBit((y >> bit) & 1);\n    }\n    if (bit < zBits) {\n      writeBit((z >> bit) & 1);\n    }\n  }\n  return zIndex;\n}\n\nexport function encodeZIndexCompressed(\n  position: TypedNumberArray,\n  shape: TypedNumberArray,\n): bigint {\n  let zIndex = 0n;\n  let outputBit = 0;\n  const rank = position.length;\n  function writeBit(b: number): void {\n    zIndex |= BigInt(b & 1) << BigInt(outputBit++);\n  }\n\n  for (let bit = 0; bit < 32; ++bit) {\n    for (let dim = 0; dim < rank; ++dim) {\n      if ((shape[dim] - 1) >>> bit) {\n        writeBit(position[dim] >>> bit);\n      }\n    }\n  }\n  return zIndex;\n}\n\nfunction lessMsb(a: number, b: number) {\n  return a < b && a < (a ^ b);\n}\n\n/**\n * Returns `true` if `(x0, y0, z0)` occurs before `(x1, y1, z1)` in Z-curve order.\n */\nexport function zorder3LessThan(\n  x0: number,\n  y0: number,\n  z0: number,\n  x1: number,\n  y1: number,\n  z1: number,\n): boolean {\n  let mostSignificant0 = z0;\n  let mostSignificant1 = z1;\n\n  if (lessMsb(mostSignificant0 ^ mostSignificant1, y0 ^ y1)) {\n    mostSignificant0 = y0;\n    mostSignificant1 = y1;\n  }\n\n  if (lessMsb(mostSignificant0 ^ mostSignificant1, x0 ^ x1)) {\n    mostSignificant0 = x0;\n    mostSignificant1 = x1;\n  }\n\n  return mostSignificant0 < mostSignificant1;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Chunk,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type {\n  EncodedMeshData,\n  EncodedVertexPositions,\n  MeshVertexIndices,\n  MultiscaleFragmentFormat,\n} from \"#src/mesh/base.js\";\nimport {\n  FRAGMENT_SOURCE_RPC_ID,\n  MESH_LAYER_RPC_ID,\n  MULTISCALE_FRAGMENT_SOURCE_RPC_ID,\n  MULTISCALE_MESH_LAYER_RPC_ID,\n  VertexPositionFormat,\n} from \"#src/mesh/base.js\";\nimport type { MultiscaleMeshManifest } from \"#src/mesh/multiscale.js\";\nimport { getDesiredMultiscaleMeshChunks } from \"#src/mesh/multiscale.js\";\nimport { computeTriangleStrips } from \"#src/mesh/triangle_strips.js\";\nimport type { PerspectiveViewBackend } from \"#src/perspective_view/backend.js\";\nimport { PerspectiveViewRenderLayerBackend } from \"#src/perspective_view/backend.js\";\nimport { get3dModelToDisplaySpaceMatrix } from \"#src/render_coordinate_transform.js\";\nimport type { RenderLayerBackendAttachment } from \"#src/render_layer_backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport {\n  getObjectKey,\n  forEachVisibleSegment,\n} from \"#src/segmentation_display_state/base.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport { convertEndian32 } from \"#src/util/endian.js\";\nimport { getFrustrumPlanes, mat4, vec3 } from \"#src/util/geom.js\";\nimport {\n  verifyObject,\n  verifyObjectProperty,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport { zorder3LessThan } from \"#src/util/zorder.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst MESH_OBJECT_MANIFEST_CHUNK_PRIORITY = 100;\nconst MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY = 50;\n\nconst CONVERT_TO_TRIANGLE_STRIPS = false;\n\nexport type FragmentId = string;\n\n// Chunk that contains the list of fragments that make up a single object.\nexport class ManifestChunk extends Chunk {\n  objectId: bigint = 0n;\n  fragmentIds: FragmentId[] | null;\n  // We can't save a reference to objectId, because it may be a temporary\n  // object.\n  initializeManifestChunk(key: string, objectId: bigint) {\n    super.initialize(key);\n    this.objectId = objectId;\n  }\n\n  freeSystemMemory() {\n    this.fragmentIds = null;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.fragmentIds = this.fragmentIds;\n  }\n\n  downloadSucceeded() {\n    // We can't easily determine the memory usage of the JSON manifest.  Just use 100 bytes as a\n    // default value.\n    this.systemMemoryBytes = 100;\n    this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n  }\n\n  toString() {\n    return this.objectId.toString();\n  }\n}\n\nexport interface RawMeshData {\n  vertexPositions: Float32Array | Uint32Array;\n  indices: MeshVertexIndices;\n}\n\nexport interface RawPartitionedMeshData extends RawMeshData {\n  subChunkOffsets: Uint32Array;\n}\n\nfunction serializeMeshData(data: EncodedMeshData, msg: any, transfers: any[]) {\n  const { vertexPositions, indices, vertexNormals, strips } = data;\n  msg.vertexPositions = vertexPositions;\n  msg.indices = indices;\n  msg.strips = strips;\n  msg.vertexNormals = vertexNormals;\n  const vertexPositionsBuffer = vertexPositions!.buffer;\n  transfers.push(vertexPositionsBuffer);\n  const indicesBuffer = indices!.buffer;\n  if (indicesBuffer !== vertexPositionsBuffer) {\n    transfers.push(indicesBuffer);\n  }\n  transfers.push(vertexNormals!.buffer);\n}\n\nfunction getMeshDataSize(data: EncodedMeshData) {\n  const { vertexPositions, indices, vertexNormals } = data;\n  return (\n    vertexPositions!.byteLength +\n    indices!.byteLength +\n    vertexNormals!.byteLength\n  );\n}\n\n/**\n * Chunk that contains the mesh for a single fragment of a single object.\n */\nexport class FragmentChunk extends Chunk {\n  manifestChunk: ManifestChunk | null = null;\n  fragmentId: FragmentId | null = null;\n  meshData: EncodedMeshData | null = null;\n  initializeFragmentChunk(\n    key: string,\n    manifestChunk: ManifestChunk,\n    fragmentId: FragmentId,\n  ) {\n    super.initialize(key);\n    this.manifestChunk = manifestChunk;\n    this.fragmentId = fragmentId;\n  }\n  freeSystemMemory() {\n    this.manifestChunk = null;\n    this.meshData = null;\n    this.fragmentId = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    serializeMeshData(this.meshData!, msg, transfers);\n    this.meshData = null;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(\n      this.meshData!,\n    );\n    super.downloadSucceeded();\n  }\n}\n\n/**\n * Assigns chunk.fragmentKeys to response[keysPropertyName].\n *\n * Verifies that response[keysPropertyName] is an array of strings.\n */\nexport function decodeJsonManifestChunk(\n  chunk: ManifestChunk,\n  response: any,\n  keysPropertyName: string,\n) {\n  verifyObject(response);\n  chunk.fragmentIds = verifyObjectProperty(\n    response,\n    keysPropertyName,\n    verifyStringArray,\n  );\n}\n\n/**\n * Computes normal vectors for each vertex of a triangular mesh.\n *\n * The normal vector for each triangle with vertices (v0, v1, v2) is computed as the (normalized)\n * cross product of (v1 - v0, v2 - v1).  The normal vector for each vertex is obtained by averaging\n * the normal vector of each of the triangles that contains it.\n *\n * @param positions The vertex positions in [x0, y0, z0, x1, y1, z1, ...] format.\n * @param indices The indices of the triangle vertices.  Each triplet of consecutive values\n *     specifies a triangle.\n */\nexport function computeVertexNormals(\n  positions: Float32Array | Uint8Array | Uint16Array | Uint32Array,\n  indices: Uint8Array | Uint16Array | Uint32Array,\n) {\n  const faceNormal = vec3.create();\n  const v1v0 = vec3.create();\n  const v2v1 = vec3.create();\n  const vertexNormals = new Float32Array(positions.length);\n  const numIndices = indices.length;\n  for (let i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i] * 3;\n    const i1 = indices[i + 1] * 3;\n    const i2 = indices[i + 2] * 3;\n    for (let j = 0; j < 3; ++j) {\n      v1v0[j] = positions[i1 + j] - positions[i0 + j];\n      v2v1[j] = positions[i2 + j] - positions[i1 + j];\n    }\n    vec3.cross(faceNormal, v1v0, v2v1);\n    vec3.normalize(faceNormal, faceNormal);\n\n    for (let k = 0; k < 3; ++k) {\n      const index = indices[i + k];\n      const offset = index * 3;\n      for (let j = 0; j < 3; ++j) {\n        vertexNormals[offset + j] += faceNormal[j];\n      }\n    }\n  }\n  // Normalize all vertex normals.\n  const numVertices = vertexNormals.length;\n  for (let i = 0; i < numVertices; i += 3) {\n    const vec = <vec3>vertexNormals.subarray(i, i + 3);\n    vec3.normalize(vec, vec);\n  }\n  return vertexNormals;\n}\n\n/**\n * Converts a floating-point number in the range `[-1, 1]` to an integer in the range `[-127, 127]`.\n */\nfunction snorm8(x: number) {\n  return Math.min(Math.max(-127, x * 127 + 0.5), 127) >>> 0;\n}\n\nfunction signNotZero(x: number) {\n  return x < 0 ? -1 : 1;\n}\n\n/**\n * Encodes normal vectors represented as 3x32-bit floating vectors into a 2x8-bit octahedron\n * representation.\n *\n * Zina H. Cigolle, Sam Donow, Daniel Evangelakos, Michael Mara, Morgan McGuire, and Quirin Meyer,\n * Survey of Efficient Representations for Independent Unit Vectors, Journal of Computer Graphics\n * Techniques (JCGT), vol. 3, no. 2, 1-30, 2014\n *\n * Available online http://jcgt.org/published/0003/02/01/\n *\n * @param out[out] Row-major array of shape `[n, 2]` set to octahedron representation.\n * @param normals[in] Row-major array of shape `[n, 3]` specifying unit normal vectors.\n */\nexport function encodeNormals32fx3ToOctahedron8x2(\n  out: Uint8Array,\n  normals: Float32Array,\n) {\n  const length = normals.length;\n  let outIndex = 0;\n  for (let i = 0; i < length; i += 3) {\n    const x = normals[i];\n    const y = normals[i + 1];\n    const z = normals[i + 2];\n\n    const invL1Norm = 1 / (Math.abs(x) + Math.abs(y) + Math.abs(z));\n\n    if (z < 0) {\n      out[outIndex] = snorm8((1 - Math.abs(y * invL1Norm)) * signNotZero(x));\n      out[outIndex + 1] = snorm8(\n        (1 - Math.abs(x * invL1Norm)) * signNotZero(y),\n      );\n    } else {\n      out[outIndex] = snorm8(x * invL1Norm);\n      out[outIndex + 1] = snorm8(y * invL1Norm);\n    }\n    outIndex += 2;\n  }\n}\n\n/**\n * Extracts vertex positions and indices of the specified endianness from `data'.\n *\n * The vertexByteOffset specifies the byte offset into `data' of the start of the vertex position\n * data.  The vertex data must consist of verticesPerPrimitive * numVertices 32-bit float values.\n *\n * If indexByteOffset is not specified, it defaults to the end of the vertex position data.  If\n * numPrimitives is not specified, it is assumed that the index data continues until the end of the\n * array.\n */\nexport function decodeVertexPositionsAndIndices(\n  verticesPerPrimitive: number,\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numPrimitives?: number,\n): RawMeshData {\n  const vertexPositions = new Float32Array(\n    data,\n    vertexByteOffset,\n    numVertices * 3,\n  );\n  convertEndian32(vertexPositions, endianness);\n\n  if (indexByteOffset === undefined) {\n    indexByteOffset = vertexByteOffset + 12 * numVertices;\n  }\n\n  let numIndices: number | undefined;\n  if (numPrimitives !== undefined) {\n    numIndices = numPrimitives * verticesPerPrimitive;\n  }\n\n  // For compatibility with Firefox, length argument must not be undefined.\n  const indices =\n    numIndices === undefined\n      ? new Uint32Array(data, indexByteOffset)\n      : new Uint32Array(data, indexByteOffset, numIndices);\n  if (indices.length % verticesPerPrimitive !== 0) {\n    throw new Error(\n      `Number of indices is not a multiple of ${verticesPerPrimitive}: ${indices.length}.`,\n    );\n  }\n  convertEndian32(indices, endianness);\n\n  return { vertexPositions, indices };\n}\n\n/**\n * Extracts vertex positions and triangle vertex indices of the specified endianness from `data'.\n *\n * Vertex normals are computed.\n *\n * See decodeVertexPositionsAndIndices above.\n */\nexport function decodeTriangleVertexPositionsAndIndices(\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numTriangles?: number,\n) {\n  return decodeVertexPositionsAndIndices(\n    /*verticesPerPrimitive=*/ 3,\n    data,\n    endianness,\n    vertexByteOffset,\n    numVertices,\n    indexByteOffset,\n    numTriangles,\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface MeshSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadFragment(chunk: FragmentChunk, signal: AbortSignal): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class MeshSource extends ChunkSource {\n  fragmentSource: FragmentSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const fragmentSource = (this.fragmentSource = this.registerDisposer(\n      rpc.getRef<FragmentSource>(options.fragmentSource),\n    ));\n    fragmentSource.meshSource = this;\n  }\n\n  getChunk(objectId: bigint) {\n    const key = getObjectKey(objectId);\n    let chunk = <ManifestChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(ManifestChunk);\n      chunk.initializeManifestChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  getFragmentKey(objectKey: string | null, fragmentId: string) {\n    return { key: `${objectKey}/${fragmentId}`, fragmentId: fragmentId };\n  }\n\n  getFragmentChunk(manifestChunk: ManifestChunk, fragmentId: FragmentId) {\n    const fragmentSource = this.fragmentSource;\n    const { key: fragmentKey, fragmentId: parsedFragmentId } =\n      this.getFragmentKey(manifestChunk.key, fragmentId);\n    let chunk = <FragmentChunk>fragmentSource.chunks.get(fragmentKey);\n    if (chunk === undefined) {\n      chunk = fragmentSource.getNewChunk_(FragmentChunk);\n      chunk.initializeFragmentChunk(\n        fragmentKey,\n        manifestChunk,\n        parsedFragmentId,\n      );\n      fragmentSource.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(FRAGMENT_SOURCE_RPC_ID)\nexport class FragmentSource extends ChunkSource {\n  meshSource: MeshSource | null = null;\n  download(chunk: FragmentChunk, signal: AbortSignal) {\n    return this.meshSource!.downloadFragment(chunk, signal);\n  }\n}\n\n@registerSharedObject(MESH_LAYER_RPC_ID)\nexport class MeshLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend)),\n) {\n  source: MeshSource;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(rpc.getRef<MeshSource>(options.source));\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  attach(attachment: RenderLayerBackendAttachment<PerspectiveViewBackend>) {\n    const scheduleUpdateChunkPriorities = () => {\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    };\n    const { view } = attachment;\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    scheduleUpdateChunkPriorities();\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.chunkManager.registerLayer(this);\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    forEachVisibleSegment(this, (objectId) => {\n      const manifestChunk = source.getChunk(objectId);\n      ++this.numVisibleChunksNeeded;\n      chunkManager.requestChunk(\n        manifestChunk,\n        priorityTier,\n        basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY,\n      );\n      const state = manifestChunk.state;\n      if (\n        state === ChunkState.SYSTEM_MEMORY_WORKER ||\n        state === ChunkState.SYSTEM_MEMORY ||\n        state === ChunkState.GPU_MEMORY\n      ) {\n        ++this.numVisibleChunksAvailable;\n        for (const fragmentId of manifestChunk.fragmentIds!) {\n          const fragmentChunk = source.getFragmentChunk(\n            manifestChunk,\n            fragmentId,\n          );\n          ++this.numVisibleChunksNeeded;\n          chunkManager.requestChunk(\n            fragmentChunk,\n            priorityTier,\n            basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY,\n          );\n          if (fragmentChunk.state === ChunkState.GPU_MEMORY) {\n            ++this.numVisibleChunksAvailable;\n          }\n        }\n      }\n    });\n  }\n}\n\n// Chunk that contains the list of fragments that make up a single object.\nexport class MultiscaleManifestChunk extends Chunk {\n  objectId: bigint = 0n;\n  manifest: MultiscaleMeshManifest | undefined;\n  // We can't save a reference to objectId, because it may be a temporary\n  // object.\n  initializeManifestChunk(key: string, objectId: bigint) {\n    super.initialize(key);\n    this.objectId = objectId;\n  }\n\n  freeSystemMemory() {\n    this.manifest = undefined;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    msg.manifest = this.manifest;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.manifest!.octree.byteLength;\n    this.gpuMemoryBytes = 0;\n    super.downloadSucceeded();\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n  }\n\n  toString() {\n    return this.objectId.toString();\n  }\n}\n\n/**\n * Chunk that contains the mesh for a single fragment of a single object.\n */\nexport class MultiscaleFragmentChunk extends Chunk {\n  subChunkOffsets: Uint32Array | null = null;\n  meshData: EncodedMeshData | null = null;\n  lod = 0;\n  chunkIndex = 0;\n  manifestChunk: MultiscaleManifestChunk | null = null;\n  freeSystemMemory() {\n    this.meshData = this.subChunkOffsets = null;\n  }\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    serializeMeshData(this.meshData!, msg, transfers);\n    const { subChunkOffsets } = this;\n    msg.subChunkOffsets = subChunkOffsets;\n    transfers.push(subChunkOffsets!.buffer);\n    this.meshData = this.subChunkOffsets = null;\n  }\n  downloadSucceeded() {\n    const { subChunkOffsets } = this;\n    this.systemMemoryBytes = this.gpuMemoryBytes = getMeshDataSize(\n      this.meshData!,\n    );\n    this.systemMemoryBytes += subChunkOffsets!.byteLength;\n    super.downloadSucceeded();\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface MultiscaleMeshSource {\n  // TODO(jbms): Move this declaration to class definition below and declare abstract once\n  // TypeScript supports mixins with abstract classes.\n  downloadFragment(\n    chunk: MultiscaleFragmentChunk,\n    signal: AbortSignal,\n  ): Promise<void>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class MultiscaleMeshSource extends ChunkSource {\n  fragmentSource: MultiscaleFragmentSource;\n  format: MultiscaleFragmentFormat;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const fragmentSource = (this.fragmentSource = this.registerDisposer(\n      rpc.getRef<MultiscaleFragmentSource>(options.fragmentSource),\n    ));\n    this.format = options.format;\n    fragmentSource.meshSource = this;\n  }\n\n  getChunk(objectId: bigint) {\n    const key = getObjectKey(objectId);\n    let chunk = <MultiscaleManifestChunk>this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(MultiscaleManifestChunk);\n      chunk.initializeManifestChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  getFragmentChunk(\n    manifestChunk: MultiscaleManifestChunk,\n    lod: number,\n    chunkIndex: number,\n  ) {\n    const key = `${manifestChunk.key}/${lod}:${chunkIndex}`;\n    const fragmentSource = this.fragmentSource;\n    let chunk = <MultiscaleFragmentChunk>fragmentSource.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = fragmentSource.getNewChunk_(MultiscaleFragmentChunk);\n      chunk.initialize(key);\n      chunk.lod = lod;\n      chunk.chunkIndex = chunkIndex;\n      chunk.manifestChunk = manifestChunk;\n      fragmentSource.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(MULTISCALE_FRAGMENT_SOURCE_RPC_ID)\nexport class MultiscaleFragmentSource extends ChunkSource {\n  meshSource: MultiscaleMeshSource | null = null;\n  download(chunk: MultiscaleFragmentChunk, signal: AbortSignal) {\n    return this.meshSource!.downloadFragment(chunk, signal);\n  }\n}\n\nconst tempModelMatrix = mat4.create();\n\n@registerSharedObject(MULTISCALE_MESH_LAYER_RPC_ID)\nexport class MultiscaleMeshLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(PerspectiveViewRenderLayerBackend)),\n) {\n  source: MultiscaleMeshSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<MultiscaleMeshSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  attach(attachment: RenderLayerBackendAttachment<PerspectiveViewBackend>) {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    scheduleUpdateChunkPriorities();\n  }\n\n  private updateChunkPriorities() {\n    const maxVisibility = this.visibility.value;\n    if (maxVisibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    const {\n      transform: { value: transform },\n    } = this;\n    if (transform.error !== undefined) return;\n    const manifestChunks = new Array<MultiscaleManifestChunk>();\n    this.chunkManager.registerLayer(this);\n    {\n      const priorityTier = getPriorityTier(maxVisibility);\n      const basePriority = getBasePriority(maxVisibility);\n      const { source, chunkManager } = this;\n      forEachVisibleSegment(this, (objectId) => {\n        const manifestChunk = source.getChunk(objectId);\n        ++this.numVisibleChunksNeeded;\n        chunkManager.requestChunk(\n          manifestChunk,\n          priorityTier,\n          basePriority + MESH_OBJECT_MANIFEST_CHUNK_PRIORITY,\n        );\n        const state = manifestChunk.state;\n        if (\n          state === ChunkState.SYSTEM_MEMORY_WORKER ||\n          state === ChunkState.SYSTEM_MEMORY ||\n          state === ChunkState.GPU_MEMORY\n        ) {\n          manifestChunks.push(manifestChunk);\n          ++this.numVisibleChunksAvailable;\n        }\n      });\n    }\n    if (manifestChunks.length === 0) return;\n    const { source, chunkManager } = this;\n    for (const { view } of this.attachments.values()) {\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n      const projectionParameters = view.projectionParameters.value;\n      const modelViewProjectionMatrix = tempModelMatrix;\n      try {\n        get3dModelToDisplaySpaceMatrix(\n          modelViewProjectionMatrix,\n          projectionParameters.displayDimensionRenderInfo,\n          transform,\n        );\n      } catch {\n        continue;\n      }\n      mat4.multiply(\n        modelViewProjectionMatrix,\n        projectionParameters.viewProjectionMat,\n        modelViewProjectionMatrix,\n      );\n      const clippingPlanes = getFrustrumPlanes(\n        new Float32Array(24),\n        modelViewProjectionMatrix,\n      );\n      const detailCutoff = this.renderScaleTarget.value;\n      for (const manifestChunk of manifestChunks) {\n        const maxLod = manifestChunk.manifest!.lodScales.length - 1;\n        getDesiredMultiscaleMeshChunks(\n          manifestChunk.manifest!,\n          modelViewProjectionMatrix,\n          clippingPlanes,\n          detailCutoff,\n          projectionParameters.width,\n          projectionParameters.height,\n          (lod, chunkIndex, _renderScale, empty) => {\n            if (empty) return;\n            const fragmentChunk = source.getFragmentChunk(\n              manifestChunk,\n              lod,\n              chunkIndex,\n            );\n            ++this.numVisibleChunksNeeded;\n            chunkManager.requestChunk(\n              fragmentChunk,\n              priorityTier,\n              basePriority + MESH_OBJECT_FRAGMENT_CHUNK_PRIORITY - maxLod + lod,\n            );\n            if (fragmentChunk.state === ChunkState.GPU_MEMORY) {\n              ++this.numVisibleChunksAvailable;\n            }\n          },\n        );\n      }\n    }\n  }\n}\n\nfunction convertMeshData(\n  data: RawMeshData & { subChunkOffsets?: Uint32Array },\n  vertexPositionFormat: VertexPositionFormat,\n): EncodedMeshData {\n  const normals = computeVertexNormals(data.vertexPositions, data.indices);\n  const encodedNormals = new Uint8Array((normals.length / 3) * 2);\n  encodeNormals32fx3ToOctahedron8x2(encodedNormals, normals);\n  let encodedIndices: MeshVertexIndices;\n  let strips: boolean;\n  if (CONVERT_TO_TRIANGLE_STRIPS) {\n    encodedIndices = computeTriangleStrips(data.indices, data.subChunkOffsets);\n    strips = true;\n  } else {\n    if (\n      data.indices.BYTES_PER_ELEMENT === 4 &&\n      data.vertexPositions.length / 3 < 65535\n    ) {\n      encodedIndices = new Uint16Array(data.indices.length);\n      encodedIndices.set(data.indices);\n    } else {\n      encodedIndices = data.indices;\n    }\n    strips = false;\n  }\n  let encodedVertexPositions: EncodedVertexPositions;\n  if (vertexPositionFormat === VertexPositionFormat.uint10) {\n    const vertexPositions = data.vertexPositions;\n    const numVertices = vertexPositions.length / 3;\n    encodedVertexPositions = new Uint32Array(numVertices);\n    for (\n      let inputIndex = 0, outputIndex = 0;\n      outputIndex < numVertices;\n      inputIndex += 3, ++outputIndex\n    ) {\n      encodedVertexPositions[outputIndex] =\n        (vertexPositions[inputIndex] & 1023) |\n        ((vertexPositions[inputIndex + 1] & 1023) << 10) |\n        ((vertexPositions[inputIndex + 2] & 1023) << 20);\n    }\n  } else if (vertexPositionFormat === VertexPositionFormat.uint16) {\n    const vertexPositions = data.vertexPositions;\n    if (vertexPositions.BYTES_PER_ELEMENT === 2) {\n      encodedVertexPositions = vertexPositions;\n    } else {\n      encodedVertexPositions = new Uint16Array(vertexPositions.length);\n      encodedVertexPositions.set(vertexPositions);\n    }\n  } else {\n    encodedVertexPositions = data.vertexPositions as Float32Array;\n  }\n  return {\n    vertexPositions: encodedVertexPositions,\n    vertexNormals: encodedNormals,\n    indices: encodedIndices,\n    strips,\n  };\n}\n\nexport function assignMeshFragmentData(\n  chunk: FragmentChunk,\n  data: RawMeshData,\n  vertexPositionFormat: VertexPositionFormat = VertexPositionFormat.float32,\n) {\n  chunk.meshData = convertMeshData(data, vertexPositionFormat);\n}\n\nexport function assignMultiscaleMeshFragmentData(\n  chunk: MultiscaleFragmentChunk,\n  data: RawPartitionedMeshData,\n  vertexPositionFormat: VertexPositionFormat,\n) {\n  chunk.meshData = convertMeshData(data, vertexPositionFormat);\n  chunk.subChunkOffsets = data.subChunkOffsets;\n}\n\nexport function generateHigherOctreeLevel(\n  octree: Uint32Array,\n  priorStart: number,\n  priorEnd: number,\n): number {\n  let curEnd = priorEnd;\n  for (let i = 0; i < 3; ++i) {\n    octree[curEnd * 5 + i] = octree[priorStart * 5 + i] >>> 1;\n  }\n  octree[curEnd * 5 + 3] = priorStart;\n  for (let i = priorStart + 1; i < priorEnd; ++i) {\n    const x = octree[i * 5] >>> 1;\n    const y = octree[i * 5 + 1] >>> 1;\n    const z = octree[i * 5 + 2] >>> 1;\n    if (\n      x !== octree[curEnd * 5] ||\n      y !== octree[curEnd * 5 + 1] ||\n      z !== octree[curEnd * 5 + 2]\n    ) {\n      octree[curEnd * 5 + 4] = i;\n      ++curEnd;\n      octree[curEnd * 5] = x;\n      octree[curEnd * 5 + 1] = y;\n      octree[curEnd * 5 + 2] = z;\n      octree[curEnd * 5 + 3] = i;\n    }\n  }\n  octree[curEnd * 5 + 4] = priorEnd;\n  ++curEnd;\n  return curEnd;\n}\n\nexport function computeOctreeChildOffsets(\n  octree: Uint32Array,\n  childStart: number,\n  childEnd: number,\n  parentEnd: number,\n) {\n  let childNode = childStart;\n  for (let parentNode = childEnd; parentNode < parentEnd; ++parentNode) {\n    const parentX = octree[parentNode * 5];\n    const parentY = octree[parentNode * 5 + 1];\n    const parentZ = octree[parentNode * 5 + 2];\n    while (childNode < childEnd) {\n      const childX = octree[childNode * 5] >>> 1;\n      const childY = octree[childNode * 5 + 1] >>> 1;\n      const childZ = octree[childNode * 5 + 2] >>> 1;\n      if (!zorder3LessThan(childX, childY, childZ, parentX, parentY, parentZ)) {\n        break;\n      }\n      ++childNode;\n    }\n    octree[parentNode * 5 + 3] = childNode;\n    while (childNode < childEnd) {\n      const childX = octree[childNode * 5] >>> 1;\n      const childY = octree[childNode * 5 + 1] >>> 1;\n      const childZ = octree[childNode * 5 + 2] >>> 1;\n      if (childX !== parentX || childY !== parentY || childZ !== parentZ) {\n        break;\n      }\n      ++childNode;\n    }\n    octree[parentNode * 5 + 4] += childNode;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { mat4, vec3 } from \"#src/util/geom.js\";\nimport { isAABBVisible } from \"#src/util/geom.js\";\nimport { getOctreeChildIndex } from \"#src/util/zorder.js\";\n\nconst DEBUG_CHUNKS_TO_DRAW = false;\n\nexport interface MultiscaleMeshManifest {\n  /**\n   * Size of finest-resolution (base) chunk in object coordinates.\n   */\n  chunkShape: vec3;\n\n  /**\n   * Starting corner position of (0, 0, 0) chunk in object coordinates.\n   */\n  chunkGridSpatialOrigin: vec3;\n\n  /**\n   * Axis-aligned bounding box lower bound of object in object coordinates to use for clipping and\n   * level-of-detail calculations.\n   */\n  clipLowerBound: vec3;\n\n  /**\n   * Axis-aligned bounding box upper bound of object in object coordinates to use for clipping and\n   * level-of-detail calculations.\n   */\n  clipUpperBound: vec3;\n\n  /**\n   * Specifies the number of levels of detail (as `lodScales.length`), and the resolution in object\n   * coordinates for each level of detail.  If `lodScales[lod] === 0`, then level-of-detail `lod`\n   * does not exist.\n   *\n   * Level of detail `0` is the finest resolution.\n   *\n   * The non-zero values must be non-decreasing.\n   *\n   * For each chunk, the chosen `lod` is the largest value such that\n   * `lodScales[lod] <= detailCutoff * pixelSize`, where `pixelSize` is the maximum spatial distance\n   * spanned by a single viewport pixel within the projected image of the chunk.\n   */\n  lodScales: Float32Array;\n\n  /**\n   * C order `[numLods, 3]` array specifying the xyz vertex position offset in object coordinates\n   * for each level of detail.\n   */\n  vertexOffsets: Float32Array;\n\n  /**\n   * Row-major `[n, 5]` array where each row is of the form `[x, y, z, start, end_and_empty]`, where\n   * `x`, `y`, and `z` are the chunk grid coordinates of the entry at a particular level of detail.\n   * Row `n-1` corresponds to level of detail `lodScales.length - 1`, the root of the octree.  Given\n   * a row corresponding to an octree node at level of detail `lod`, bits `start` specifies the row\n   * number of the first child octree node at level of detail `lod-1`, and bits `[0,30]` of\n   * `end_and_empty` specify one past the row number of the last child octree node.  Bit `31` of\n   * `end_and_empty` is set to `1` if the mesh for the octree node is empty and should not be\n   * requested/rendered.\n   */\n  octree: Uint32Array;\n}\n\n/**\n * @param detailCutoff Factor by which the spatial resolution of the mesh may be worse than the\n *     spatial resolution of a single viewport pixel.  For example, a value of 10 means that if a\n *     given portion of the object will be rendered such that a pixel corresponds to 50 nm, then a\n *     mesh level of detail down to 500 nm will be requested for that portion of the object.\n */\nexport function getDesiredMultiscaleMeshChunks(\n  manifest: MultiscaleMeshManifest,\n  modelViewProjection: mat4,\n  clippingPlanes: Float32Array,\n  detailCutoff: number,\n  viewportWidth: number,\n  viewportHeight: number,\n  callback: (\n    lod: number,\n    row: number,\n    renderScale: number,\n    empty: number,\n  ) => void,\n) {\n  const { octree, lodScales, chunkGridSpatialOrigin, chunkShape } = manifest;\n  const maxLod = lodScales.length - 1;\n  const m00 = modelViewProjection[0];\n  const m01 = modelViewProjection[4];\n  const m02 = modelViewProjection[8];\n  const m10 = modelViewProjection[1];\n  const m11 = modelViewProjection[5];\n  const m12 = modelViewProjection[9];\n  const m30 = modelViewProjection[3];\n  const m31 = modelViewProjection[7];\n  const m32 = modelViewProjection[11];\n  const m33 = modelViewProjection[15];\n\n  const minWXcoeff = m30 > 0 ? 0 : 1;\n  const minWYcoeff = m31 > 0 ? 0 : 1;\n  const minWZcoeff = m32 > 0 ? 0 : 1;\n\n  const nearA = clippingPlanes[4 * 4];\n  const nearB = clippingPlanes[4 * 4 + 1];\n  const nearC = clippingPlanes[4 * 4 + 2];\n  const nearD = clippingPlanes[4 * 4 + 3];\n\n  function getPointW(x: number, y: number, z: number) {\n    return m30 * x + m31 * y + m32 * z + m33;\n  }\n\n  function getBoxW(\n    xLower: number,\n    yLower: number,\n    zLower: number,\n    xUpper: number,\n    yUpper: number,\n    zUpper: number,\n  ) {\n    return getPointW(\n      xLower + minWXcoeff * (xUpper - xLower),\n      yLower + minWYcoeff * (yUpper - yLower),\n      zLower + minWZcoeff * (zUpper - zLower),\n    );\n  }\n\n  /**\n   * Minimum value of w within clipping frustrum (under the assumption that the minimum value occurs\n   * on the near clipping plane).\n   */\n  const minWClip = getPointW(-nearD * nearA, -nearD * nearB, -nearD * nearC);\n\n  const objectXLower = manifest.clipLowerBound[0];\n  const objectYLower = manifest.clipLowerBound[1];\n  const objectZLower = manifest.clipLowerBound[2];\n  const objectXUpper = manifest.clipUpperBound[0];\n  const objectYUpper = manifest.clipUpperBound[1];\n  const objectZUpper = manifest.clipUpperBound[2];\n\n  const xScale = Math.sqrt(\n    (m00 * viewportWidth) ** 2 + (m10 * viewportHeight) ** 2,\n  );\n  const yScale = Math.sqrt(\n    (m01 * viewportWidth) ** 2 + (m11 * viewportHeight) ** 2,\n  );\n  const zScale = Math.sqrt(\n    (m02 * viewportWidth) ** 2 + (m12 * viewportHeight) ** 2,\n  );\n\n  const scaleFactor = Math.max(xScale, yScale, zScale);\n\n  function handleChunk(lod: number, row: number, priorLodScale: number) {\n    const size = 1 << lod;\n    const rowOffset = row * 5;\n    const gridX = octree[rowOffset];\n    const gridY = octree[rowOffset + 1];\n    const gridZ = octree[rowOffset + 2];\n    const childBegin = octree[rowOffset + 3];\n    const childEndAndEmpty = octree[rowOffset + 4];\n    let xLower = gridX * size * chunkShape[0] + chunkGridSpatialOrigin[0];\n    let yLower = gridY * size * chunkShape[1] + chunkGridSpatialOrigin[1];\n    let zLower = gridZ * size * chunkShape[2] + chunkGridSpatialOrigin[2];\n    let xUpper = xLower + size * chunkShape[0];\n    let yUpper = yLower + size * chunkShape[1];\n    let zUpper = zLower + size * chunkShape[2];\n    xLower = Math.max(xLower, objectXLower);\n    yLower = Math.max(yLower, objectYLower);\n    zLower = Math.max(zLower, objectZLower);\n    xUpper = Math.min(xUpper, objectXUpper);\n    yUpper = Math.min(yUpper, objectYUpper);\n    zUpper = Math.min(zUpper, objectZUpper);\n\n    if (\n      isAABBVisible(\n        xLower,\n        yLower,\n        zLower,\n        xUpper,\n        yUpper,\n        zUpper,\n        clippingPlanes,\n      )\n    ) {\n      const minW = Math.max(\n        minWClip,\n        getBoxW(xLower, yLower, zLower, xUpper, yUpper, zUpper),\n      );\n      const pixelSize = minW / scaleFactor;\n\n      if (priorLodScale === 0 || pixelSize * detailCutoff < priorLodScale) {\n        const lodScale = lodScales[lod];\n        if (lodScale !== 0) {\n          callback(lod, row, lodScale / pixelSize, childEndAndEmpty >>> 31);\n        }\n\n        if (\n          lod > 0 &&\n          (lodScale === 0 || pixelSize * detailCutoff < lodScale)\n        ) {\n          const nextPriorLodScale = lodScale === 0 ? priorLodScale : lodScale;\n          const childEnd = (childEndAndEmpty & 0x7fffffff) >>> 0;\n          for (let childRow = childBegin; childRow < childEnd; ++childRow) {\n            handleChunk(lod - 1, childRow, nextPriorLodScale);\n          }\n        }\n      }\n    }\n  }\n  handleChunk(maxLod, octree.length / 5 - 1, 0);\n}\n\nexport function getMultiscaleChunksToDraw(\n  manifest: MultiscaleMeshManifest,\n  modelViewProjection: mat4,\n  clippingPlanes: Float32Array,\n  detailCutoff: number,\n  viewportWidth: number,\n  viewportHeight: number,\n  hasChunk: (lod: number, row: number, renderScale: number) => boolean,\n  callback: (\n    lod: number,\n    row: number,\n    subChunkBegin: number,\n    subChunkEnd: number,\n    renderScale: number,\n  ) => void,\n) {\n  const { lodScales } = manifest;\n  let maxLod = 0;\n  while (maxLod + 1 < lodScales.length && lodScales[maxLod + 1] !== 0) {\n    ++maxLod;\n  }\n\n  const stackEntryStride = 3;\n\n  // [row, parentSubChunkIndex, renderScale]\n  const stack: number[] = [];\n  let stackDepth = 0;\n  let priorSubChunkIndex = 0;\n  function emitChunksUpTo(targetStackIndex: number, subChunkIndex: number) {\n    if (DEBUG_CHUNKS_TO_DRAW) {\n      console.log(\n        `emitChunksUpTo: stackDepth=${stackDepth}, targetStackIndex=${targetStackIndex}, subChunkIndex=${subChunkIndex}, priorSubChunkIndex=${priorSubChunkIndex}`,\n      );\n    }\n    while (true) {\n      if (stackDepth === 0) return;\n\n      // Finish last chunk of last (finest) lod.\n      const stackIndex = stackDepth - 1;\n      const entryLod = maxLod - stackIndex;\n      const entryRow = stack[stackIndex * stackEntryStride];\n      const numSubChunks = entryLod === 0 ? 1 : 8;\n      const entrySubChunkIndex = stack[stackIndex * stackEntryStride + 1];\n      const entryRenderScale = stack[stackIndex * stackEntryStride + 2];\n      if (targetStackIndex === stackDepth) {\n        const endSubChunk = subChunkIndex & (numSubChunks - 1);\n\n        if (priorSubChunkIndex !== endSubChunk && entryRow !== -1) {\n          if (DEBUG_CHUNKS_TO_DRAW) {\n            console.log(\n              `  drawing chunk because priorSubChunkIndex (${priorSubChunkIndex}) != endSubChunk (${endSubChunk})`,\n            );\n          }\n          callback(\n            entryLod,\n            entryRow,\n            priorSubChunkIndex,\n            endSubChunk,\n            entryRenderScale,\n          );\n        }\n        priorSubChunkIndex = endSubChunk + 1;\n        return;\n      }\n      if (priorSubChunkIndex !== numSubChunks && entryRow !== -1) {\n        callback(\n          entryLod,\n          entryRow,\n          priorSubChunkIndex,\n          numSubChunks,\n          entryRenderScale,\n        );\n      }\n      priorSubChunkIndex = entrySubChunkIndex + 1;\n      --stackDepth;\n    }\n  }\n\n  let priorMissingLod = 0;\n  if (DEBUG_CHUNKS_TO_DRAW) {\n    console.log(\"\");\n    console.log(\"Starting to draw\");\n  }\n  const { octree } = manifest;\n  getDesiredMultiscaleMeshChunks(\n    manifest,\n    modelViewProjection,\n    clippingPlanes,\n    detailCutoff,\n    viewportWidth,\n    viewportHeight,\n    (lod, row, renderScale, empty) => {\n      if (!empty && !hasChunk(lod, row, renderScale)) {\n        priorMissingLod = Math.max(lod, priorMissingLod);\n        return;\n      }\n      if (lod < priorMissingLod) {\n        // A parent chunk (containing chunk at coarser level-of-detail) is missing.  We can't draw\n        // chunks at this level-of-detail because we would not be able to fill in gaps.\n        return;\n      }\n      priorMissingLod = 0;\n      const rowOffset = row * 5;\n      const x = octree[rowOffset];\n      const y = octree[rowOffset + 1];\n      const z = octree[rowOffset + 2];\n      const subChunkIndex = getOctreeChildIndex(x, y, z);\n      const stackIndex = maxLod - lod;\n      emitChunksUpTo(stackIndex, subChunkIndex);\n      const stackOffset = stackIndex * stackEntryStride;\n      stack[stackOffset] = empty ? -1 : row;\n      stack[stackOffset + 1] = subChunkIndex;\n      stack[stackOffset + 2] = renderScale;\n      if (DEBUG_CHUNKS_TO_DRAW) {\n        console.log(\n          `Adding to stack: lod=${lod}, row=${stack[stackOffset]}, subChunkIndex=${subChunkIndex}`,\n        );\n      }\n      priorSubChunkIndex = 0;\n      stackDepth = stackIndex + 1;\n    },\n  );\n\n  emitChunksUpTo(0, 0);\n}\n\nexport function validateOctree(octree: Uint32Array) {\n  if (octree.length % 5 !== 0) {\n    throw new Error(\"Invalid length\");\n  }\n  const numNodes = octree.length / 5;\n  const seenNodes = new Set<number>();\n  function exploreNode(node: number) {\n    if (seenNodes.has(node)) {\n      throw new Error(\"Previously seen node\");\n    }\n    seenNodes.add(node);\n    if (node < 0 || node >= numNodes) {\n      throw new Error(\"Invalid node reference\");\n    }\n    const x = octree[node * 5];\n    const y = octree[node * 5 + 1];\n    const z = octree[node * 5 + 2];\n    const beginChild = octree[node * 5 + 3];\n    const endChild = octree[node * 5 + 4];\n    if (\n      beginChild < 0 ||\n      endChild < 0 ||\n      endChild < beginChild ||\n      endChild > numNodes ||\n      beginChild + 8 < endChild\n    ) {\n      throw new Error(\"Invalid child references\");\n    }\n    for (let child = beginChild; child < endChild; ++child) {\n      const childX = octree[child * 5];\n      const childY = octree[child * 5 + 1];\n      const childZ = octree[child * 5 + 2];\n      if (childX >>> 1 !== x || childY >>> 1 !== y || childZ >>> 1 !== z) {\n        throw new Error(\"invalid child\");\n      }\n      exploreNode(child);\n    }\n  }\n  if (numNodes === 0) return;\n  exploreNode(numNodes - 1);\n  if (seenNodes.size !== numNodes) {\n    throw new Error(\"Orphan nodes in octree\");\n  }\n}\n\nexport function getMultiscaleFragmentKey(\n  objectKey: string,\n  lod: number,\n  chunkIndex: number,\n) {\n  return `${objectKey}/${lod}:${chunkIndex}`;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const encodeCompressedSegmentationUint32 = asyncComputation<\n  (\n    rawData: Uint32Array<ArrayBuffer>,\n    shape: ArrayLike<number>,\n    blockSize: ArrayLike<number>,\n  ) => Uint32Array\n>(\"encodeCompressedSegmentationUint32\");\n\nexport const encodeCompressedSegmentationUint64 = asyncComputation<\n  (\n    rawData: Uint32Array<ArrayBuffer>,\n    shape: ArrayLike<number>,\n    blockSize: ArrayLike<number>,\n  ) => Uint32Array\n>(\"encodeCompressedSegmentationUint64\");\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Interface for defining transcode operations.\n */\n\nexport interface AsyncComputationSpec<Signature extends (...args: any) => any> {\n  id: string;\n  t?: Signature;\n}\n\n/**\n * Declares an asynchronous operation.\n */\nexport function asyncComputation<Signature extends (...args: any) => any>(\n  id: string,\n): AsyncComputationSpec<Signature> {\n  return { id };\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AsyncComputationSpec } from \"#src/async_computation/index.js\";\n\nlet numWorkers = 0;\nconst freeWorkers: Worker[] = [];\nconst pendingTasks = new Map<\n  number,\n  { msg: any; transfer: Transferable[] | undefined; cleanup?: () => void }\n>();\nconst tasks = new Map<\n  number,\n  {\n    resolve: (value: any) => void;\n    reject: (error: any) => void;\n  }\n>();\n// On Safari, `navigator.hardwareConcurrency` is not defined.\nconst maxWorkers =\n  typeof navigator.hardwareConcurrency === \"undefined\"\n    ? 4\n    : Math.min(12, navigator.hardwareConcurrency);\nlet nextTaskId = 0;\n\nfunction returnWorker(worker: Worker) {\n  for (const [id, task] of pendingTasks) {\n    pendingTasks.delete(id);\n    task.cleanup?.();\n    worker.postMessage(task.msg, task.transfer as Transferable[]);\n    return;\n  }\n  freeWorkers.push(worker);\n}\n\nfunction launchWorker() {\n  ++numWorkers;\n  // Note: For compatibility with multiple bundlers, a browser-compatible URL\n  // must be used with `new URL`, which means a Node.js subpath import like\n  // \"#src/async_computation.bundle.js\" cannot be used.\n  const worker = new Worker(\n    /* webpackChunkName: \"neuroglancer_async_computation\" */\n    new URL(\"../async_computation.bundle.js\", import.meta.url),\n    { type: \"module\" },\n  );\n  let ready = false;\n  worker.onmessage = (msg) => {\n    // First message indicates worker is ready.\n    if (!ready) {\n      ready = true;\n      returnWorker(worker);\n      return;\n    }\n    const { id, value, error } = msg.data as {\n      id: number;\n      value?: any;\n      error?: string;\n    };\n    returnWorker(worker);\n    const callbacks = tasks.get(id)!;\n    tasks.delete(id);\n    if (callbacks === undefined) return;\n    if (error !== undefined) {\n      callbacks.reject(error);\n    } else {\n      callbacks.resolve(value);\n    }\n  };\n}\n\nexport function requestAsyncComputation<\n  Signature extends (...args: any) => any,\n>(\n  request: AsyncComputationSpec<Signature>,\n  signal: AbortSignal | undefined,\n  transfer: Transferable[] | undefined,\n  ...args: Parameters<Signature>\n): Promise<ReturnType<Signature>> {\n  const id = nextTaskId++;\n  const msg = { t: request.id, id, args: args };\n\n  signal?.throwIfAborted();\n\n  const promise = new Promise<ReturnType<Signature>>((resolve, reject) => {\n    tasks.set(id, { resolve, reject });\n  });\n\n  if (freeWorkers.length !== 0) {\n    freeWorkers.pop()!.postMessage(msg, transfer as Transferable[]);\n  } else {\n    let cleanup: (() => void) | undefined;\n    if (signal !== undefined) {\n      function abortHandler() {\n        pendingTasks.delete(id);\n        const task = tasks.get(id)!;\n        tasks.delete(id);\n        task.reject(signal!.reason);\n      }\n      signal.addEventListener(\"abort\", abortHandler, { once: true });\n      cleanup = () => {\n        signal.removeEventListener(\"abort\", abortHandler);\n      };\n    }\n    pendingTasks.set(id, { msg, transfer, cleanup });\n    if (tasks.size > numWorkers && numWorkers < maxWorkers) {\n      launchWorker();\n    }\n  }\n\n  return promise;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Converts raw data volumes to the appropriate format required by the frontend.\n */\n\nimport {\n  encodeCompressedSegmentationUint32,\n  encodeCompressedSegmentationUint64,\n} from \"#src/async_computation/encode_compressed_segmentation_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { DataType } from \"#src/sliceview/base.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function postProcessRawData(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  data: ArrayBufferView<ArrayBuffer>,\n) {\n  const { spec } = chunk.source!;\n  if (spec.compressedSegmentationBlockSize !== undefined) {\n    const { dataType } = spec;\n    const chunkDataSize = chunk.chunkDataSize!;\n    const shape = [\n      chunkDataSize[0],\n      chunkDataSize[1],\n      chunkDataSize[2],\n      chunkDataSize[3] || 1,\n    ];\n    switch (dataType) {\n      case DataType.UINT32:\n        chunk.data = await requestAsyncComputation(\n          encodeCompressedSegmentationUint32,\n          signal,\n          [data.buffer],\n          data as Uint32Array<ArrayBuffer>,\n          shape,\n          spec.compressedSegmentationBlockSize,\n        );\n        break;\n      case DataType.UINT64:\n        chunk.data = await requestAsyncComputation(\n          encodeCompressedSegmentationUint64,\n          signal,\n          [data.buffer],\n          data as Uint32Array<ArrayBuffer>,\n          shape,\n          spec.compressedSegmentationBlockSize,\n        );\n        break;\n      default:\n        throw new Error(\n          `Unsupported data type for compressed segmentation: ${DataType[dataType]}`,\n        );\n    }\n  } else {\n    chunk.data = data;\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Support for parsing NumPy dtype strings.\n */\n\nimport { DataType } from \"#src/util/data_type.js\";\nimport { Endianness } from \"#src/util/endian.js\";\n\nexport interface NumpyDtype {\n  dataType: DataType;\n  endianness: Endianness;\n}\n\nconst supportedDataTypes = new Map<string, NumpyDtype>();\nsupportedDataTypes.set(\"|u1\", {\n  endianness: Endianness.LITTLE,\n  dataType: DataType.UINT8,\n});\nsupportedDataTypes.set(\"|i1\", {\n  endianness: Endianness.LITTLE,\n  dataType: DataType.INT8,\n});\nfor (const [endiannessChar, endianness] of <[string, Endianness][]>[\n  [\"<\", Endianness.LITTLE],\n  [\">\", Endianness.BIG],\n]) {\n  // For now, treat both signed and unsigned integer types as unsigned.\n  for (const typeChar of [\"u\", \"i\"]) {\n    supportedDataTypes.set(`${endiannessChar}${typeChar}8`, {\n      endianness,\n      dataType: DataType.UINT64,\n    });\n  }\n  supportedDataTypes.set(`${endiannessChar}u2`, {\n    endianness,\n    dataType: DataType.UINT16,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}i2`, {\n    endianness,\n    dataType: DataType.INT16,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}u4`, {\n    endianness,\n    dataType: DataType.UINT32,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}i4`, {\n    endianness,\n    dataType: DataType.INT32,\n  });\n\n  supportedDataTypes.set(`${endiannessChar}f4`, {\n    endianness,\n    dataType: DataType.FLOAT32,\n  });\n}\n\nexport function parseNumpyDtype(typestr: unknown): NumpyDtype {\n  const dtype = supportedDataTypes.get(typestr as any);\n  if (dtype === undefined) {\n    throw new Error(`Unsupported numpy data type: ${JSON.stringify(typestr)}`);\n  }\n  return dtype;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Basic support for parsing the Python Numpy 'npy' serialization format.\n *\n * See http://docs.scipy.org/doc/numpy-dev/neps/npy-format.html\n */\n\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport type { DataType } from \"#src/util/data_type.js\";\nimport {\n  DATA_TYPE_ARRAY_CONSTRUCTOR,\n  DATA_TYPE_BYTES,\n} from \"#src/util/data_type.js\";\nimport { convertEndian } from \"#src/util/endian.js\";\nimport { pythonLiteralParse } from \"#src/util/json.js\";\nimport { parseNumpyDtype } from \"#src/util/numpy_dtype.js\";\n\nexport class NumpyArray {\n  constructor(\n    public data: TypedNumberArray<ArrayBuffer>,\n    public shape: number[],\n    public dataType: DataType,\n    public fortranOrder: boolean,\n  ) {}\n}\n\nexport function parseNpy(x: Uint8Array<ArrayBuffer>) {\n  // Verify 6-byte magic sequence: 147, 78, 85, 77, 80, 89\n  if (\n    x[0] !== 147 ||\n    x[1] !== 78 ||\n    x[2] !== 85 ||\n    x[3] !== 77 ||\n    x[4] !== 80 ||\n    x[5] !== 89\n  ) {\n    throw new Error(\"Data does not match npy format.\");\n  }\n  const majorVersion = x[6];\n  const minorVersion = x[7];\n  if (majorVersion !== 1 || minorVersion !== 0) {\n    throw new Error(`Unsupported npy version ${majorVersion}.${minorVersion}`);\n  }\n  const dv = new DataView(x.buffer, x.byteOffset, x.byteLength);\n  const headerLength = dv.getUint16(8, /*littleEndian=*/ true);\n  const header = new TextDecoder(\"utf-8\").decode(\n    x.subarray(10, headerLength + 10),\n  );\n  let headerObject: any;\n  const dataOffset = headerLength + 10;\n  try {\n    headerObject = pythonLiteralParse(header);\n  } catch (e) {\n    throw new Error(`Failed to parse npy header: ${e}`);\n  }\n  const dtype = headerObject.descr;\n  const shape = headerObject.shape;\n  let numElements = 1;\n  if (!Array.isArray(shape)) {\n    throw new Error(\"Invalid shape ${JSON.stringify(shape)}\");\n  }\n  for (const dim of shape) {\n    if (typeof dim !== \"number\") {\n      throw new Error(\"Invalid shape ${JSON.stringify(shape)}\");\n    }\n    numElements *= dim;\n  }\n  const { dataType, endianness } = parseNumpyDtype(dtype);\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  const arrayConstructor = DATA_TYPE_ARRAY_CONSTRUCTOR[dataType];\n  if (bytesPerElement * numElements + dataOffset !== x.byteLength) {\n    throw new Error(\"Expected length does not match length of data\");\n  }\n  const data = new arrayConstructor(\n    x.buffer,\n    x.byteOffset + dataOffset,\n    numElements,\n  ) as TypedNumberArray<ArrayBuffer>;\n  convertEndian(data, endianness, bytesPerElement);\n  return new NumpyArray(\n    data,\n    shape,\n    dataType,\n    headerObject.fortran_order === true,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This decodes the BOSS (https://github.com/jhuapl-boss/) NPZ format, which is the Python\n * NPY binary format with zlib encoding.\n *\n * This is NOT the same as the Python NPZ format, which is a ZIP file containing multiple files\n * (each corresponding to a different variable) in NPY binary format.\n */\n\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport { DataType } from \"#src/sliceview/base.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { vec3Key } from \"#src/util/geom.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport { parseNpy } from \"#src/util/npy.js\";\n\nexport async function decodeBossNpzChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const parseResult = parseNpy(\n    new Uint8Array(await decodeGzip(response, \"deflate\")),\n  );\n  const chunkDataSize = chunk.chunkDataSize!;\n  const source = chunk.source!;\n  const { shape } = parseResult;\n  if (\n    shape.length !== 3 ||\n    shape[0] !== chunkDataSize[2] ||\n    shape[1] !== chunkDataSize[1] ||\n    shape[2] !== chunkDataSize[0]\n  ) {\n    throw new Error(\n      `Shape ${JSON.stringify(shape)} does not match chunkDataSize ${vec3Key(\n        chunkDataSize,\n      )}`,\n    );\n  }\n  const parsedDataType = parseResult.dataType;\n  const { spec } = source;\n  if (parsedDataType !== spec.dataType) {\n    throw new Error(\n      `Data type ${\n        DataType[parsedDataType]\n      } does not match expected data type ${DataType[spec.dataType]}`,\n    );\n  }\n  await postProcessRawData(chunk, signal, parseResult.data);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { DecodedImage } from \"#src/async_computation/decode_png_request.js\";\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeJpeg = asyncComputation<\n  (\n    data: Uint8Array<ArrayBuffer>,\n    width: number | undefined,\n    height: number | undefined,\n    // Expected width * height\n    area: number | undefined,\n    numComponents: number | undefined,\n    convertToGrayscale: boolean,\n  ) => DecodedImage\n>(\"decodeJpeg\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeJpegChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const { uint8Array: decoded } = await requestAsyncComputation(\n    decodeJpeg,\n    signal,\n    [response],\n    new Uint8Array(response),\n    undefined,\n    undefined,\n    chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    chunkDataSize[3] || 1,\n    false,\n  );\n  await postProcessRawData(chunk, signal, decoded);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Chunk } from \"#src/chunk_manager/backend.js\";\nimport {\n  SliceViewChunk,\n  SliceViewChunkSourceBackend,\n} from \"#src/sliceview/backend.js\";\nimport type {\n  DataType,\n  SliceViewChunkSpecification,\n} from \"#src/sliceview/base.js\";\nimport type {\n  VolumeChunkSource as VolumeChunkSourceInterface,\n  VolumeChunkSpecification,\n} from \"#src/sliceview/volume/base.js\";\nimport type { vec3 } from \"#src/util/geom.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\n\nexport class VolumeChunk extends SliceViewChunk {\n  source: VolumeChunkSource | null = null;\n  data: ArrayBufferView | null;\n  chunkDataSize: Uint32Array | null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: vec3) {\n    super.initializeVolumeChunk(key, chunkGridPosition);\n    this.chunkDataSize = null;\n    this.data = null;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const chunkDataSize = this.chunkDataSize;\n    if (chunkDataSize !== this.source!.spec.chunkDataSize) {\n      msg.chunkDataSize = chunkDataSize;\n    }\n    const data = (msg.data = this.data);\n    if (data !== null) {\n      transfers.push(data!.buffer);\n    }\n    this.data = null;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes = this.data?.byteLength ?? 0;\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {\n    this.data = null;\n  }\n}\n\ninterface ChunkWithGridPositionAndDataSize extends Chunk {\n  chunkGridPosition: Float32Array;\n  chunkDataSize: Uint32Array | null;\n}\n\ninterface SliceViewChunkSpecWithOffsetAndDatatype\n  extends SliceViewChunkSpecification<Uint32Array> {\n  baseVoxelOffset: Float32Array;\n  dataType: DataType;\n}\n\ninterface ChunkSourceForChunkBounds {\n  spec: SliceViewChunkSpecWithOffsetAndDatatype;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n}\n\n/**\n * Helper function for computing the voxel bounds of a chunk based on its chunkGridPosition.\n *\n * This assumes that the grid of chunk positions starts at this.baseVoxelOffset.  Chunks are\n * clipped to lie within upperVoxelBound, but are not clipped to lie within lowerVoxelBound.  (The\n * frontend code currently cannot handle chunks clipped at their lower corner, and the chunk\n * layout can generally be chosen so that lowerVoxelBound lies on a chunk boundary.)\n *\n * This sets chunk.chunkDataSize to a copy of the returned chunkDataSize if it differs from\n * source.spec.chunkDataSize; otherwise, it is set to source.spec.chunkDataSize.\n *\n * @returns A globally-allocated Vec3 containing the chunk corner position in voxel coordinates.\n * The returned Vec3 will be invalidated by any subsequent call to this method, even on a\n * different VolumeChunkSource instance.\n */\nexport function computeChunkBounds(\n  source: ChunkSourceForChunkBounds,\n  chunk: ChunkWithGridPositionAndDataSize,\n) {\n  const { spec, tempChunkDataSize, tempChunkPosition } = source;\n  const { upperVoxelBound, rank, baseVoxelOffset } = spec;\n\n  const origChunkDataSize = spec.chunkDataSize;\n  const newChunkDataSize = tempChunkDataSize;\n\n  // Chunk start position in voxel coordinates.\n  const chunkPosition = vector.multiply(\n    tempChunkPosition,\n    chunk.chunkGridPosition,\n    origChunkDataSize,\n  );\n\n  // Specifies whether the chunk only partially fits within the data bounds.\n  let partial = false;\n  for (let i = 0; i < rank; ++i) {\n    const upper = Math.min(\n      upperVoxelBound[i],\n      chunkPosition[i] + origChunkDataSize[i],\n    );\n    const size = (newChunkDataSize[i] = upper - chunkPosition[i]);\n    if (size !== origChunkDataSize[i]) {\n      partial = true;\n    }\n  }\n\n  vector.add(chunkPosition, chunkPosition, baseVoxelOffset);\n\n  if (partial) {\n    chunk.chunkDataSize = Uint32Array.from(newChunkDataSize);\n  } else {\n    chunk.chunkDataSize = origChunkDataSize;\n  }\n\n  return chunkPosition;\n}\n\nexport class VolumeChunkSource\n  extends SliceViewChunkSourceBackend\n  implements VolumeChunkSourceInterface\n{\n  declare spec: VolumeChunkSpecification;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    const rank = this.spec.rank;\n    this.tempChunkDataSize = new Uint32Array(rank);\n    this.tempChunkPosition = new Float32Array(rank);\n  }\n\n  computeChunkBounds(chunk: VolumeChunk) {\n    return computeChunkBounds(this, chunk);\n  }\n}\nVolumeChunkSource.prototype.chunkConstructor = VolumeChunk;\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { BossToken } from \"#src/datasource/boss/api.js\";\nimport { fetchWithBossCredentials } from \"#src/datasource/boss/api.js\";\nimport {\n  MeshSourceParameters,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/boss/base.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  decodeJsonManifestChunk,\n  decodeTriangleVertexPositionsAndIndices,\n  MeshSource,\n} from \"#src/mesh/backend.js\";\nimport { decodeBossNpzChunk } from \"#src/sliceview/backend_chunk_decoders/bossNpz.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst chunkDecoders = new Map<string, ChunkDecoder>();\nchunkDecoders.set(\"npz\", decodeBossNpzChunk);\nchunkDecoders.set(\"jpeg\", decodeJpegChunk);\n\nconst acceptHeaders = new Map<string, string>();\nacceptHeaders.set(\"npz\", \"application/npygz\");\nacceptHeaders.set(\"jpeg\", \"image/jpeg\");\n\nfunction BossSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<BossToken>()(Base),\n    parametersConstructor,\n  );\n}\n\n@registerSharedObject()\nexport class BossVolumeChunkSource extends BossSource(\n  VolumeChunkSource,\n  VolumeChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    let url = `${parameters.baseUrl}/latest/cutout/${parameters.collection}/${parameters.experiment}/${parameters.channel}/${parameters.resolution}`;\n    {\n      // chunkPosition must not be captured, since it will be invalidated by the next call to\n      // computeChunkBounds.\n      const chunkPosition = this.computeChunkBounds(chunk);\n      const chunkDataSize = chunk.chunkDataSize!;\n      for (let i = 0; i < 3; ++i) {\n        url += `/${chunkPosition[i]}:${chunkPosition[i] + chunkDataSize[i]}`;\n      }\n    }\n    url += \"/\";\n\n    if (parameters.window !== undefined) {\n      url += `?window=${parameters.window[0]},${parameters.window[1]}`;\n    }\n    const response = await fetchWithBossCredentials(\n      this.credentialsProvider,\n      url,\n      {\n        signal: signal,\n        headers: { Accept: acceptHeaders.get(parameters.encoding)! },\n      },\n    );\n    await this.chunkDecoder(chunk, signal, await response.arrayBuffer());\n  }\n}\n\nfunction decodeManifestChunk(chunk: ManifestChunk, response: any) {\n  return decodeJsonManifestChunk(chunk, response, \"fragments\");\n}\n\nfunction decodeFragmentChunk(chunk: FragmentChunk, response: ArrayBuffer) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class BossMeshSource extends BossSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  download(chunk: ManifestChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    return fetchWithBossCredentials(\n      this.credentialsProvider,\n      `${parameters.baseUrl}${chunk.objectId}`,\n      { signal: signal },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeManifestChunk(chunk, response));\n  }\n\n  downloadFragment(chunk: FragmentChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    return fetchWithBossCredentials(\n      this.credentialsProvider,\n      `${parameters.baseUrl}${chunk.fragmentId}`,\n      { signal: signal },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeFragmentChunk(chunk, response));\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file Facilities for converting between strings and RGB/RGBA colors.\n */\n\nimport { WatchableValue } from \"#src/trackable_value.js\";\nimport { float32ToString } from \"#src/util/float32_to_string.js\";\nimport { vec3, vec4 } from \"#src/util/geom.js\";\nimport { hexEncodeByte } from \"#src/util/hex.js\";\n\n/**\n * Parse the serialization of a color.\n *\n * This is based on the definition here:\n * https://html.spec.whatwg.org/multipage/canvas.html#serialisation-of-a-color\n */\nexport function parseColorSerialization(x: string) {\n  const rgbaPattern =\n    /^rgba\\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\\.[0-9]+)?)\\)$/;\n  {\n    const m = x.match(rgbaPattern);\n    if (m !== null) {\n      return [\n        parseInt(m[1], 10),\n        parseInt(m[2], 10),\n        parseInt(m[3], 10),\n        parseFloat(m[4]),\n      ];\n    }\n  }\n  const hexPattern = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;\n  {\n    const m = x.match(hexPattern);\n    if (m !== null) {\n      return [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 1.0];\n    }\n  }\n  throw new Error(`Invalid serialized color: ${JSON.stringify(x)}.`);\n}\n\nexport function parseRGBAColorSpecification(x: any) {\n  try {\n    if (typeof x !== \"string\") {\n      throw new Error(`Expected string, but received ${JSON.stringify(x)}.`);\n    }\n    const context = document.createElement(\"canvas\").getContext(\"2d\")!;\n    context.fillStyle = x;\n    const result = parseColorSerialization(context.fillStyle);\n    return vec4.fromValues(\n      result[0] / 255,\n      result[1] / 255,\n      result[2] / 255,\n      result[3],\n    );\n  } catch (parseError) {\n    throw new Error(\n      `Failed to parse color specification: ${parseError.message}`,\n    );\n  }\n}\n\nexport function parseRGBColorSpecification(x: any) {\n  const result = parseRGBAColorSpecification(x);\n  return <vec3>result.subarray(0, 3);\n}\n\n/**\n * Returns an integer formed by concatenating the channels of the input color vector.\n * Each channel is clamped to the range [0.0, 1.0] before being converted to 8 bits.\n * An RGB color is packed into 24 bits, and a RGBA into 32 bits.\n */\nexport function packColor(x: vec3 | vec4): number {\n  const size = x[3] === undefined ? 3 : 4;\n  let result = 0;\n  for (let i = 0; i < size; i++) {\n    // The \">>> 0\" ensures an unsigned value.\n    result =\n      ((result << 8) >>> 0) +\n      Math.min(255, Math.max(0, Math.round(x[size - 1 - i] * 255)));\n  }\n  return result;\n}\n\nexport function unpackRGB(value: number) {\n  return vec3.fromValues(\n    ((value >>> 0) & 0xff) / 255,\n    ((value >>> 8) & 0xff) / 255,\n    ((value >>> 16) & 0xff) / 255,\n  );\n}\n\nexport function unpackRGBA(value: number) {\n  return vec4.fromValues(\n    ((value >>> 0) & 0xff) / 255,\n    ((value >>> 8) & 0xff) / 255,\n    ((value >>> 16) & 0xff) / 255,\n    ((value >>> 24) & 0xff) / 255,\n  );\n}\n\nexport function serializeColor(x: vec3 | vec4) {\n  if (x[3] === undefined || x[3] === 1) {\n    let result = \"#\";\n    for (let i = 0; i < 3; ++i) {\n      result += hexEncodeByte(\n        Math.min(255, Math.max(0, Math.round(x[i] * 255))),\n      );\n    }\n    return result;\n  }\n  let result = \"rgba(\";\n  for (let i = 0; i < 3; ++i) {\n    if (i !== 0) {\n      result += \", \";\n    }\n    result += Math.min(255, Math.max(0, Math.round(x[i] * 255)));\n  }\n  result += `, ${float32ToString(x[3])})`;\n  return result;\n}\n\n// Converts an sRGB color component to the gamma-expanded (\"linear\") value.\nexport function srgbGammaExpand(value: number) {\n  return value <= 0.03928 ? value / 12.92 : ((value + 0.055) / 1.055) ** 2.4;\n}\n\n// Computes the relative luminance according to Web Content Accessibility Guidelines (WCAG) 2.0\n//\n// https://www.w3.org/TR/WCAG20/#relativeluminancedef\n//\n// @param color sRGB color\nexport function getRelativeLuminance(color: vec3 | vec4) {\n  const [r, g, b] = color;\n  return (\n    0.2126 * srgbGammaExpand(r) +\n    0.7152 * srgbGammaExpand(g) +\n    0.0722 * srgbGammaExpand(b)\n  );\n}\n\n// Determines whether a white background would provide higher contrast than a black background for\n// the given foreground color.\n//\n// This is determined according to the Web Content Accessibility Guidelines (WCAG) 2.0:\n// https://www.w3.org/TR/WCAG20/#contrast-ratiodef\n//\n// https://stackoverflow.com/a/3943023\nexport function useWhiteBackground(foregroundColor: vec3 | vec4) {\n  return getRelativeLuminance(foregroundColor) <= 0.179;\n}\n\nexport class TrackableRGB extends WatchableValue<vec3> {\n  constructor(public defaultValue: vec3) {\n    super(vec3.clone(defaultValue));\n  }\n  toString() {\n    return serializeColor(this.value);\n  }\n  toJSON() {\n    if (vec3.equals(this.value, this.defaultValue)) {\n      return undefined;\n    }\n    return serializeColor(this.value);\n  }\n  reset() {\n    this.value = vec3.clone(this.defaultValue);\n  }\n  restoreState(x: any) {\n    if (x === undefined) {\n      this.reset();\n      return;\n    }\n    const { value } = this;\n    const newValue = parseRGBColorSpecification(x);\n    if (!vec3.equals(value, newValue)) {\n      this.value = newValue;\n    }\n  }\n}\n\nexport class TrackableOptionalRGB extends WatchableValue<vec3 | undefined> {\n  constructor() {\n    super(undefined);\n  }\n  toJSON() {\n    const { value } = this;\n    if (value === undefined) return undefined;\n    return serializeColor(value);\n  }\n  reset() {\n    this.value = undefined;\n  }\n  restoreState(x: any) {\n    if (x === undefined) {\n      this.reset();\n      return;\n    }\n    const { value } = this;\n    const newValue = parseRGBColorSpecification(x);\n    if (value === undefined || !vec3.equals(value, newValue)) {\n      this.value = newValue;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function hexEncodeByte(x: number) {\n  return (\"0\" + x.toString(16)).slice(-2);\n}\n\nexport function hexEncode(arr: Uint8Array) {\n  return Array.prototype.map.call(arr, hexEncodeByte).join(\"\");\n}\n\nexport function hexDecode(x: string) {\n  if (!/^(?:[0-9a-fA-F]{2})*$/.test(x)) {\n    throw new Error(\"Invalid hex-encoded string\");\n  }\n  const length = x.length / 2;\n  const result = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    result[i] = parseInt(x.substr(i * 2, 2), 16);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright 2021 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Endianness, ENDIANNESS } from \"#src/util/endian.js\";\n\nconst denormMin = 2 ** -1074;\n\nconst float64Buf = new Float64Array(1);\nconst uint32Buf = new Uint32Array(float64Buf.buffer);\n\n// The following implementation is derived from:\n// https://github.com/scijs/nextafter/\n//\n// and is subject to the following license:\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2013 Mikola Lysenko\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Like the C standard library `nextafter` function, returns the next representable JavaScript\n// number (float64) after `x` in the direction of `y`.  Returns `y` if `x === y`.\nexport function nextAfterFloat64(x: number, y: number) {\n  if (Number.isNaN(x) || Number.isNaN(y)) return NaN;\n  if (x === y) return y;\n  if (x === 0) {\n    return y < 0 ? -denormMin : denormMin;\n  }\n  float64Buf[0] = x;\n  const lowIndex = ENDIANNESS === Endianness.LITTLE ? 0 : 1;\n  const highIndex = 1 - lowIndex;\n  if (y > x === x > 0) {\n    if (uint32Buf[lowIndex] === 0xffffffff) {\n      uint32Buf[lowIndex] = 0;\n      uint32Buf[highIndex] += 1;\n    } else {\n      uint32Buf[lowIndex] += 1;\n    }\n  } else {\n    if (uint32Buf[lowIndex] === 0) {\n      uint32Buf[lowIndex] = 0xffffffff;\n      uint32Buf[highIndex] -= 1;\n    } else {\n      uint32Buf[lowIndex] -= 1;\n    }\n  }\n  return float64Buf[0];\n}\n","/**\n * @license\n * Copyright 2021 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  bigintAbs,\n  bigintMax,\n  bigintMin,\n  clampToUint64,\n  roundToUint64,\n  UINT64_MAX,\n} from \"#src/util/bigint.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport { nextAfterFloat64 } from \"#src/util/float.js\";\nimport { parseFixedLengthArray, parseUint64 } from \"#src/util/json.js\";\n\nexport type DataTypeInterval = [number, number] | [bigint, bigint];\n\nexport type UnknownDataTypeInterval = [number | bigint, number | bigint];\n\nexport const defaultDataTypeRange: Record<DataType, DataTypeInterval> = {\n  [DataType.UINT8]: [0, 0xff],\n  [DataType.INT8]: [-0x80, 0x7f],\n  [DataType.UINT16]: [0, 0xffff],\n  [DataType.INT16]: [-0x8000, 0x7fff],\n  [DataType.UINT32]: [0, 0xffffffff],\n  [DataType.INT32]: [-0x80000000, 0x7fffffff],\n  [DataType.UINT64]: [0n, 0xffffffffffffffffn],\n  [DataType.FLOAT32]: [0, 1],\n};\n\n/**\n * Compute inverse linear interpolation on the interval [0, 1].\n * @param range Values at start and end of interval.\n * @param value Value to interpolate at.\n * @returns Coordinate of interpolated point.\n */\nexport function computeInvlerp(\n  range: DataTypeInterval,\n  value: number | bigint,\n): number {\n  const [minValue, maxValue] = range as [any, any];\n  return Number((value as any) - minValue) / Number(maxValue - minValue);\n}\n\n/**\n * Compute linear interpolation on the interval [0, 1].\n * @param range Values at start and end of interval.\n * @param dataType\n * @param value Coordinate to interpolate at.\n * @returns Interpolated value.\n */\nexport function computeLerp(\n  range: DataTypeInterval,\n  dataType: DataType,\n  value: number,\n): number | bigint {\n  if (typeof range[0] === \"number\") {\n    const minValue = range[0] as number;\n    const maxValue = range[1] as number;\n    let result = minValue * (1 - value) + maxValue * value;\n    if (dataType !== DataType.FLOAT32) {\n      const dataTypeRange = defaultDataTypeRange[dataType];\n      result = Math.round(result);\n      result = Math.max(dataTypeRange[0] as number, result);\n      result = Math.min(dataTypeRange[1] as number, result);\n    }\n    return result;\n  }\n  const minValue = range[0] as bigint;\n  const maxValue = range[1] as bigint;\n  const scalar = Number(maxValue - minValue);\n  let result: bigint;\n  if (value >= 1) {\n    result = maxValue + BigInt(Math.round(scalar * (value - 1)));\n  } else {\n    result = minValue + BigInt(Math.round(scalar * value));\n  }\n  return clampToUint64(result);\n}\n\nexport function clampToInterval(\n  range: DataTypeInterval,\n  value: number | bigint,\n): number | bigint {\n  if (typeof value === \"number\") {\n    return Math.min(Math.max(range[0] as number, value), range[1] as number);\n  }\n  return bigintMin(bigintMax(range[0] as bigint, value), range[1] as bigint);\n}\n\nexport function getClampedInterval(\n  bounds: DataTypeInterval,\n  range: DataTypeInterval,\n): DataTypeInterval {\n  return [\n    clampToInterval(bounds, range[0]),\n    clampToInterval(bounds, range[1]),\n  ] as DataTypeInterval;\n}\n\n// Validates that the lower bound is <= the upper bound.\nexport function validateDataTypeInterval(\n  interval: DataTypeInterval,\n): DataTypeInterval {\n  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;\n  throw new Error(`Invalid interval: [${interval[0]}, ${interval[1]}]`);\n}\n\n// Ensures the lower bound is <= the upper bound.\nexport function normalizeDataTypeInterval(\n  interval: DataTypeInterval,\n): DataTypeInterval {\n  if (dataTypeCompare(interval[0], interval[1]) <= 0) return interval;\n  return [interval[1], interval[0]] as DataTypeInterval;\n}\n\nexport function dataTypeCompare(a: number | bigint, b: number | bigint) {\n  return (a as any) < (b as any) ? -1 : (a as any) > (b as any) ? 1 : 0;\n}\n\nexport function getClosestEndpoint(\n  range: DataTypeInterval,\n  value: number | bigint,\n): number {\n  if (typeof value === \"number\") {\n    return Math.abs(value - (range[0] as number)) <\n      Math.abs(value - (range[1] as number))\n      ? 0\n      : 1;\n  }\n  return bigintAbs((range[0] as bigint) - value) <\n    bigintAbs((range[1] as bigint) - value)\n    ? 0\n    : 1;\n}\n\nexport function parseDataTypeValue(\n  dataType: DataType,\n  x: unknown,\n): number | bigint {\n  let s: string;\n  if (typeof x !== \"string\") {\n    s = \"\" + x;\n  } else {\n    s = x;\n  }\n  switch (dataType) {\n    case DataType.UINT64:\n      return parseUint64(s);\n    case DataType.FLOAT32: {\n      const value = parseFloat(s);\n      if (!Number.isFinite(value)) {\n        throw new Error(`Invalid float32 value: ${JSON.stringify(s)}`);\n      }\n      return value;\n    }\n    default: {\n      const value = parseInt(s);\n      const dataTypeRange = defaultDataTypeRange[dataType];\n      if (\n        !Number.isInteger(value) ||\n        value < (dataTypeRange[0] as number) ||\n        value > (dataTypeRange[1] as number)\n      ) {\n        throw new Error(\n          `Invalid ${DataType[dataType].toLowerCase()} value: ${JSON.stringify(\n            s,\n          )}`,\n        );\n      }\n      return value;\n    }\n  }\n}\n\nexport function parseUnknownDataTypeValue(x: unknown): number | bigint {\n  if (typeof x === \"number\") return x;\n  if (typeof x === \"string\") {\n    const num = Number(x);\n    try {\n      const num64 = parseUint64(x);\n      if (num64.toString() === num.toString()) {\n        return num;\n      }\n      return num64;\n    } catch {\n      // Ignore failure to parse as uint64.\n    }\n    if (!Number.isFinite(num)) {\n      throw new Error(`Invalid value: ${JSON.stringify(x)}`);\n    }\n    return num;\n  }\n  throw new Error(`Invalid value: ${JSON.stringify(x)}`);\n}\n\nexport function parseDataTypeInterval(\n  obj: unknown,\n  dataType: DataType,\n): DataTypeInterval {\n  return parseFixedLengthArray(new Array(2), obj, (x) =>\n    parseDataTypeValue(dataType, x),\n  ) as DataTypeInterval;\n}\n\nexport function parseUnknownDataTypeInterval(\n  obj: unknown,\n): UnknownDataTypeInterval {\n  return parseFixedLengthArray(new Array(2), obj, (x) =>\n    parseUnknownDataTypeValue(x),\n  ) as UnknownDataTypeInterval;\n}\n\nexport function dataTypeIntervalEqual(\n  a: DataTypeInterval,\n  b: DataTypeInterval,\n) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nexport function dataTypeIntervalToJson(\n  range: DataTypeInterval,\n  dataType: DataType,\n  defaultRange = defaultDataTypeRange[dataType],\n) {\n  if (dataTypeIntervalEqual(range, defaultRange)) return undefined;\n  if (dataType === DataType.UINT64) {\n    return [range[0].toString(), range[1].toString()];\n  }\n  return range;\n}\n\nexport function dataTypeValueNextAfter(\n  dataType: DataType,\n  value: number | bigint,\n  sign: 1 | -1,\n): number | bigint {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return nextAfterFloat64(value as number, sign * Infinity);\n    case DataType.UINT64: {\n      return clampToUint64((value as bigint) + BigInt(sign));\n    }\n    default: {\n      const range = defaultDataTypeRange[dataType] as [number, number];\n      return Math.max(range[0], Math.min(range[1], (value as number) + sign));\n    }\n  }\n}\n\n// Returns the offset such that within the floating point range `[-offset, 1+offset]`, there is an\n// equal-sized interval corresponding to each number in `interval`.\n//\n// For dataType=FLOAT32, always returns 0.  For integer data types, returns:\n//\n//   0.5 / (1 + abs(interval[1] - interval[0]))\nexport function getIntervalBoundsEffectiveOffset(\n  dataType: DataType,\n  interval: DataTypeInterval,\n) {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return 0;\n    case DataType.UINT64:\n      return (\n        0.5 /\n        Number(bigintAbs((interval[0] as bigint) - (interval[1] as bigint)))\n      );\n    default:\n      return 0.5 / Math.abs((interval[0] as number) - (interval[1] as number));\n  }\n}\n\nexport function getIntervalBoundsEffectiveFraction(\n  dataType: DataType,\n  interval: DataTypeInterval,\n) {\n  switch (dataType) {\n    case DataType.FLOAT32:\n      return 1;\n    case DataType.UINT64: {\n      const diff = Number(\n        bigintAbs((interval[0] as bigint) - (interval[1] as bigint)),\n      );\n      return diff / (diff + 1);\n    }\n    default: {\n      const diff = Math.abs((interval[0] as number) - (interval[1] as number));\n      return diff / (diff + 1);\n    }\n  }\n}\n\nexport function convertDataTypeInterval(\n  interval: UnknownDataTypeInterval | undefined,\n  dataType: DataType,\n): DataTypeInterval {\n  if (interval === undefined) {\n    return defaultDataTypeRange[dataType];\n  }\n  let [lower, upper] = interval;\n  if (dataType === DataType.UINT64) {\n    return [\n      roundToUint64(Number.isNaN(lower) ? 0n : lower),\n      roundToUint64(Number.isNaN(upper) ? UINT64_MAX : upper),\n    ];\n  }\n  lower = Number(lower);\n  upper = Number(upper);\n  if (dataType !== DataType.FLOAT32) {\n    lower = Math.round(lower);\n    upper = Math.round(upper);\n    const range = defaultDataTypeRange[dataType] as [number, number];\n    if (!Number.isFinite(lower)) {\n      lower = range[0];\n    } else {\n      lower = Math.min(Math.max(range[0], lower), range[1]);\n    }\n    if (!Number.isFinite(upper)) {\n      upper = range[1];\n    } else {\n      upper = Math.min(Math.max(range[0], upper), range[1]);\n    }\n  }\n  return [lower, upper];\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport type { OAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\nimport { fetchOkWithOAuth2Credentials } from \"#src/credentials_provider/oauth2.js\";\nimport type { RequestInitWithProgress } from \"#src/util/http_request.js\";\n\nexport type { OAuth2Credentials };\n\nexport type BrainmapsCredentialsProvider =\n  CredentialsProvider<OAuth2Credentials>;\n\n/**\n * Key used for retrieving the CredentialsProvider from a CredentialsManager.\n */\nexport const credentialsKey = \"google-brainmaps\";\n\nexport interface BrainmapsInstance {\n  description: string;\n  /**\n   * One or more server URLs to use to connect to the instance.\n   */\n  serverUrl: string;\n}\n\n/**\n * API-related interfaces.\n */\n\nexport interface ChangeSpecPayload {\n  change_stack_id?: string;\n  time_stamp?: number;\n  skip_equivalences?: boolean;\n}\n\nexport interface ChangeStackAwarePayload {\n  change_spec?: ChangeSpecPayload;\n}\n\nexport interface GeometryPayload {\n  corner: string;\n  size: string;\n  scale: number;\n}\n\nexport interface GeometryAwarePayload {\n  geometry: GeometryPayload;\n}\n\nexport interface ImageFormatOptionsPayload {\n  image_format?: \"AUTO\" | \"JPEG\" | \"PNG\" | \"JSON\";\n  jpeg_quality?: number;\n  compressed_segmentation_block_size?: string;\n}\n\nexport interface SubvolumePayload\n  extends ChangeStackAwarePayload,\n    GeometryAwarePayload {\n  image_format_options?: ImageFormatOptionsPayload;\n  subvolume_format?: \"RAW\" | \"SINGLE_IMAGE\";\n}\n\nexport interface SkeletonPayload extends ChangeStackAwarePayload {\n  object_id: string;\n}\n\nexport interface MeshFragmentPayload extends ChangeStackAwarePayload {\n  fragment_key: string;\n  object_id: string;\n}\n\nexport interface BatchMeshFragment {\n  object_id: string;\n  fragment_keys: string[];\n}\n\nexport interface BatchMeshFragmentPayload {\n  volume_id: string;\n  mesh_name: string;\n  batches: BatchMeshFragment[];\n}\n\nexport function makeRequest(\n  instance: BrainmapsInstance,\n  credentialsProvider: BrainmapsCredentialsProvider,\n  path: string,\n  init: RequestInitWithProgress = {},\n): Promise<Response> {\n  return fetchOkWithOAuth2Credentials(\n    credentialsProvider,\n    `${instance.serverUrl}${path}`,\n    init,\n  );\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Chunk,\n  ChunkRenderLayerBackend,\n  ChunkSource,\n  withChunkManager,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkState } from \"#src/chunk_manager/base.js\";\nimport { decodeVertexPositionsAndIndices } from \"#src/mesh/backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport {\n  forEachVisibleSegment,\n  getObjectKey,\n} from \"#src/segmentation_display_state/base.js\";\nimport { SKELETON_LAYER_RPC_ID } from \"#src/skeleton/base.js\";\nimport type { TypedNumberArray } from \"#src/util/array.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst SKELETON_CHUNK_PRIORITY = 60;\n\n// Chunk that contains the skeleton of a single object.\nexport class SkeletonChunk extends Chunk {\n  objectId: bigint = 0n;\n  vertexPositions: Float32Array | null = null;\n  vertexAttributes: TypedNumberArray[] | null = null;\n  indices: Uint32Array | null = null;\n\n  initializeSkeletonChunk(key: string, objectId: bigint) {\n    super.initialize(key);\n    this.objectId = objectId;\n  }\n  freeSystemMemory() {\n    this.vertexPositions = this.indices = null;\n  }\n\n  private getVertexAttributeBytes() {\n    let total = this.vertexPositions!.byteLength;\n    const { vertexAttributes } = this;\n    if (vertexAttributes != null) {\n      vertexAttributes.forEach((a) => {\n        total += a.byteLength;\n      });\n    }\n    return total;\n  }\n\n  serialize(msg: any, transfers: any[]) {\n    super.serialize(msg, transfers);\n    const vertexPositions = this.vertexPositions!;\n    const indices = this.indices!;\n    msg.numVertices = vertexPositions.length / 3;\n    msg.indices = indices;\n    transfers.push(indices.buffer);\n\n    const { vertexAttributes } = this;\n    if (vertexAttributes != null && vertexAttributes.length > 0) {\n      const vertexData = new Uint8Array(this.getVertexAttributeBytes());\n      vertexData.set(\n        new Uint8Array(\n          vertexPositions.buffer,\n          vertexPositions.byteOffset,\n          vertexPositions.byteLength,\n        ),\n      );\n      const vertexAttributeOffsets = (msg.vertexAttributeOffsets =\n        new Uint32Array(vertexAttributes.length + 1));\n      vertexAttributeOffsets[0] = 0;\n      let offset = vertexPositions.byteLength;\n      vertexAttributes.forEach((a, i) => {\n        vertexAttributeOffsets[i + 1] = offset;\n        vertexData.set(\n          new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n          offset,\n        );\n        offset += a.byteLength;\n      });\n      transfers.push(vertexData.buffer);\n      msg.vertexAttributes = vertexData;\n    } else {\n      msg.vertexAttributes = new Uint8Array(\n        vertexPositions.buffer,\n        vertexPositions.byteOffset,\n        vertexPositions.byteLength,\n      );\n      msg.vertexAttributeOffsets = Uint32Array.of(0);\n      if (vertexPositions.buffer !== transfers[0]) {\n        transfers.push(vertexPositions.buffer);\n      }\n    }\n    this.vertexPositions = this.indices = this.vertexAttributes = null;\n  }\n  downloadSucceeded() {\n    this.systemMemoryBytes = this.gpuMemoryBytes =\n      this.indices!.byteLength + this.getVertexAttributeBytes();\n    super.downloadSucceeded();\n  }\n}\n\nexport class SkeletonSource extends ChunkSource {\n  declare chunks: Map<string, SkeletonChunk>;\n  getChunk(objectId: bigint) {\n    const key = getObjectKey(objectId);\n    let chunk = this.chunks.get(key);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(SkeletonChunk);\n      chunk.initializeSkeletonChunk(key, objectId);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n}\n\n@registerSharedObject(SKELETON_LAYER_RPC_ID)\nexport class SkeletonLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(ChunkRenderLayerBackend)),\n) {\n  source: SkeletonSource;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<SkeletonSource>(options.source),\n    );\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n      }),\n    );\n  }\n\n  private updateChunkPriorities() {\n    const visibility = this.visibility.value;\n    if (visibility === Number.NEGATIVE_INFINITY) {\n      return;\n    }\n    this.chunkManager.registerLayer(this);\n    const priorityTier = getPriorityTier(visibility);\n    const basePriority = getBasePriority(visibility);\n    const { source, chunkManager } = this;\n    forEachVisibleSegment(this, (objectId) => {\n      const chunk = source.getChunk(objectId);\n      ++this.numVisibleChunksNeeded;\n      if (chunk.state === ChunkState.GPU_MEMORY) {\n        ++this.numVisibleChunksAvailable;\n      }\n      chunkManager.requestChunk(\n        chunk,\n        priorityTier,\n        basePriority + SKELETON_CHUNK_PRIORITY,\n      );\n    });\n  }\n}\n\n/**\n * Extracts vertex positions and edge vertex indices of the specified endianness from `data'.\n *\n * See documentation of decodeVertexPositionsAndIndices.\n */\nexport function decodeSkeletonVertexPositionsAndIndices(\n  chunk: SkeletonChunk,\n  data: ArrayBuffer,\n  endianness: Endianness,\n  vertexByteOffset: number,\n  numVertices: number,\n  indexByteOffset?: number,\n  numEdges?: number,\n) {\n  const meshData = decodeVertexPositionsAndIndices(\n    /*verticesPerPrimitive=*/ 2,\n    data,\n    endianness,\n    vertexByteOffset,\n    numVertices,\n    indexByteOffset,\n    numEdges,\n  );\n  chunk.vertexPositions = meshData.vertexPositions as Float32Array;\n  chunk.indices = meshData.indices as Uint32Array;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeCompressedSegmentationChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  signal;\n  chunk.data = new Uint32Array(response);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { DATA_TYPE_BYTES, makeDataTypeArrayView } from \"#src/util/data_type.js\";\nimport type { Endianness } from \"#src/util/endian.js\";\nimport { convertEndian, ENDIANNESS } from \"#src/util/endian.js\";\nimport * as vector from \"#src/util/vector.js\";\n\nexport async function decodeRawChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n  endianness: Endianness = ENDIANNESS,\n  byteOffset = 0,\n  byteLength: number = response.byteLength,\n) {\n  signal;\n  const { spec } = chunk.source!;\n  const { dataType } = spec;\n  const numElements = vector.prod(chunk.chunkDataSize!);\n  const bytesPerElement = DATA_TYPE_BYTES[dataType];\n  const expectedBytes = numElements * bytesPerElement;\n  if (expectedBytes !== byteLength) {\n    throw new Error(\n      `Raw-format chunk is ${byteLength} bytes, ` +\n        `but ${numElements} * ${bytesPerElement} = ${expectedBytes} bytes are expected.`,\n    );\n  }\n  const data = makeDataTypeArrayView(\n    dataType,\n    response,\n    byteOffset,\n    byteLength,\n  );\n  convertEndian(data, endianness, bytesPerElement);\n  await postProcessRawData(chunk, signal, data);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AnnotationGeometryChunk,\n  AnnotationMetadataChunk,\n  AnnotationSubsetGeometryChunk,\n} from \"#src/annotation/backend.js\";\nimport {\n  AnnotationGeometryChunkSourceBackend,\n  AnnotationGeometryData,\n  AnnotationSource,\n} from \"#src/annotation/backend.js\";\nimport type { Annotation, AnnotationId } from \"#src/annotation/index.js\";\nimport {\n  AnnotationSerializer,\n  AnnotationType,\n  makeAnnotationPropertySerializers,\n} from \"#src/annotation/index.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type {\n  BatchMeshFragment,\n  BatchMeshFragmentPayload,\n  BrainmapsInstance,\n  ChangeStackAwarePayload,\n  OAuth2Credentials,\n  SkeletonPayload,\n  SubvolumePayload,\n} from \"#src/datasource/brainmaps/api.js\";\nimport { makeRequest } from \"#src/datasource/brainmaps/api.js\";\nimport type { ChangeSpec } from \"#src/datasource/brainmaps/base.js\";\nimport {\n  AnnotationSourceParameters,\n  AnnotationSpatialIndexSourceParameters,\n  MeshSourceParameters,\n  MultiscaleMeshSourceParameters,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeSourceParameters,\n} from \"#src/datasource/brainmaps/base.js\";\nimport type {\n  FragmentChunk,\n  ManifestChunk,\n  MultiscaleFragmentChunk,\n  MultiscaleManifestChunk,\n} from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  assignMultiscaleMeshFragmentData,\n  generateHigherOctreeLevel,\n  MeshSource,\n  MultiscaleMeshSource,\n} from \"#src/mesh/backend.js\";\nimport { VertexPositionFormat } from \"#src/mesh/base.js\";\nimport type { MultiscaleMeshManifest } from \"#src/mesh/multiscale.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport {\n  decodeSkeletonVertexPositionsAndIndices,\n  SkeletonSource,\n} from \"#src/skeleton/backend.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { convertEndian32, Endianness } from \"#src/util/endian.js\";\nimport { kInfinityVec, kZeroVec, vec3, vec3Key } from \"#src/util/geom.js\";\nimport {\n  parseArray,\n  parseFixedLengthArray,\n  parseUint64,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalString,\n  verifyString,\n  verifyStringArray,\n} from \"#src/util/json.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\nimport * as vector from \"#src/util/vector.js\";\nimport {\n  decodeZIndexCompressed,\n  encodeZIndexCompressed3d,\n  getOctreeChildIndex,\n  zorder3LessThan,\n} from \"#src/util/zorder.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst CHUNK_DECODERS = new Map([\n  [VolumeChunkEncoding.RAW, decodeRawChunk],\n  [VolumeChunkEncoding.JPEG, decodeJpegChunk],\n  [\n    VolumeChunkEncoding.COMPRESSED_SEGMENTATION,\n    decodeCompressedSegmentationChunk,\n  ],\n]);\n\nfunction applyChangeStack(\n  changeStack: ChangeSpec | undefined,\n  payload: ChangeStackAwarePayload,\n) {\n  if (!changeStack) {\n    return;\n  }\n  payload.change_spec = {\n    change_stack_id: changeStack.changeStackId,\n  };\n  if (changeStack.timeStamp) {\n    payload.change_spec.time_stamp = changeStack.timeStamp;\n  }\n  if (changeStack.skipEquivalences) {\n    payload.change_spec.skip_equivalences = changeStack.skipEquivalences;\n  }\n}\n\nfunction BrainmapsSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<OAuth2Credentials>()(Base),\n    parametersConstructor,\n  );\n}\n\n@registerSharedObject()\nexport class BrainmapsVolumeChunkSource extends BrainmapsSource(\n  VolumeChunkSource,\n  VolumeSourceParameters,\n) {\n  chunkDecoder = CHUNK_DECODERS.get(this.parameters.encoding)!;\n\n  private applyEncodingParams(payload: SubvolumePayload) {\n    const { encoding } = this.parameters;\n    switch (encoding) {\n      case VolumeChunkEncoding.RAW:\n        payload.subvolume_format = \"RAW\";\n        break;\n      case VolumeChunkEncoding.JPEG:\n        payload.subvolume_format = \"SINGLE_IMAGE\";\n        payload.image_format_options = {\n          image_format: \"JPEG\",\n          jpeg_quality: this.parameters.jpegQuality!,\n        };\n        return;\n      case VolumeChunkEncoding.COMPRESSED_SEGMENTATION:\n        payload.subvolume_format = \"RAW\";\n        payload.image_format_options = {\n          compressed_segmentation_block_size: vec3Key(\n            this.spec.compressedSegmentationBlockSize!,\n          ),\n        };\n        break;\n      default:\n        throw new Error(`Invalid encoding: ${encoding}`);\n    }\n  }\n\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    const { parameters } = this;\n\n    // chunkPosition must not be captured, since it will be invalidated by the next call to\n    // computeChunkBounds.\n    const chunkPosition = this.computeChunkBounds(chunk);\n    const chunkDataSize = chunk.chunkDataSize!;\n    const path = `/v1/volumes/${parameters.volumeId}/subvolume:binary`;\n\n    const payload: SubvolumePayload = {\n      geometry: {\n        corner: vec3Key(chunkPosition),\n        size: vec3Key(chunkDataSize),\n        scale: parameters.scaleIndex,\n      },\n    };\n\n    this.applyEncodingParams(payload);\n    applyChangeStack(parameters.changeSpec, payload);\n\n    const response = await makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      path,\n      {\n        method: \"POST\",\n        body: JSON.stringify(payload),\n        signal: signal,\n      },\n    );\n    await this.chunkDecoder(chunk, signal, await response.arrayBuffer());\n  }\n}\n\nfunction getFragmentCorner(\n  fragmentId: string,\n  xBits: number,\n  yBits: number,\n  zBits: number,\n): Uint32Array {\n  const value = parseUint64(BigInt(\"0x\" + fragmentId));\n  return decodeZIndexCompressed(value, xBits, yBits, zBits);\n}\n\ninterface BrainmapsMultiscaleManifestChunk extends MultiscaleManifestChunk {\n  fragmentSupervoxelIds: { fragmentId: string; supervoxelIds: string[] }[];\n}\n\nfunction decodeMultiscaleManifestChunk(\n  chunk: BrainmapsMultiscaleManifestChunk,\n  response: any,\n) {\n  verifyObject(response);\n  const source = chunk.source as BrainmapsMultiscaleMeshSource;\n  const fragmentKeys = verifyObjectProperty(\n    response,\n    \"fragmentKey\",\n    verifyStringArray,\n  );\n  const supervoxelIds = verifyObjectProperty(\n    response,\n    \"supervoxelId\",\n    verifyStringArray,\n  );\n  const length = fragmentKeys.length;\n  if (length !== supervoxelIds.length) {\n    throw new Error(\n      \"Expected fragmentKey and supervoxelId arrays to have the same length.\",\n    );\n  }\n  const fragmentSupervoxelIds = new Map<string, string[]>();\n  fragmentKeys.forEach((fragmentId, i) => {\n    let ids = fragmentSupervoxelIds.get(fragmentId);\n    if (ids === undefined) {\n      ids = [];\n      fragmentSupervoxelIds.set(fragmentId, ids);\n    }\n    ids.push(supervoxelIds[i]);\n  });\n  const { chunkShape } = source.parameters.info;\n  const gridShape = source.parameters.info.lods[0].gridShape;\n  const xBits = Math.ceil(Math.log2(gridShape[0]));\n  const yBits = Math.ceil(Math.log2(gridShape[1]));\n  const zBits = Math.ceil(Math.log2(gridShape[2]));\n  const fragmentIdAndCorners = Array.from(fragmentSupervoxelIds.entries()).map(\n    ([id, supervoxelIds]) => ({\n      fragmentId: id,\n      corner: getFragmentCorner(id, xBits, yBits, zBits),\n      supervoxelIds,\n    }),\n  );\n  fragmentIdAndCorners.sort((a, b) => {\n    return zorder3LessThan(\n      a.corner[0],\n      a.corner[1],\n      a.corner[2],\n      b.corner[0],\n      b.corner[1],\n      b.corner[2],\n    )\n      ? -1\n      : 1;\n  });\n  let clipLowerBound: vec3;\n  let clipUpperBound: vec3;\n  let minNumLods = 0;\n  let octree: Uint32Array;\n  if (length === 0) {\n    clipLowerBound = clipUpperBound = kZeroVec;\n    octree = Uint32Array.of(0, 0, 0, 0, 0x80000000);\n  } else {\n    const minCoord = vec3.clone(kInfinityVec);\n    const maxCoord = vec3.clone(kZeroVec);\n    fragmentIdAndCorners.forEach((x) => {\n      const { corner } = x;\n      for (let i = 0; i < 3; ++i) {\n        minCoord[i] = Math.min(minCoord[i], corner[i]);\n        maxCoord[i] = Math.max(maxCoord[i], corner[i]);\n      }\n    });\n    minNumLods = 1;\n    while (\n      maxCoord[0] >>> (minNumLods - 1) !== minCoord[0] >>> (minNumLods - 1) ||\n      maxCoord[1] >>> (minNumLods - 1) !== minCoord[1] >>> (minNumLods - 1) ||\n      maxCoord[2] >>> (minNumLods - 1) !== minCoord[2] >>> (minNumLods - 1)\n    ) {\n      ++minNumLods;\n    }\n    clipLowerBound = vec3.multiply(minCoord, minCoord, chunkShape);\n    clipUpperBound = vec3.add(\n      maxCoord,\n      vec3.multiply(maxCoord, maxCoord, chunkShape),\n      chunkShape,\n    );\n  }\n  const { lods } = source.parameters.info;\n  const lodScales = new Float32Array(Math.max(lods.length, minNumLods));\n  for (let lodIndex = 0; lodIndex < lods.length; ++lodIndex) {\n    lodScales[lodIndex] = lods[lodIndex].scale;\n  }\n\n  if (length !== 0) {\n    const octreeTemp = new Uint32Array(\n      fragmentIdAndCorners.length * lodScales.length * 5,\n    );\n    fragmentIdAndCorners.forEach((x, i) => {\n      octreeTemp.set(x.corner, i * 5);\n      octreeTemp[i * 5] = x.corner[0];\n    });\n    let priorStart = 0;\n    let priorEnd = fragmentIdAndCorners.length;\n    for (let lod = 1; lod < lodScales.length; ++lod) {\n      const curEnd = generateHigherOctreeLevel(\n        octreeTemp,\n        priorStart,\n        priorEnd,\n      );\n      priorStart = priorEnd;\n      priorEnd = curEnd;\n    }\n    octree = octreeTemp.slice(0, priorEnd * 5);\n  }\n\n  const manifest: MultiscaleMeshManifest = {\n    chunkShape,\n    chunkGridSpatialOrigin: kZeroVec,\n    clipLowerBound,\n    clipUpperBound,\n    octree: octree!,\n    lodScales: lodScales,\n    vertexOffsets: new Float32Array(lodScales.length * 3),\n  };\n  chunk.manifest = manifest;\n  chunk.fragmentSupervoxelIds = fragmentIdAndCorners;\n}\n\nconst maxMeshBatchSize = 255;\n\ninterface BatchMeshResponseFragment {\n  fullKey: string;\n  buffer: ArrayBuffer;\n  verticesOffset: number;\n  indicesOffset: number;\n  numVertices: number;\n  numIndices: number;\n}\n\nfunction decodeBatchMeshResponse(\n  response: ArrayBuffer,\n  callback: (fragment: BatchMeshResponseFragment) => void,\n) {\n  const length = response.byteLength;\n  let index = 0;\n  const dataView = new DataView(response);\n  const headerSize =\n    /*object id*/ 8 +\n    /*fragment key length*/ 8 +\n    /*num vertices*/ 8 +\n    /*num triangles*/ 8;\n  while (index < length) {\n    if (index + headerSize > length) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const objectId = dataView.getBigUint64(index, /*littleEndian=*/ true);\n    const objectIdString = objectId.toString();\n    const prefix = objectIdString + \"\\0\";\n    index += 8;\n    const fragmentKeyLength = dataView.getUint32(index, /*littleEndian=*/ true);\n    const fragmentKeyLengthHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    if (fragmentKeyLengthHigh !== 0) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    if (\n      index + fragmentKeyLength + /* num vertices */ 8 + /*num indices*/ 8 >\n      length\n    ) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const fragmentKey = new TextDecoder().decode(\n      new Uint8Array(response, index, fragmentKeyLength),\n    );\n    const fullKey = prefix + fragmentKey;\n    index += fragmentKeyLength;\n    const numVertices = dataView.getUint32(index, /*littleEndian=*/ true);\n    const numVerticesHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    const numTriangles = dataView.getUint32(index, /*littleEndian=*/ true);\n    const numTrianglesHigh = dataView.getUint32(\n      index + 4,\n      /*littleEndian=*/ true,\n    );\n    index += 8;\n    if (numVerticesHigh !== 0 || numTrianglesHigh !== 0) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    const endOffset = index + numTriangles * 12 + numVertices * 12;\n    if (endOffset > length) {\n      throw new Error(\"Invalid batch mesh fragment response.\");\n    }\n    callback({\n      fullKey,\n      buffer: response,\n      verticesOffset: index,\n      numVertices,\n      indicesOffset: index + 12 * numVertices,\n      numIndices: numTriangles * 3,\n    });\n    index = endOffset;\n  }\n}\n\nfunction combineBatchMeshFragments(fragments: BatchMeshResponseFragment[]) {\n  let totalVertices = 0;\n  let totalIndices = 0;\n  for (const fragment of fragments) {\n    totalVertices += fragment.numVertices;\n    totalIndices += fragment.numIndices;\n  }\n  const vertexBuffer = new Float32Array(totalVertices * 3);\n  const indexBuffer = new Uint32Array(totalIndices);\n  let vertexOffset = 0;\n  let indexOffset = 0;\n  for (const fragment of fragments) {\n    vertexBuffer.set(\n      new Float32Array(\n        fragment.buffer,\n        fragment.verticesOffset,\n        fragment.numVertices * 3,\n      ),\n      vertexOffset * 3,\n    );\n    const { numIndices } = fragment;\n    const sourceIndices = new Uint32Array(\n      fragment.buffer,\n      fragment.indicesOffset,\n      numIndices,\n    );\n    convertEndian32(sourceIndices, Endianness.LITTLE);\n    for (let i = 0; i < numIndices; ++i) {\n      indexBuffer[indexOffset++] = sourceIndices[i] + vertexOffset;\n    }\n    vertexOffset += fragment.numVertices;\n  }\n  convertEndian32(vertexBuffer, Endianness.LITTLE);\n  return { vertexPositions: vertexBuffer, indices: indexBuffer };\n}\n\nasync function makeBatchMeshRequest<T>(\n  credentialsProvider: CredentialsProvider<OAuth2Credentials>,\n  parameters: {\n    instance: BrainmapsInstance;\n    volumeId: string;\n    meshName: string;\n  },\n  ids: Map<string, T>,\n  signal: AbortSignal,\n): Promise<ArrayBuffer> {\n  const path = \"/v1/objects/meshes:batch\";\n  const batches: BatchMeshFragment[] = [];\n  let prevObjectId: string | undefined;\n  let batchSize = 0;\n  const pendingIds = new Map<string, T>();\n  for (const [id, idData] of ids) {\n    pendingIds.set(id, idData);\n    ids.delete(id);\n    const splitIndex = id.indexOf(\"\\0\");\n    const objectId = id.substring(0, splitIndex);\n    const fragmentId = id.substring(splitIndex + 1);\n    if (objectId !== prevObjectId) {\n      batches.push({ object_id: objectId, fragment_keys: [] });\n    }\n    batches[batches.length - 1].fragment_keys.push(fragmentId);\n    if (++batchSize === maxMeshBatchSize) break;\n  }\n  const payload: BatchMeshFragmentPayload = {\n    volume_id: parameters.volumeId,\n    mesh_name: parameters.meshName,\n    batches: batches,\n  };\n  try {\n    return await (\n      await makeRequest(parameters.instance, credentialsProvider, path, {\n        method: \"POST\",\n        body: JSON.stringify(payload),\n        signal: signal,\n      })\n    ).arrayBuffer();\n  } finally {\n    for (const [id, idData] of pendingIds) {\n      ids.set(id, idData);\n    }\n  }\n}\n\n@registerSharedObject()\nexport class BrainmapsMultiscaleMeshSource extends BrainmapsSource(\n  MultiscaleMeshSource,\n  MultiscaleMeshSourceParameters,\n) {\n  private listFragmentsParams = (() => {\n    const { parameters } = this;\n    const { changeSpec } = parameters;\n    if (changeSpec !== undefined) {\n      return `&header.changeStackId=${changeSpec.changeStackId}`;\n    }\n    return \"\";\n  })();\n\n  download(chunk: BrainmapsMultiscaleManifestChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const path =\n      `/v1/objects/${parameters.volumeId}/meshes/` +\n      `${parameters.info.lods[0].info.name}:listfragments?` +\n      `object_id=${chunk.objectId}&return_supervoxel_ids=true` +\n      this.listFragmentsParams;\n    return makeRequest(parameters.instance, this.credentialsProvider, path, {\n      signal: signal,\n    })\n      .then((response) => response.json())\n      .then((response) => decodeMultiscaleManifestChunk(chunk, response));\n  }\n\n  async downloadFragment(chunk: MultiscaleFragmentChunk, signal: AbortSignal) {\n    const { parameters } = this;\n\n    const manifestChunk =\n      chunk.manifestChunk! as BrainmapsMultiscaleManifestChunk;\n    const { fragmentSupervoxelIds } = manifestChunk;\n    const manifest = manifestChunk.manifest!;\n    const { lod } = chunk;\n    const { octree } = manifest;\n    const numBaseChunks = fragmentSupervoxelIds.length;\n    const row = chunk.chunkIndex;\n    let startChunkIndex = row;\n    while (startChunkIndex >= numBaseChunks) {\n      startChunkIndex = octree[startChunkIndex * 5 + 3];\n    }\n    let endChunkIndex = row + 1;\n    while (endChunkIndex > numBaseChunks) {\n      endChunkIndex = octree[endChunkIndex * 5 - 1] & 0x7fffffff;\n    }\n    const { relativeBlockShape, gridShape } = parameters.info.lods[lod];\n    const xBits = Math.ceil(Math.log2(gridShape[0]));\n    const yBits = Math.ceil(Math.log2(gridShape[1]));\n    const zBits = Math.ceil(Math.log2(gridShape[2]));\n\n    let ids = new Map<string, number>();\n    for (\n      let chunkIndex = startChunkIndex;\n      chunkIndex < endChunkIndex;\n      ++chunkIndex\n    ) {\n      // Determine number of x, y, and z bits to skip.\n      const gridX = Math.floor(octree[chunkIndex * 5] / relativeBlockShape[0]);\n      const gridY = Math.floor(\n        octree[chunkIndex * 5 + 1] / relativeBlockShape[1],\n      );\n      const gridZ = Math.floor(\n        octree[chunkIndex * 5 + 2] / relativeBlockShape[2],\n      );\n      const fragmentKey = encodeZIndexCompressed3d(\n        xBits,\n        yBits,\n        zBits,\n        gridX,\n        gridY,\n        gridZ,\n      )\n        .toString(16)\n        .padStart(16, \"0\");\n      const entry = fragmentSupervoxelIds[chunkIndex];\n      for (const supervoxelId of entry.supervoxelIds) {\n        ids.set(supervoxelId + \"\\0\" + fragmentKey, chunkIndex);\n      }\n    }\n\n    const prevLod = Math.max(0, lod - 1);\n\n    const fragments: (BatchMeshResponseFragment & { chunkIndex: number })[] =\n      [];\n\n    const idArray = Array.from(ids);\n    idArray.sort((a, b) => defaultStringCompare(a[0], b[0]));\n    ids = new Map(idArray);\n\n    const meshName = parameters.info.lods[lod].info.name;\n\n    const parallelRequests = true;\n\n    await new Promise((resolve, reject) => {\n      let requestsInProgress = 0;\n      let error = false;\n      const maybeIssueMoreRequests = () => {\n        if (error) return;\n        while (ids.size !== 0) {\n          ++requestsInProgress;\n          makeBatchMeshRequest(\n            this.credentialsProvider,\n            {\n              instance: parameters.instance,\n              volumeId: parameters.volumeId,\n              meshName,\n            },\n            ids,\n            signal,\n          )\n            .then((response) => {\n              --requestsInProgress;\n              decodeBatchMeshResponse(\n                response,\n                (\n                  fragment: BatchMeshResponseFragment & { chunkIndex: number },\n                ) => {\n                  const chunkIndex = ids.get(fragment.fullKey)!;\n                  if (!ids.delete(fragment.fullKey)) {\n                    throw new Error(\n                      `Received unexpected fragment key: ${JSON.stringify(\n                        fragment.fullKey,\n                      )}.`,\n                    );\n                  }\n                  fragment.chunkIndex = chunkIndex;\n                  fragments.push(fragment);\n                },\n              );\n              maybeIssueMoreRequests();\n            })\n            .catch((e) => {\n              error = true;\n              reject(e);\n            });\n          if (!parallelRequests) break;\n        }\n        // Notify the chunk queue of the number of download slots being used.  This partially limits\n        // parallelism by maximum number of concurrent downloads, and avoids fetch errors due to an\n        // excessive number of concurrent requests.\n        //\n        // Note that the limit on the number of concurrent downloads is not enforced perfectly.  If\n        // the new value of `downloadSlots` results in the total number of concurrent downloads\n        // exceeding the maximum allowed, the concurrent requests are still issued.  However, no\n        // additional lower-priority chunks will be promoted to `ChunkState.DOWNLOADING` until a\n        // download slot is available.\n        chunk.downloadSlots = Math.max(1, requestsInProgress);\n        if (requestsInProgress === 0) {\n          resolve(undefined);\n          return;\n        }\n      };\n      maybeIssueMoreRequests();\n    });\n\n    // Combine fragments\n    fragments.sort((a, b) => a.chunkIndex - b.chunkIndex);\n    let indexOffset = 0;\n    const numSubChunks = 1 << (3 * (lod - prevLod));\n    const subChunkOffsets = new Uint32Array(numSubChunks + 1);\n    let prevSubChunkIndex = 0;\n    for (const fragment of fragments) {\n      const row = fragment.chunkIndex;\n      const subChunkIndex =\n        getOctreeChildIndex(\n          octree[row * 5] >>> prevLod,\n          octree[row * 5 + 1] >>> prevLod,\n          octree[row * 5 + 2] >>> prevLod,\n        ) &\n        (numSubChunks - 1);\n      subChunkOffsets.fill(\n        indexOffset,\n        prevSubChunkIndex + 1,\n        subChunkIndex + 1,\n      );\n      prevSubChunkIndex = subChunkIndex;\n      indexOffset += fragment.numIndices;\n    }\n    subChunkOffsets.fill(indexOffset, prevSubChunkIndex + 1, numSubChunks + 1);\n    assignMultiscaleMeshFragmentData(\n      chunk,\n      { ...combineBatchMeshFragments(fragments), subChunkOffsets },\n      VertexPositionFormat.float32,\n    );\n  }\n}\n\nfunction groupFragmentsIntoBatches(ids: string[]) {\n  const batches = [];\n  let index = 0;\n  const length = ids.length;\n  while (index < length) {\n    batches.push(JSON.stringify(ids.slice(index, index + maxMeshBatchSize)));\n    index += maxMeshBatchSize;\n  }\n  return batches;\n}\n\nfunction decodeManifestChunkWithSupervoxelIds(\n  chunk: ManifestChunk,\n  response: any,\n) {\n  verifyObject(response);\n  const fragmentKeys = verifyObjectProperty(\n    response,\n    \"fragmentKey\",\n    verifyStringArray,\n  );\n  const supervoxelIds = verifyObjectProperty(\n    response,\n    \"supervoxelId\",\n    verifyStringArray,\n  );\n  const length = fragmentKeys.length;\n  if (length !== supervoxelIds.length) {\n    throw new Error(\n      \"Expected fragmentKey and supervoxelId arrays to have the same length.\",\n    );\n  }\n  const fragmentIds = supervoxelIds.map(\n    (supervoxelId, index) => supervoxelId + \"\\0\" + fragmentKeys[index],\n  );\n  chunk.fragmentIds = groupFragmentsIntoBatches(fragmentIds);\n}\n\n@registerSharedObject()\nexport class BrainmapsMeshSource extends BrainmapsSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  private listFragmentsParams = (() => {\n    const { parameters } = this;\n    const { changeSpec } = parameters;\n    if (changeSpec !== undefined) {\n      return `&header.changeStackId=${changeSpec.changeStackId}`;\n    }\n    return \"\";\n  })();\n\n  download(chunk: ManifestChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const path =\n      `/v1/objects/${parameters.volumeId}/meshes/` +\n      `${parameters.meshName}:listfragments?` +\n      `object_id=${chunk.objectId}&return_supervoxel_ids=true` +\n      this.listFragmentsParams;\n    return makeRequest(parameters.instance, this.credentialsProvider, path, {\n      signal,\n    })\n      .then((response) => response.json())\n      .then((response) =>\n        decodeManifestChunkWithSupervoxelIds(chunk, response),\n      );\n  }\n\n  async downloadFragment(chunk: FragmentChunk, signal: AbortSignal) {\n    const { parameters } = this;\n\n    const ids = new Map<string, null>();\n    for (const id of JSON.parse(chunk.fragmentId!)) {\n      ids.set(id, null);\n    }\n\n    const fragments: BatchMeshResponseFragment[] = [];\n\n    const { credentialsProvider } = this;\n\n    while (ids.size !== 0) {\n      const response = await makeBatchMeshRequest(\n        credentialsProvider,\n        parameters,\n        ids,\n        signal,\n      );\n      decodeBatchMeshResponse(response, (fragment) => {\n        if (!ids.delete(fragment.fullKey)) {\n          throw new Error(\n            `Received unexpected fragment key: ${JSON.stringify(\n              fragment.fullKey,\n            )}.`,\n          );\n        }\n        fragments.push(fragment);\n      });\n    }\n    assignMeshFragmentData(chunk, combineBatchMeshFragments(fragments));\n  }\n}\n\nfunction decodeSkeletonChunk(chunk: SkeletonChunk, response: ArrayBuffer) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  const numVerticesHigh = dv.getUint32(4, true);\n  if (numVerticesHigh !== 0) {\n    throw new Error(\"The number of vertices should not exceed 2^32-1.\");\n  }\n  const numEdges = dv.getUint32(8, true);\n  const numEdgesHigh = dv.getUint32(12, true);\n  if (numEdgesHigh !== 0) {\n    throw new Error(\"The number of edges should not exceed 2^32-1.\");\n  }\n  decodeSkeletonVertexPositionsAndIndices(\n    chunk,\n    response,\n    Endianness.LITTLE,\n    /*vertexByteOffset=*/ 16,\n    numVertices,\n    /*indexByteOffset=*/ undefined,\n    /*numEdges=*/ numEdges,\n  );\n}\n\n@registerSharedObject()\nexport class BrainmapsSkeletonSource extends BrainmapsSource(\n  SkeletonSource,\n  SkeletonSourceParameters,\n) {\n  download(chunk: SkeletonChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const payload: SkeletonPayload = {\n      object_id: `${chunk.objectId}`,\n    };\n    const path =\n      `/v1/objects/${parameters.volumeId}` +\n      `/meshes/${parameters.meshName}` +\n      \"/skeleton:binary\";\n    applyChangeStack(parameters.changeSpec, payload);\n    return makeRequest(parameters.instance, this.credentialsProvider, path, {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      signal,\n    })\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeSkeletonChunk(chunk, response));\n  }\n}\n\nconst spatialAnnotationTypes = [\"LOCATION\", \"LINE\", \"VOLUME\"];\n\nfunction parseCommaSeparatedPoint(x: string) {\n  const pattern = /(-?[0-9]+),(-?[0-9]+),(-?[0-9]+)/;\n  const cornerParts = x.match(pattern);\n  if (cornerParts === null) {\n    throw new Error(`Error parsing number triplet: ${JSON.stringify(x)}.`);\n  }\n  return vec3.fromValues(\n    parseFloat(cornerParts[1]),\n    parseFloat(cornerParts[2]),\n    parseFloat(cornerParts[3]),\n  );\n}\n\nfunction getIdPrefix(parameters: AnnotationSourceParameters) {\n  return parameters.volumeId + \":\" + parameters.changestack + \":\";\n}\n\nfunction parseBrainmapsAnnotationId(idPrefix: string, fullId: string) {\n  if (!fullId.startsWith(idPrefix)) {\n    throw new Error(\n      `Received annotation id ${JSON.stringify(\n        fullId,\n      )} does not have expected prefix of ${JSON.stringify(idPrefix)}.`,\n    );\n  }\n  const id = fullId.substring(idPrefix.length);\n  return id;\n}\n\nfunction parseObjectLabels(obj: any): BigUint64Array[] | undefined {\n  if (obj == null) {\n    return undefined;\n  }\n  return [BigUint64Array.from(parseArray(obj, parseUint64))];\n}\n\nfunction parseAnnotation(\n  entry: any,\n  idPrefix: string,\n  expectedId?: string,\n): Annotation {\n  const corner = verifyObjectProperty(entry, \"corner\", (x) =>\n    parseCommaSeparatedPoint(verifyString(x)),\n  );\n  const size = verifyObjectProperty(entry, \"size\", (x) =>\n    parseCommaSeparatedPoint(verifyString(x)),\n  );\n  const description = verifyObjectProperty(\n    entry,\n    \"payload\",\n    verifyOptionalString,\n  );\n  const spatialAnnotationType = verifyObjectProperty(\n    entry,\n    \"type\",\n    verifyString,\n  );\n  const fullId = verifyObjectProperty(entry, \"id\", verifyString);\n  const id = parseBrainmapsAnnotationId(idPrefix, fullId);\n  const segments = verifyObjectProperty(\n    entry,\n    \"objectLabels\",\n    parseObjectLabels,\n  );\n  if (expectedId !== undefined && id !== expectedId) {\n    throw new Error(\n      `Received annotation has unexpected id ${JSON.stringify(fullId)}.`,\n    );\n  }\n  switch (spatialAnnotationType) {\n    case \"LOCATION\": {\n      if (vec3.equals(size, kZeroVec)) {\n        return {\n          type: AnnotationType.POINT,\n          id,\n          point: corner,\n          description,\n          relatedSegments: segments,\n          properties: [],\n        };\n      }\n      const radii = vec3.scale(vec3.create(), size, 0.5);\n      const center = vec3.add(vec3.create(), corner, radii);\n      return {\n        type: AnnotationType.ELLIPSOID,\n        id,\n        center,\n        radii,\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    }\n    case \"LINE\":\n      return {\n        type: AnnotationType.LINE,\n        id,\n        pointA: corner,\n        pointB: vec3.add(vec3.create(), corner, size),\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    case \"VOLUME\":\n      return {\n        type: AnnotationType.AXIS_ALIGNED_BOUNDING_BOX,\n        id,\n        pointA: corner,\n        pointB: vec3.add(vec3.create(), corner, size),\n        description,\n        relatedSegments: segments,\n        properties: [],\n      };\n    default:\n      throw new Error(\n        `Unknown spatial annotation type: ${JSON.stringify(\n          spatialAnnotationType,\n        )}.`,\n      );\n  }\n}\n\nfunction parseAnnotationResponse(\n  response: any,\n  idPrefix: string,\n  expectedId?: string,\n): Annotation {\n  verifyObject(response);\n  const entry = verifyObjectProperty(response, \"annotations\", (x) =>\n    parseFixedLengthArray(<any[]>[undefined], x, verifyObject),\n  )[0];\n  return parseAnnotation(entry, idPrefix, expectedId);\n}\n\nconst annotationPropertySerializers = makeAnnotationPropertySerializers(\n  /*rank=*/ 3,\n  /*propertySpecs=*/ [],\n);\n\nfunction parseAnnotations(\n  chunk: AnnotationGeometryChunk | AnnotationSubsetGeometryChunk,\n  responses: any[],\n) {\n  const serializer = new AnnotationSerializer(annotationPropertySerializers);\n  const source = <BrainmapsAnnotationSource>chunk.source.parent;\n  const idPrefix = getIdPrefix(source.parameters);\n  responses.forEach((response, responseIndex) => {\n    try {\n      verifyObject(response);\n      const annotationsArray = verifyObjectProperty(\n        response,\n        \"annotations\",\n        (x) => (x === undefined ? [] : x),\n      );\n      if (!Array.isArray(annotationsArray)) {\n        throw new Error(\n          `Expected array, but received ${JSON.stringify(\n            typeof annotationsArray,\n          )}.`,\n        );\n      }\n      for (const entry of annotationsArray) {\n        try {\n          serializer.add(parseAnnotation(entry, idPrefix));\n        } catch (e) {\n          throw new Error(`Error parsing annotation: ${e.message}`);\n        }\n      }\n    } catch (parseError) {\n      throw new Error(\n        `Error parsing ${spatialAnnotationTypes[responseIndex]} annotations: ${parseError.message}`,\n      );\n    }\n  });\n  chunk.data = Object.assign(\n    new AnnotationGeometryData(),\n    serializer.serialize(),\n  );\n}\n\nfunction getSpatialAnnotationTypeFromId(id: string) {\n  const index = id.indexOf(\".\");\n  return id.substring(0, index);\n}\n\nfunction toCommaSeparated(v: vec3) {\n  return `${Math.round(v[0])},${Math.round(v[1])},${Math.round(v[2])}`;\n}\n\nfunction getFullSpatialAnnotationId(\n  parameters: AnnotationSourceParameters,\n  id: string,\n) {\n  return `${parameters.volumeId}:${parameters.changestack}:${id}`;\n}\n\nfunction annotationToBrainmaps(annotation: Annotation): any {\n  const payload = annotation.description || \"\";\n  const objectLabels =\n    annotation.relatedSegments === undefined\n      ? undefined\n      : Array.from(annotation.relatedSegments[0], (x) => x.toString());\n  switch (annotation.type) {\n    case AnnotationType.LINE: {\n      const { pointA, pointB } = annotation;\n      const size = vec3.subtract(vec3.create(), pointB as vec3, pointA as vec3);\n      return {\n        type: \"LINE\",\n        corner: toCommaSeparated(pointA as vec3),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.AXIS_ALIGNED_BOUNDING_BOX: {\n      const { pointA, pointB } = annotation;\n      const minPoint = vector.min(vec3.create(), pointA, pointB);\n      const maxPoint = vector.max(vec3.create(), pointA, pointB);\n      const size = vec3.subtract(maxPoint, maxPoint, minPoint);\n      return {\n        type: \"VOLUME\",\n        corner: toCommaSeparated(minPoint),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.POINT: {\n      return {\n        type: \"LOCATION\",\n        corner: toCommaSeparated(annotation.point as vec3),\n        size: \"0,0,0\",\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n    case AnnotationType.ELLIPSOID: {\n      const corner = vec3.subtract(\n        vec3.create(),\n        annotation.center as vec3,\n        annotation.radii as vec3,\n      );\n      const size = vec3.scale(vec3.create(), annotation.radii as vec3, 2);\n      return {\n        type: \"LOCATION\",\n        corner: toCommaSeparated(corner),\n        size: toCommaSeparated(size),\n        object_labels: objectLabels,\n        payload,\n      };\n    }\n  }\n}\n\n@registerSharedObject() //\nexport class BrainmapsAnnotationGeometryChunkSource extends BrainmapsSource(\n  AnnotationGeometryChunkSourceBackend,\n  AnnotationSpatialIndexSourceParameters,\n) {\n  async download(chunk: AnnotationGeometryChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    return Promise.all(\n      spatialAnnotationTypes.map((spatialAnnotationType) =>\n        makeRequest(\n          parameters.instance,\n          this.credentialsProvider,\n          `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n          {\n            signal,\n            method: \"POST\",\n            body: JSON.stringify({\n              type: spatialAnnotationType,\n              ignore_payload: true,\n            }),\n          },\n        ).then((response) => response.json()),\n      ),\n    ).then((values) => {\n      parseAnnotations(chunk, values);\n    });\n  }\n}\n\n@registerSharedObject()\nexport class BrainmapsAnnotationSource extends BrainmapsSource(\n  AnnotationSource,\n  AnnotationSourceParameters,\n) {\n  downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    _relationshipIndex: number,\n    signal: AbortSignal,\n  ) {\n    const { parameters } = this;\n    return Promise.all(\n      spatialAnnotationTypes.map((spatialAnnotationType) =>\n        makeRequest(\n          parameters.instance,\n          this.credentialsProvider,\n          `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n          {\n            signal,\n            method: \"POST\",\n            body: JSON.stringify({\n              type: spatialAnnotationType,\n              object_labels: [chunk.objectId.toString()],\n              ignore_payload: true,\n            }),\n          },\n        ).then((response) => response.json()),\n      ),\n    ).then((values) => {\n      parseAnnotations(chunk, values);\n    });\n  }\n\n  downloadMetadata(chunk: AnnotationMetadataChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const id = chunk.key!;\n    return makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:get`,\n      {\n        signal,\n        method: \"POST\",\n        body: JSON.stringify({\n          type: getSpatialAnnotationTypeFromId(id),\n          id: getFullSpatialAnnotationId(parameters, id),\n        }),\n      },\n    )\n      .then((response) => response.json())\n      .then(\n        (response) => {\n          chunk.annotation = parseAnnotationResponse(\n            response,\n            getIdPrefix(parameters),\n            id,\n          );\n        },\n        () => {\n          chunk.annotation = null;\n        },\n      );\n  }\n\n  add(annotation: Annotation) {\n    const { parameters } = this;\n    const brainmapsAnnotation = annotationToBrainmaps(annotation);\n    return makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({ annotations: [brainmapsAnnotation] }),\n      },\n    )\n      .then((response) => response.json())\n      .then((response) => {\n        verifyObject(response);\n        const ids = verifyObjectProperty(response, \"ids\", verifyStringArray);\n        if (ids.length !== 1) {\n          throw new Error(\n            `Expected list of 1 id, but received ${JSON.stringify(ids)}.`,\n          );\n        }\n        const idPrefix = getIdPrefix(this.parameters);\n        return parseBrainmapsAnnotationId(idPrefix, ids[0]);\n      });\n  }\n\n  update(id: AnnotationId, annotation: Annotation) {\n    const { parameters } = this;\n    const brainmapsAnnotation = annotationToBrainmaps(annotation);\n    brainmapsAnnotation.id = getFullSpatialAnnotationId(parameters, id);\n    return makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:push`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({ annotations: [brainmapsAnnotation] }),\n      },\n    ).then((response) => response.json());\n  }\n\n  delete(id: AnnotationId) {\n    const { parameters } = this;\n    return makeRequest(\n      parameters.instance,\n      this.credentialsProvider,\n      `/v1/changes/${parameters.volumeId}/${parameters.changestack}/spatials:delete`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          type: getSpatialAnnotationTypeFromId(id),\n          ids: [getFullSpatialAnnotationId(parameters, id)],\n        }),\n      },\n    ).then((response) => response.json());\n  }\n}\n","/**\n * @license\n * Copyright 2022 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport interface DecodedImage {\n  width: number;\n  height: number;\n  numComponents: number;\n  uint8Array: Uint8Array<ArrayBuffer>;\n}\n\nexport const decodePng = asyncComputation<\n  (\n    data: Uint8Array<ArrayBuffer>,\n    width: number | undefined,\n    height: number | undefined,\n    // Expected width * height\n    area: number | undefined,\n    numComponents: number | undefined,\n    bytesPerPixel: number,\n    convertToGrayscale: boolean,\n  ) => DecodedImage\n>(\"decodePng\");\n","/**\n * @license\n * Copyright 2016 Google Inc., 2023 Gergely Csucs\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { decodePng } from \"#src/async_computation/decode_png_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport {\n  ImageTileEncoding,\n  ImageTileSourceParameters,\n} from \"#src/datasource/deepzoom/base.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { transposeArray2d } from \"#src/util/array.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n/* This is enough if support for these aren't needed:\n * - Firefox before 105 (OffscreenCanvas, 2022-09-20)\n * - Safari before 16.4 (OffscreenCanvas, 2023-03-27)\n */\n// declare var OffscreenCanvas: any; // shutting up some outdated compiler(?)\n\n@registerSharedObject()\nexport class DeepzoomImageTileSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(VolumeChunkSource),\n  ImageTileSourceParameters,\n) {\n  private tileKvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n\n  gridShape = (() => {\n    const gridShape = new Uint32Array(2);\n    const { upperVoxelBound, chunkDataSize } = this.spec;\n    for (let i = 0; i < 2; ++i) {\n      gridShape[i] = Math.ceil(upperVoxelBound[i] / chunkDataSize[i]);\n    }\n    return gridShape;\n  })();\n\n  async download(chunk: VolumeChunk, signal: AbortSignal): Promise<void> {\n    const { parameters } = this;\n\n    // /* This block is enough if support for these aren't needed:\n    //  * - Firefox before 105 (OffscreenCanvas, 2022-09-20)\n    //  * - Safari before 16.4 (OffscreenCanvas, 2023-03-27)\n    //  */\n    // const {tilesize, overlap} = parameters;\n    // const [x, y] = chunk.chunkGridPosition;\n    // const url = `${parameters.url}/${x}_${y}.${ImageTileEncoding[parameters.encoding].toLowerCase()}`;\n    // const response: Blob = await (await fetchSpecialOk(this.credentialsProvider, url, {signal: signal})).blob();\n    // const tile = await createImageBitmap(response);\n    // const canvas = new OffscreenCanvas(tilesize, tilesize);\n    // const ctx = canvas.getContext(\"2d\")!;\n    // ctx.drawImage(tile, x === 0 ? 0 : -overlap, y === 0 ? 0 : -overlap);\n    // const id = ctx.getImageData(0, 0, tilesize, tilesize).data;\n    // const t2 = tilesize * tilesize;\n    // const d = chunk.data = new Uint8Array(t2 * 3);\n    // for (let i = 0; i < t2; i++) {\n    //   d[i] = id[i * 4];\n    //   d[i + t2] = id[i * 4 + 1];\n    //   d[i + 2 * t2] = id[i * 4 + 2];\n    // }\n    // Todo: ^ \"transposeArray2d\" likely does the same\n\n    const { tilesize, overlap, encoding } = parameters;\n    const [x, y] = chunk.chunkGridPosition;\n    const ox = x === 0 ? 0 : overlap;\n    const oy = y === 0 ? 0 : overlap;\n    const path = `${this.tileKvStore.path}/${x}_${y}.${parameters.format}`;\n    const response = await this.tileKvStore.store.read(path, {\n      signal,\n    });\n    if (response === undefined) {\n      return;\n    }\n    const responseArray = new Uint8Array(await response.response.arrayBuffer());\n\n    let tilewidth = 0;\n    let tileheight = 0;\n    let tiledata: Uint8Array | undefined;\n    switch (encoding) {\n      case ImageTileEncoding.PNG: {\n        const pngbitmap = await requestAsyncComputation(\n          decodePng,\n          signal,\n          [responseArray.buffer],\n          responseArray,\n          undefined,\n          undefined,\n          undefined,\n          3,\n          1,\n          false,\n        );\n        ({ width: tilewidth, height: tileheight } = pngbitmap);\n        tiledata = transposeArray2d(\n          pngbitmap.uint8Array,\n          tilewidth * tileheight,\n          3,\n        );\n        break;\n      }\n\n      case ImageTileEncoding.JPG:\n      case ImageTileEncoding.JPEG: {\n        const jpegbitmap = await requestAsyncComputation(\n          decodeJpeg,\n          signal,\n          [responseArray.buffer],\n          responseArray,\n          undefined,\n          undefined,\n          undefined,\n          3,\n          false,\n        );\n        ({\n          uint8Array: tiledata,\n          width: tilewidth,\n          height: tileheight,\n        } = jpegbitmap);\n        break;\n      }\n    }\n    if (tiledata !== undefined) {\n      const t2 = tilesize * tilesize;\n      const twh = tilewidth * tileheight;\n      const d = (chunk.data = new Uint8Array(t2 * 3));\n      for (let k = 0; k < 3; k++)\n        for (let j = 0; j < tileheight; j++)\n          for (let i = 0; i < tilewidth; i++)\n            d[i + j * tilesize + k * t2] =\n              tiledata[i + ox + (j + oy) * tilewidth + k * twh];\n    }\n  }\n}\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2019 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fetchOkWithCredentials } from \"#src/credentials_provider/http_request.js\";\nimport type { CredentialsProvider } from \"#src/credentials_provider/index.js\";\n\nexport interface DVIDToken {\n  // If token is undefined, it indicates anonymous credentials that may be retried.\n  token?: string;\n}\n\nexport const credentialsKey = \"DVID\";\n\nexport class DVIDInstance {\n  constructor(\n    public baseUrl: string,\n    public nodeKey: string,\n  ) {}\n\n  getNodeApiUrl(path = \"\"): string {\n    return `${this.baseUrl}/api/node/${this.nodeKey}${path}`;\n  }\n\n  getRepoInfoUrl(): string {\n    return `${this.baseUrl}/api/repos/info`;\n  }\n\n  getKeyValueUrl(dataName: string, key: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/key/${key}`;\n  }\n\n  getKeyValueRangeUrl(dataName: string, startKey: string, endKey: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/keyrange/${startKey}/${endKey}`;\n  }\n\n  getKeyValuesUrl(dataName: string) {\n    return `${this.getNodeApiUrl()}/${dataName}/keyvalues?jsontar=false`;\n  }\n}\n\nexport function appendQueryStringForDvid(\n  url: string,\n  user: string | null | undefined,\n) {\n  if (url.includes(\"?\")) {\n    url += \"&\";\n  } else {\n    url += \"?\";\n  }\n  url += \"app=Neuroglancer\";\n  if (user) {\n    url += `&u=${user}`;\n  }\n  return url;\n}\n\nexport function fetchWithDVIDCredentials(\n  credentialsProvider: CredentialsProvider<DVIDToken>,\n  input: string,\n  init: RequestInit,\n): Promise<Response> {\n  return fetchOkWithCredentials(\n    credentialsProvider,\n    input,\n    init,\n    (credentials: DVIDToken, init: RequestInit) => {\n      const newInit: RequestInit = { ...init };\n      if (credentials.token) {\n        newInit.headers = {\n          ...newInit.headers,\n          Authorization: `Bearer ${credentials}`,\n        };\n      }\n      return newInit;\n    },\n    (error) => {\n      const { status } = error;\n      if (status === 403 || status === 401) {\n        // Authorization needed.  Retry with refreshed token.\n        return \"refresh\";\n      }\n      throw error;\n    },\n  );\n}\n","/**\n * @license\n * This work is a derivative of the Google Neuroglancer project,\n * Copyright 2016 Google Inc.\n * The Derivative Work is covered by\n * Copyright 2020 Howard Hughes Medical Institute\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\n\nexport function decodeSwcSkeletonChunk(chunk: SkeletonChunk, swcStr: string) {\n  const swcObjects: Array<PointObj> = parseSwc(swcStr);\n\n  if (swcObjects.length < 1) {\n    throw new Error(\"ERROR parsing swc data\");\n  }\n\n  const indexMap = new Uint32Array(swcObjects.length);\n\n  let nodeCount = 0;\n  let edgeCount = 0;\n  swcObjects.forEach((swcObj, i) => {\n    if (swcObj) {\n      indexMap[i] = nodeCount++;\n      if (swcObj.parent >= 0) {\n        ++edgeCount;\n      }\n    }\n  });\n\n  const glVertices = new Float32Array(3 * nodeCount);\n  const glIndices = new Uint32Array(2 * edgeCount);\n\n  let nodeIndex = 0;\n  let edgetIndex = 0;\n  swcObjects.forEach((swcObj) => {\n    if (swcObj) {\n      glVertices[3 * nodeIndex] = swcObj.x;\n      glVertices[3 * nodeIndex + 1] = swcObj.y;\n      glVertices[3 * nodeIndex + 2] = swcObj.z;\n\n      if (swcObj.parent >= 0) {\n        glIndices[2 * edgetIndex] = nodeIndex;\n        glIndices[2 * edgetIndex + 1] = indexMap[swcObj.parent];\n        ++edgetIndex;\n      }\n      ++nodeIndex;\n    }\n  });\n\n  chunk.indices = glIndices;\n  chunk.vertexPositions = glVertices;\n}\n\n/*\n * Parses a standard SWC file into an array of point objects\n * modified from\n * https://github.com/JaneliaSciComp/SharkViewer/blob/d9969a7c513beee32ff9650b00bf79cda8f3c76a/html/js/sharkviewer_loader.js\n */\nfunction parseSwc(swcStr: string) {\n  const swcInputAr = swcStr.split(\"\\n\");\n  const swcObjectsAr: Array<PointObj> = [];\n  const float = \"-?\\\\d*(?:\\\\.\\\\d+)?\";\n  const pattern = new RegExp(\n    \"^[ \\\\t]*(\" +\n      [\n        \"\\\\d+\", // index\n        \"\\\\d+\", // type\n        float, // x\n        float, // y\n        float, // z\n        float, // radius\n        \"-1|\\\\d+\", // parent\n      ].join(\")[ \\\\t]+(\") +\n      \")[ \\\\t]*$\",\n  );\n\n  swcInputAr.forEach((e) => {\n    // if line meets swc point criteria, add it to the array\n    const match = e.match(pattern);\n    if (match) {\n      const point = (swcObjectsAr[parseInt(match[1], 10)] = new PointObj());\n      point.type = parseInt(match[2], 10);\n      point.x = parseFloat(match[3]);\n      point.y = parseFloat(match[4]);\n      point.z = parseFloat(match[5]);\n      point.radius = parseFloat(match[6]);\n      point.parent = parseInt(match[7], 10);\n    }\n  });\n  return swcObjectsAr;\n}\n\nclass PointObj {\n  type: number;\n  x: number;\n  y: number;\n  z: number;\n  radius: number;\n  parent: number;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport type { ChunkSourceParametersConstructor } from \"#src/chunk_manager/base.js\";\nimport { WithSharedCredentialsProviderCounterpart } from \"#src/credentials_provider/shared_counterpart.js\";\nimport type { DVIDToken } from \"#src/datasource/dvid/api.js\";\nimport {\n  DVIDInstance,\n  fetchWithDVIDCredentials,\n  appendQueryStringForDvid,\n} from \"#src/datasource/dvid/api.js\";\nimport {\n  MeshSourceParameters,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/dvid/base.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  decodeTriangleVertexPositionsAndIndices,\n  MeshSource,\n} from \"#src/mesh/backend.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { SkeletonSource } from \"#src/skeleton/backend.js\";\nimport { decodeSwcSkeletonChunk } from \"#src/skeleton/decode_swc_skeleton.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport type { SharedObject } from \"#src/worker_rpc.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nfunction DVIDSource<\n  Parameters,\n  TBase extends { new (...args: any[]): SharedObject },\n>(\n  Base: TBase,\n  parametersConstructor: ChunkSourceParametersConstructor<Parameters>,\n) {\n  return WithParameters(\n    WithSharedCredentialsProviderCounterpart<DVIDToken>()(Base),\n    parametersConstructor,\n  );\n}\n\n@registerSharedObject()\nexport class DVIDSkeletonSource extends DVIDSource(\n  SkeletonSource,\n  SkeletonSourceParameters,\n) {\n  download(chunk: SkeletonChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const bodyid = `${chunk.objectId}`;\n    const url =\n      `${parameters.baseUrl}/api/node/${parameters.nodeKey}` +\n      `/${parameters.dataInstanceKey}/key/` +\n      bodyid +\n      \"_swc\";\n    return fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(url, parameters.user),\n      {\n        signal: signal,\n      },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => {\n        const enc = new TextDecoder(\"utf-8\");\n        decodeSwcSkeletonChunk(chunk, enc.decode(response));\n      });\n  }\n}\n\nexport function decodeFragmentChunk(\n  chunk: FragmentChunk,\n  response: ArrayBuffer,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class DVIDMeshSource extends DVIDSource(\n  MeshSource,\n  MeshSourceParameters,\n) {\n  download(chunk: ManifestChunk) {\n    // DVID does not currently store meshes chunked, the main\n    // use-case is for low-resolution 3D views.\n    // for now, fragmentId is the body id\n    chunk.fragmentIds = [`${chunk.objectId}`];\n    return Promise.resolve(undefined);\n  }\n\n  downloadFragment(chunk: FragmentChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const dvidInstance = new DVIDInstance(\n      parameters.baseUrl,\n      parameters.nodeKey,\n    );\n    const meshUrl = dvidInstance.getKeyValueUrl(\n      parameters.dataInstanceKey,\n      `${chunk.fragmentId}.ngmesh`,\n    );\n\n    return fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(meshUrl, parameters.user),\n      {\n        signal: signal,\n      },\n    )\n      .then((response) => response.arrayBuffer())\n      .then((response) => decodeFragmentChunk(chunk, response));\n  }\n}\n\n@registerSharedObject()\nexport class DVIDVolumeChunkSource extends DVIDSource(\n  VolumeChunkSource,\n  VolumeChunkSourceParameters,\n) {\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    const params = this.parameters;\n    let path: string;\n    {\n      // chunkPosition must not be captured, since it will be invalidated by the next call to\n      // computeChunkBounds.\n      const chunkPosition = this.computeChunkBounds(chunk);\n      const chunkDataSize = chunk.chunkDataSize!;\n\n      // if the volume is an image, get a jpeg\n      path = this.getPath(chunkPosition, chunkDataSize);\n    }\n    const decoder = this.getDecoder(params);\n    const response = await fetchWithDVIDCredentials(\n      this.credentialsProvider,\n      appendQueryStringForDvid(`${params.baseUrl}${path}`, params.user),\n      { signal: signal },\n    ).then((response) => response.arrayBuffer());\n    await decoder(\n      chunk,\n      signal,\n      params.encoding === VolumeChunkEncoding.JPEG\n        ? response.slice(16)\n        : response,\n    );\n  }\n  getPath(chunkPosition: Float32Array, chunkDataSize: Uint32Array) {\n    const params = this.parameters;\n    if (params.encoding === VolumeChunkEncoding.JPEG) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/subvolblocks/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}`\n      );\n    }\n    if (params.encoding === VolumeChunkEncoding.RAW) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}/jpeg`\n      );\n    }\n    if (params.encoding === VolumeChunkEncoding.COMPRESSED_SEGMENTATIONARRAY) {\n      return (\n        `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n        `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n        `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip&scale=${params.dataScale}`\n      );\n    }\n    // encoding is COMPRESSED_SEGMENTATION\n    return (\n      `/api/node/${params.nodeKey}/${params.dataInstanceKey}/raw/0_1_2/` +\n      `${chunkDataSize[0]}_${chunkDataSize[1]}_${chunkDataSize[2]}/` +\n      `${chunkPosition[0]}_${chunkPosition[1]}_${chunkPosition[2]}?compression=googlegzip`\n    );\n  }\n  getDecoder(params: any) {\n    if (\n      params.encoding === VolumeChunkEncoding.JPEG ||\n      params.encoding === VolumeChunkEncoding.RAW\n    ) {\n      return decodeJpegChunk;\n    }\n    // encoding is COMPRESSED_SEGMENTATION\n    return decodeCompressedSegmentationChunk;\n  }\n}\n","/**\n * @license\n * Copyright 2019 The Neuroglancer Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ShardingParameters } from \"#src/datasource/precomputed/base.js\";\nimport type { KvStoreContext } from \"#src/kvstore/context.js\";\nimport { ReadableHttpKvStore } from \"#src/kvstore/http/common.js\";\nimport { joinBaseUrlAndPath } from \"#src/kvstore/url.js\";\nimport type {\n  ChunkLayoutOptions,\n  SliceViewChunkSource,\n  SliceViewChunkSpecification,\n  SliceViewChunkSpecificationBaseOptions,\n  SliceViewChunkSpecificationOptions,\n  DataType,\n} from \"#src/sliceview/base.js\";\nimport { makeSliceViewChunkSpecification } from \"#src/sliceview/base.js\";\nimport type { mat4 } from \"#src/util/geom.js\";\nimport type { FetchOk, HttpError } from \"#src/util/http_request.js\";\n\nexport const PYCG_APP_VERSION = 1;\nexport const GRAPHENE_MESH_NEW_SEGMENT_RPC_ID = \"GrapheneMeshSource:NewSegment\";\n\nexport enum VolumeChunkEncoding {\n  RAW = 0,\n  JPEG = 1,\n  COMPRESSED_SEGMENTATION = 2,\n}\n\nexport class VolumeChunkSourceParameters {\n  url: string;\n  encoding: VolumeChunkEncoding;\n  sharding: ShardingParameters | undefined;\n\n  static RPC_ID = \"graphene/VolumeChunkSource\";\n}\n\nexport class ChunkedGraphSourceParameters {\n  url: string;\n\n  static RPC_ID = \"graphene/ChunkedGraphSource\";\n}\n\nexport class MeshSourceParameters {\n  manifestUrl: string;\n  fragmentUrl: string;\n  lod: number;\n  sharding: Array<ShardingParameters> | undefined;\n  nBitsForLayerId: number;\n\n  static RPC_ID = \"graphene/MeshSource\";\n}\n\nexport class MultiscaleMeshMetadata {\n  transform: mat4;\n  lodScaleMultiplier: number;\n  vertexQuantizationBits: number;\n  sharding: Array<ShardingParameters> | undefined;\n}\n\nexport function isBaseSegmentId(segmentId: bigint, nBitsForLayerId: number) {\n  const layerId = segmentId >> BigInt(64 - nBitsForLayerId);\n  return layerId == 1n;\n}\n\nexport function getGrapheneFragmentKey(fragmentId: string) {\n  const sharded = fragmentId.charAt(0) === \"~\";\n\n  if (sharded) {\n    const parts = fragmentId.substring(1).split(/:(.+)/);\n    return { key: parts[0], fragmentId: parts[1] };\n  }\n  return { key: fragmentId, fragmentId: fragmentId };\n}\n\nexport const CHUNKED_GRAPH_LAYER_RPC_ID = \"ChunkedGraphLayer\";\nexport const CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID =\n  \"ChunkedGraphLayer:updateSources\";\nexport const RENDER_RATIO_LIMIT = 5.0;\n\nexport interface ChunkedGraphChunkSpecificationBaseOptions\n  extends SliceViewChunkSpecificationBaseOptions {\n  /**\n   * Specifies offset for use by backend.ts:GenericVolumeChunkSource.computeChunkBounds in\n   * calculating chunk voxel coordinates.  The calculated chunk coordinates will be equal to the\n   * voxel position (in chunkLayout coordinates) plus this value.\n   *\n   * Defaults to kZeroVec if not specified.\n   */\n  baseVoxelOffset?: Float32Array;\n  dataType: DataType;\n}\n\nexport interface ChunkedGraphChunkSpecificationOptions\n  extends ChunkedGraphChunkSpecificationBaseOptions,\n    SliceViewChunkSpecificationOptions<Uint32Array> {}\n\n/**\n * Specifies parameters for ChunkedGraphChunkSpecification.getDefaults.\n */\nexport interface ChunkedGraphChunkSpecificationGetDefaultsOptions\n  extends ChunkedGraphChunkSpecificationBaseOptions,\n    ChunkLayoutOptions {}\n\n/**\n * Specifies a chunk layout and voxel size.\n */\nexport interface ChunkedGraphChunkSpecification\n  extends SliceViewChunkSpecification<Uint32Array> {\n  baseVoxelOffset: Float32Array;\n  dataType: DataType;\n}\n\nexport function makeChunkedGraphChunkSpecification(\n  options: ChunkedGraphChunkSpecificationOptions,\n): ChunkedGraphChunkSpecification {\n  const { rank, dataType } = options;\n  const { baseVoxelOffset = new Float32Array(rank) } = options;\n\n  return {\n    ...makeSliceViewChunkSpecification(options),\n    baseVoxelOffset,\n    dataType,\n  };\n}\n\nexport interface ChunkedGraphChunkSource extends SliceViewChunkSource {\n  spec: ChunkedGraphChunkSpecification;\n}\n\nexport async function parseGrapheneError(e: HttpError) {\n  if (e.response) {\n    let msg: string;\n    if (e.response.headers.get(\"content-type\") === \"application/json\") {\n      msg = (await e.response.json()).message;\n    } else {\n      msg = await e.response.text();\n    }\n    return msg;\n  }\n  return undefined;\n}\n\nexport interface HttpSource {\n  fetchOkImpl: FetchOk;\n  baseUrl: string;\n}\n\nexport function getHttpSource(\n  kvStoreContext: KvStoreContext,\n  url: string,\n): HttpSource {\n  const { store, path } = kvStoreContext.getKvStore(url);\n  if (!(store instanceof ReadableHttpKvStore)) {\n    throw new Error(`Non-HTTP URL ${JSON.stringify(url)} not supported`);\n  }\n  const { fetchOkImpl, baseUrl } = store;\n  if (baseUrl.includes(\"?\")) {\n    throw new Error(`Invalid URL ${baseUrl}: query parameters not supported`);\n  }\n  return { fetchOkImpl, baseUrl: joinBaseUrlAndPath(baseUrl, path) };\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst OBJECT_ID_SYMBOL = Symbol(\"objectId\");\nlet nextObjectId = 0;\n\n/**\n * Returns a string that uniquely identifies a particular primitive value or object instance.\n */\nexport function getObjectId(x: any) {\n  if (x instanceof Object) {\n    let id = x[OBJECT_ID_SYMBOL];\n    if (id === undefined) {\n      id = x[OBJECT_ID_SYMBOL] = nextObjectId++;\n    }\n    return `o${id}`;\n  }\n  return \"\" + JSON.stringify(x);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @file\n * Provides a simple way to request a file on the backend with priority integration.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { Chunk, ChunkSourceBase } from \"#src/chunk_manager/backend.js\";\nimport { ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { ReadResponse } from \"#src/kvstore/index.js\";\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { stableStringify } from \"#src/util/json.js\";\nimport type { AsyncMemoize } from \"#src/util/memoize.js\";\nimport { asyncMemoizeWithProgress } from \"#src/util/memoize.js\";\nimport { getObjectId } from \"#src/util/object_id.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nclass AsyncCacheChunk<Data> extends Chunk {\n  asyncMemoize: AsyncMemoize<Data> | undefined;\n\n  initialize(key: string) {\n    super.initialize(key);\n  }\n\n  freeSystemMemory() {\n    this.asyncMemoize = undefined;\n  }\n}\n\nexport interface SimpleAsyncCacheOptions<Key, Value> {\n  encodeKey?: (key: Key) => string;\n  get: (\n    key: Key,\n    progressOptions: ProgressOptions,\n  ) => Promise<{ size: number; data: Value }>;\n}\n\nexport class SimpleAsyncCache<Key, Value> extends ChunkSourceBase {\n  declare chunks: Map<string, AsyncCacheChunk<Value>>;\n\n  constructor(\n    chunkManager: Owned<ChunkManager>,\n    options: SimpleAsyncCacheOptions<Key, Value>,\n  ) {\n    super(chunkManager);\n    this.registerDisposer(chunkManager);\n    this.downloadFunction = options.get;\n    this.encodeKeyFunction = options.encodeKey ?? stableStringify;\n  }\n  encodeKeyFunction: (key: Key) => string;\n  downloadFunction: (\n    key: Key,\n    progressOptions: ProgressOptions,\n  ) => Promise<{ size: number; data: Value }>;\n\n  get(key: Key, options: Partial<ProgressOptions>): Promise<Value> {\n    const encodedKey = this.encodeKeyFunction(key);\n    let chunk = this.chunks.get(encodedKey);\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_<AsyncCacheChunk<Value>>(AsyncCacheChunk);\n      chunk.initialize(encodedKey);\n      this.addChunk(chunk);\n    }\n    if (chunk.asyncMemoize === undefined) {\n      chunk.asyncMemoize = asyncMemoizeWithProgress(async (progressOptions) => {\n        try {\n          const { data, size } = await this.downloadFunction(\n            key,\n            progressOptions,\n          );\n          chunk.systemMemoryBytes = size;\n          chunk!.queueManager.updateChunkState(\n            chunk!,\n            ChunkState.SYSTEM_MEMORY_WORKER,\n          );\n          return data;\n        } catch (e) {\n          chunk!.queueManager.updateChunkState(chunk!, ChunkState.FAILED);\n          throw e;\n        }\n      });\n    }\n    if (chunk.state === ChunkState.SYSTEM_MEMORY_WORKER) {\n      chunk.chunkManager.queueManager.markRecentlyUsed(chunk);\n    }\n    return chunk.asyncMemoize(options);\n  }\n}\n\nexport function makeSimpleAsyncCache<Key, Data>(\n  chunkManager: ChunkManager,\n  memoizeKey: string,\n  options: SimpleAsyncCacheOptions<Key, Data>,\n) {\n  return chunkManager.memoize.get(\n    `simpleAsyncCache:${memoizeKey}`,\n    () => new SimpleAsyncCache(chunkManager.addRef(), options),\n  );\n}\n\nexport function getCachedDecodedUrl<Data>(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  decodeFunction: (\n    readResponse: ReadResponse,\n    options: ProgressOptions,\n  ) => Promise<{ size: number; data: Data }>,\n  options: Partial<ProgressOptions>,\n): Promise<Data> {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    `getCachedDecodedUrl:${getObjectId(decodeFunction)}`,\n    () => {\n      const cache = new SimpleAsyncCache(\n        sharedKvStoreContext.chunkManager.addRef(),\n        {\n          get: async (url: string, progressOptions: ProgressOptions) => {\n            const readResponse = await sharedKvStoreContext.kvStoreContext.read(\n              url,\n              { ...progressOptions, throwIfMissing: true },\n            );\n            try {\n              return decodeFunction(readResponse, progressOptions);\n            } catch (e) {\n              throw new Error(\"Error reading ${url}\", { cause: e });\n            }\n          },\n        },\n      );\n      cache.registerDisposer(sharedKvStoreContext.addRef());\n      return cache;\n    },\n  );\n  return cache.get(url, options);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This is a very simple string hash function.  It isn't secure, but\n * is suitable for sharding of requests.\n */\nexport function simpleStringHash(s: string): number {\n  let h = 0;\n  const length = s.length;\n  for (let i = 0; i < length; ++i) {\n    h = (h * 31 + s.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n/**\n * MurmurHash3_x86_32 mixing function\n */\nexport function murmurHash3_x86_32Mix(h: number, k: number): number {\n  k = Math.imul(k, 0xcc9e2d51) >>> 0;\n  k = ((k << 15) | (k >>> 17)) >>> 0;\n  k = Math.imul(k, 0x1b873593) >>> 0;\n  h ^= k;\n  h = ((h << 13) | (h >>> 19)) >>> 0;\n  h = (Math.imul(h, 5) + 0xe6546b64) >>> 0;\n  return h;\n}\n\n/**\n * MurmurHash3_x86_32 finalization function\n */\nexport function murmurHash3_x86_32Finalize(h: number, len: number) {\n  h ^= len;\n  h ^= h >>> 16;\n  h = Math.imul(h, 0x85ebca6b) >>> 0;\n  h ^= h >>> 13;\n  h *= 0xc2b2ae35;\n  h ^= h >>> 16;\n  return h >>> 0;\n}\n\n/**\n * MurmurHash3_x86_32, specialized for 8 bytes of input.\n */\nexport function murmurHash3_x86_32Hash64Bits(\n  seed: number,\n  low: number,\n  high: number,\n): number {\n  let h = seed;\n  h = murmurHash3_x86_32Mix(h, low);\n  h = murmurHash3_x86_32Mix(h, high);\n  return murmurHash3_x86_32Finalize(h, 8);\n}\n\nexport function murmurHash3_x86_32Hash64Bits_Bigint(\n  seed: number,\n  x: bigint,\n): number {\n  let h = seed;\n  h = murmurHash3_x86_32Mix(h, Number(x & 0xffffffffn));\n  h = murmurHash3_x86_32Mix(h, Number(x >> 32n));\n  return murmurHash3_x86_32Finalize(h, 8);\n}\n\nfunction murmurHash3_x86_128Mix(h: number) {\n  h ^= h >>> 16;\n  h = Math.imul(h, 0x85ebca6b);\n  h ^= h >>> 13;\n  h = Math.imul(h, 0xc2b2ae35);\n  h ^= h >>> 16;\n  return h;\n}\n\nfunction rotl32(x: number, r: number) {\n  return (x << r) | (x >>> (32 - r));\n}\n\n/**\n * MurmurHash3_x86_128, specialized for 8 bytes of input.\n *\n * Only the low 8 bytes of output are returned.\n */\nexport function murmurHash3_x86_128Hash64Bits_Bigint(\n  seed: number,\n  input: bigint,\n): bigint {\n  let h1 = seed;\n  let h2 = seed;\n  let h3 = seed;\n  let h4 = seed;\n  const c1 = 0x239b961b;\n  const c2 = 0xab0e9789;\n  const c3 = 0x38b34ae5;\n  // const c4 = 0xa1e38b93;\n\n  let k2 = Math.imul(Number(input >> BigInt(32)), c2);\n  k2 = rotl32(k2, 16);\n  k2 = Math.imul(k2, c3);\n  h2 ^= k2;\n\n  let k1 = Math.imul(Number(input & BigInt(0xffffffff)), c1);\n  k1 = rotl32(k1, 15);\n  k1 = Math.imul(k1, c2);\n  h1 ^= k1;\n\n  const len = 8;\n\n  h1 ^= len;\n  h2 ^= len;\n  h3 ^= len;\n  h4 ^= len;\n\n  h1 = (h1 + h2) >>> 0;\n  h1 = (h1 + h3) >>> 0;\n  h1 = (h1 + h4) >>> 0;\n  h2 = (h2 + h1) >>> 0;\n  h3 = (h3 + h1) >>> 0;\n  h4 = (h4 + h1) >>> 0;\n\n  h1 = murmurHash3_x86_128Mix(h1);\n  h2 = murmurHash3_x86_128Mix(h2);\n  h3 = murmurHash3_x86_128Mix(h3);\n  h4 = murmurHash3_x86_128Mix(h4);\n\n  h1 = (h1 + h2) >>> 0;\n  h1 = (h1 + h3) >>> 0;\n  h1 = (h1 + h4) >>> 0;\n  h2 = (h2 + h1) >>> 0;\n\n  // h3 = (h3 + h1) >>> 0;\n  // h4 = (h4 + h1) >>> 0;\n\n  return BigInt(h1) | (BigInt(h2) << BigInt(32));\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport {\n  DataEncoding,\n  ShardingHashFunction,\n  type ShardingParameters,\n} from \"#src/datasource/precomputed/base.js\";\nimport { FileByteRangeHandle } from \"#src/kvstore/byte_range/file_handle.js\";\nimport { GzipFileHandle } from \"#src/kvstore/gzip/file_handle.js\";\nimport type {\n  ByteRange,\n  DriverReadOptions,\n  FileHandle,\n  KvStoreWithPath,\n  ReadableKvStore,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport { KvStoreFileHandle, readFileHandle } from \"#src/kvstore/index.js\";\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport { convertEndian64, Endianness } from \"#src/util/endian.js\";\nimport { murmurHash3_x86_128Hash64Bits_Bigint } from \"#src/util/hash.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nconst shardingHashFunctions: Map<\n  ShardingHashFunction,\n  (input: bigint) => bigint\n> = new Map([\n  [\n    ShardingHashFunction.MURMURHASH3_X86_128,\n    (input) => murmurHash3_x86_128Hash64Bits_Bigint(/*seed=*/ 0, input),\n  ],\n  [ShardingHashFunction.IDENTITY, (input) => input],\n]);\n\nexport interface ShardInfo {\n  shardPath: string;\n  offset: number;\n}\n\ninterface DecodedMinishardIndex {\n  data: BigUint64Array;\n  shardPath: string;\n}\n\ntype MinishardIndexCache = SimpleAsyncCache<\n  bigint,\n  DecodedMinishardIndex | undefined\n>;\n\nfunction decodeFileHandle(handle: FileHandle, encoding: DataEncoding) {\n  if (encoding === DataEncoding.GZIP) {\n    handle = new GzipFileHandle(handle, \"gzip\");\n  }\n  return handle;\n}\n\nfunction makeMinishardIndexCache(\n  chunkManager: ChunkManager,\n  base: KvStoreWithPath,\n  sharding: ShardingParameters,\n): MinishardIndexCache {\n  return new SimpleAsyncCache(chunkManager.addRef(), {\n    encodeKey: (key) => key.toString(),\n    get: async (\n      shardAndMinishard: bigint,\n      progressOptions: Partial<ProgressOptions>,\n    ) => {\n      const minishard =\n        shardAndMinishard & ((1n << BigInt(sharding.minishardBits)) - 1n);\n      const shard =\n        ((1n << BigInt(sharding.shardBits)) - 1n) &\n        (shardAndMinishard >> BigInt(sharding.minishardBits));\n      const shardPath =\n        base.path +\n        shard.toString(16).padStart(Math.ceil(sharding.shardBits / 4), \"0\") +\n        \".shard\";\n\n      const shardFileHandle = new KvStoreFileHandle(base.store, shardPath);\n\n      // Retrive minishard index start/end offsets.\n      const shardIndexSize = BigInt(16) << BigInt(sharding.minishardBits);\n\n      // Multiply minishard by 16.\n      const shardIndexStart = minishard << 4n;\n      const response = await readFileHandle(shardFileHandle, {\n        ...progressOptions,\n        byteRange: { offset: Number(shardIndexStart), length: 16 },\n        strictByteRange: true,\n      });\n      if (response === undefined) {\n        return { data: undefined, size: 0 };\n      }\n      const shardIndexResponse = await response.response.arrayBuffer();\n      const shardIndexDv = new DataView(shardIndexResponse);\n      let minishardStartOffset = shardIndexDv.getBigUint64(\n        0,\n        /*littleEndian=*/ true,\n      );\n      let minishardEndOffset = shardIndexDv.getBigUint64(\n        8,\n        /*littleEndian=*/ true,\n      );\n      if (minishardStartOffset === minishardEndOffset) {\n        return { data: undefined, size: 0 };\n      }\n      // The start/end offsets in the shard index are relative to the end of the shard\n      // index.\n      minishardStartOffset += shardIndexSize;\n      minishardEndOffset += shardIndexSize;\n\n      const minishardIndexBuffer = await (\n        await readFileHandle(\n          decodeFileHandle(\n            new FileByteRangeHandle(shardFileHandle, {\n              offset: Number(minishardStartOffset),\n              length: Number(minishardEndOffset - minishardStartOffset),\n            }),\n            sharding.minishardIndexEncoding,\n          ),\n          {\n            ...progressOptions,\n            strictByteRange: true,\n            throwIfMissing: true,\n          },\n        )\n      ).response.arrayBuffer();\n      if (minishardIndexBuffer.byteLength % 24 !== 0) {\n        throw new Error(\n          `Invalid minishard index length: ${minishardIndexBuffer.byteLength}`,\n        );\n      }\n      const minishardIndex = new BigUint64Array(minishardIndexBuffer);\n      convertEndian64(minishardIndex, Endianness.LITTLE);\n\n      const minishardIndexSize = minishardIndex.byteLength / 24;\n      let prevEntryKey = 0n;\n      // Offsets in the minishard index are relative to the end of the shard index.\n      let prevStart = shardIndexSize;\n      for (let i = 0; i < minishardIndexSize; ++i) {\n        const entryKey = prevEntryKey + minishardIndex[i];\n        prevEntryKey = minishardIndex[i] = entryKey;\n        const start = prevStart + minishardIndex[minishardIndexSize + i];\n        minishardIndex[minishardIndexSize + i] = start;\n        const size = minishardIndex[2 * minishardIndexSize + i];\n        const end = start + size;\n        prevStart = end;\n        minishardIndex[2 * minishardIndexSize + i] = end;\n      }\n      return {\n        data: { data: minishardIndex, shardPath },\n        size: minishardIndex.byteLength,\n      };\n    },\n  });\n}\n\nfunction findMinishardEntry(\n  minishardIndex: DecodedMinishardIndex,\n  key: bigint,\n): ByteRange | undefined {\n  const minishardIndexData = minishardIndex.data;\n  const minishardIndexSize = minishardIndexData.length / 3;\n  for (let i = 0; i < minishardIndexSize; ++i) {\n    if (minishardIndexData[i] !== key) {\n      continue;\n    }\n    const startOffset = minishardIndexData[minishardIndexSize + i];\n    const endOffset = minishardIndexData[2 * minishardIndexSize + i];\n\n    return {\n      offset: Number(startOffset),\n      length: Number(endOffset - startOffset),\n    };\n  }\n  return undefined;\n}\n\nexport class ShardedKvStore\n  extends RefCounted\n  implements ReadableKvStore<bigint>\n{\n  private minishardIndexCache: Owned<MinishardIndexCache>;\n\n  constructor(\n    chunkManager: ChunkManager,\n    private base: KvStoreWithPath,\n    private sharding: ShardingParameters,\n  ) {\n    super();\n    this.minishardIndexCache = this.registerDisposer(\n      makeMinishardIndexCache(chunkManager, base, sharding),\n    );\n  }\n\n  getUrl(key: bigint): string {\n    return `chunk ${key} in ${this.base.store.getUrl(this.base.path)}`;\n  }\n\n  async findKey(\n    key: bigint,\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<{ minishardEntry: ByteRange; shardInfo: ShardInfo } | undefined> {\n    const { sharding } = this;\n    const hashFunction = shardingHashFunctions.get(sharding.hash)!;\n    const hashCode = hashFunction(key >> BigInt(sharding.preshiftBits));\n    const shardAndMinishard =\n      hashCode &\n      ((1n << BigInt(sharding.minishardBits + sharding.shardBits)) - 1n);\n    const minishardIndex = await this.minishardIndexCache.get(\n      shardAndMinishard,\n      progressOptions,\n    );\n    if (minishardIndex === undefined) return undefined;\n    const minishardEntry = findMinishardEntry(minishardIndex, key);\n    if (minishardEntry === undefined) return undefined;\n    return {\n      minishardEntry,\n      shardInfo: {\n        shardPath: minishardIndex.shardPath,\n        offset: minishardEntry.offset,\n      },\n    };\n  }\n\n  async readWithShardInfo(\n    key: bigint,\n    options: DriverReadOptions,\n  ): Promise<\n    | {\n        response: ReadResponse;\n        shardInfo: ShardInfo;\n      }\n    | undefined\n  > {\n    const { sharding } = this;\n    const findResult = await this.findKey(key, options);\n    if (findResult === undefined) return undefined;\n    const { minishardEntry, shardInfo } = findResult;\n    return {\n      response: (await decodeFileHandle(\n        new FileByteRangeHandle(\n          new KvStoreFileHandle(this.base.store, shardInfo.shardPath),\n          minishardEntry,\n        ),\n        sharding.dataEncoding,\n      ).read(options))!,\n      shardInfo,\n    };\n  }\n\n  async stat(\n    key: bigint,\n    options: StatOptions,\n  ): Promise<StatResponse | undefined> {\n    const findResult = await this.findKey(key, options);\n    if (findResult === undefined) return undefined;\n    const { sharding } = this;\n    if (sharding.dataEncoding !== DataEncoding.RAW) {\n      return { totalSize: undefined };\n    } else {\n      return { totalSize: findResult.minishardEntry.length };\n    }\n  }\n\n  async read(\n    key: bigint,\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const response = await this.readWithShardInfo(key, options);\n    if (response === undefined) return undefined;\n    return response.response;\n  }\n\n  get supportsOffsetReads() {\n    return this.sharding.dataEncoding === DataEncoding.RAW;\n  }\n  get supportsSuffixReads() {\n    return this.sharding.dataEncoding === DataEncoding.RAW;\n  }\n}\n\nexport function getShardedKvStoreIfApplicable(\n  chunkSource: RefCounted & {\n    chunkManager: ChunkManager;\n  },\n  base: KvStoreWithPath,\n  sharding: ShardingParameters | undefined,\n) {\n  if (sharding === undefined) return undefined;\n  return chunkSource.registerDisposer(\n    new ShardedKvStore(chunkSource.chunkManager, base, sharding),\n  );\n}\n","/**\n * @license\n * Copyright 2021 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeCompresso =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeCompresso\",\n  );\n","/**\n * @license\n * Copyright 2021 William Silvermsith.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeCompresso } from \"#src/async_computation/decode_compresso_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeCompressoChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const image = await requestAsyncComputation(\n    decodeCompresso,\n    signal,\n    [response],\n    new Uint8Array(response),\n  );\n\n  await decodeRawChunk(chunk, signal, image.buffer);\n}\n","/**\n * @license\n * Copyright 2024 William Silversmith\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { DecodedImage } from \"#src/async_computation/decode_png_request.js\";\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeJxl =\n  asyncComputation<\n    (\n      data: Uint8Array,\n      area: number | undefined,\n      numComponents: number | undefined,\n      bytesPerPixel: number,\n    ) => DecodedImage\n  >(\"decodeJxl\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJxl } from \"#src/async_computation/decode_jxl_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\n\nexport async function decodeJxlChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const { uint8Array: decoded } = await requestAsyncComputation(\n    decodeJxl,\n    signal,\n    [response],\n    new Uint8Array(response),\n    chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    chunkDataSize[3] || 1,\n    1, // bytesPerPixel\n  );\n  await postProcessRawData(chunk, signal, decoded);\n}\n","/**\n * @license\n * Copyright 2022 William Silvermsith.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodePng } from \"#src/async_computation/decode_png_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { DATA_TYPE_BYTES } from \"#src/util/data_type.js\";\n\nexport async function decodePngChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n) {\n  const chunkDataSize = chunk.chunkDataSize!;\n  const dataType = chunk.source!.spec.dataType;\n  const { uint8Array: image } = await requestAsyncComputation(\n    decodePng,\n    signal,\n    [response],\n    /*buffer=*/ new Uint8Array(response),\n    /*width=*/ undefined,\n    /*height=*/ undefined,\n    /*area=*/ chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n    /*numComponents=*/ chunkDataSize[3] || 1,\n    /*bytesPerPixel=*/ DATA_TYPE_BYTES[dataType],\n    /*convertToGrayscale=*/ false,\n  );\n\n  await decodeRawChunk(chunk, signal, image.buffer);\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AnnotationGeometryChunk,\n  AnnotationMetadataChunk,\n  AnnotationSubsetGeometryChunk,\n} from \"#src/annotation/backend.js\";\nimport {\n  AnnotationGeometryData,\n  AnnotationSource,\n  AnnotationGeometryChunkSourceBackend,\n} from \"#src/annotation/backend.js\";\nimport type { Annotation } from \"#src/annotation/index.js\";\nimport {\n  AnnotationPropertySerializer,\n  annotationTypeHandlers,\n  annotationTypes,\n} from \"#src/annotation/index.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport {\n  AnnotationSourceParameters,\n  AnnotationSpatialIndexSourceParameters,\n  MeshSourceParameters,\n  MultiscaleMeshSourceParameters,\n  SkeletonSourceParameters,\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/precomputed/base.js\";\nimport type {\n  ShardedKvStore,\n  ShardInfo,\n} from \"#src/datasource/precomputed/sharded.js\";\nimport { getShardedKvStoreIfApplicable } from \"#src/datasource/precomputed/sharded.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { KvStoreWithPath, ReadResponse } from \"#src/kvstore/index.js\";\nimport { readKvStore } from \"#src/kvstore/index.js\";\nimport type {\n  FragmentChunk,\n  ManifestChunk,\n  MultiscaleFragmentChunk,\n  MultiscaleManifestChunk,\n} from \"#src/mesh/backend.js\";\nimport {\n  assignMeshFragmentData,\n  assignMultiscaleMeshFragmentData,\n  computeOctreeChildOffsets,\n  decodeJsonManifestChunk,\n  decodeTriangleVertexPositionsAndIndices,\n  generateHigherOctreeLevel,\n  MeshSource,\n  MultiscaleMeshSource,\n} from \"#src/mesh/backend.js\";\nimport { decodeDracoPartitioned } from \"#src/mesh/draco/index.js\";\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { SkeletonSource } from \"#src/skeleton/backend.js\";\nimport { decodeSkeletonChunk } from \"#src/skeleton/decode_precomputed_skeleton.js\";\nimport { decodeCompressedSegmentationChunk } from \"#src/sliceview/backend_chunk_decoders/compressed_segmentation.js\";\nimport { decodeCompressoChunk } from \"#src/sliceview/backend_chunk_decoders/compresso.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { decodeJpegChunk } from \"#src/sliceview/backend_chunk_decoders/jpeg.js\";\nimport { decodeJxlChunk } from \"#src/sliceview/backend_chunk_decoders/jxl.js\";\nimport { decodePngChunk } from \"#src/sliceview/backend_chunk_decoders/png.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { convertEndian32, Endianness } from \"#src/util/endian.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport {\n  encodeZIndexCompressed,\n  encodeZIndexCompressed3d,\n  zorder3LessThan,\n} from \"#src/util/zorder.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n// Set to true to validate the multiscale index.\nconst DEBUG_MULTISCALE_INDEX = false;\n\nfunction getOrNotFoundError<T>(v: T | undefined) {\n  if (v === undefined) throw new Error(\"not found\");\n  return v;\n}\n\nconst chunkDecoders = new Map<VolumeChunkEncoding, ChunkDecoder>();\nchunkDecoders.set(VolumeChunkEncoding.RAW, decodeRawChunk);\nchunkDecoders.set(VolumeChunkEncoding.JPEG, decodeJpegChunk);\nchunkDecoders.set(\n  VolumeChunkEncoding.COMPRESSED_SEGMENTATION,\n  decodeCompressedSegmentationChunk,\n);\nchunkDecoders.set(VolumeChunkEncoding.COMPRESSO, decodeCompressoChunk);\nchunkDecoders.set(VolumeChunkEncoding.PNG, decodePngChunk);\nchunkDecoders.set(VolumeChunkEncoding.JXL, decodeJxlChunk);\n\n@registerSharedObject()\nexport class PrecomputedVolumeChunkSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(VolumeChunkSource),\n  VolumeChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  shardedKvStore = getShardedKvStoreIfApplicable(\n    this,\n    this.kvStore,\n    this.parameters.sharding,\n  );\n\n  gridShape = (() => {\n    const gridShape = new Uint32Array(3);\n    const { upperVoxelBound, chunkDataSize } = this.spec;\n    for (let i = 0; i < 3; ++i) {\n      gridShape[i] = Math.ceil(upperVoxelBound[i] / chunkDataSize[i]);\n    }\n    return gridShape;\n  })();\n\n  async download(chunk: VolumeChunk, signal: AbortSignal): Promise<void> {\n    const { shardedKvStore } = this;\n    let readResponse: ReadResponse | undefined;\n    if (shardedKvStore === undefined) {\n      const { kvStore } = this;\n      let path: string;\n      {\n        // chunkPosition must not be captured, since it will be invalidated by the next call to\n        // computeChunkBounds.\n        const chunkPosition = this.computeChunkBounds(chunk);\n        const chunkDataSize = chunk.chunkDataSize!;\n        path =\n          `${kvStore.path}${chunkPosition[0]}-${\n            chunkPosition[0] + chunkDataSize[0]\n          }_` +\n          `${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_` +\n          `${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;\n      }\n      readResponse = await kvStore.store.read(path, { signal });\n    } else {\n      this.computeChunkBounds(chunk);\n      const { gridShape } = this;\n      const { chunkGridPosition } = chunk;\n      const xBits = Math.ceil(Math.log2(gridShape[0]));\n      const yBits = Math.ceil(Math.log2(gridShape[1]));\n      const zBits = Math.ceil(Math.log2(gridShape[2]));\n      const chunkIndex = encodeZIndexCompressed3d(\n        xBits,\n        yBits,\n        zBits,\n        chunkGridPosition[0],\n        chunkGridPosition[1],\n        chunkGridPosition[2],\n      );\n      readResponse = await shardedKvStore.read(chunkIndex, { signal });\n    }\n    if (readResponse !== undefined) {\n      await this.chunkDecoder(\n        chunk,\n        signal,\n        await readResponse.response.arrayBuffer(),\n      );\n    }\n  }\n}\n\nexport function decodeManifestChunk(chunk: ManifestChunk, response: any) {\n  return decodeJsonManifestChunk(chunk, response, \"fragments\");\n}\n\nexport function decodeFragmentChunk(\n  chunk: FragmentChunk,\n  response: ArrayBuffer,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  assignMeshFragmentData(\n    chunk,\n    decodeTriangleVertexPositionsAndIndices(\n      response,\n      Endianness.LITTLE,\n      /*vertexByteOffset=*/ 4,\n      numVertices,\n    ),\n  );\n}\n\n@registerSharedObject()\nexport class PrecomputedMeshSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(MeshSource),\n  MeshSourceParameters,\n) {\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  async download(chunk: ManifestChunk, signal: AbortSignal) {\n    const { parameters, kvStore } = this;\n    const response = await readKvStore(\n      kvStore.store,\n      `${kvStore.path}${chunk.objectId}:${parameters.lod}`,\n      { signal, throwIfMissing: true },\n    );\n    decodeManifestChunk(chunk, await response.response.json());\n  }\n\n  async downloadFragment(chunk: FragmentChunk, signal: AbortSignal) {\n    const { kvStore } = this;\n    const response = await readKvStore(\n      kvStore.store,\n      `${kvStore.path}${chunk.fragmentId}`,\n      { signal, throwIfMissing: true },\n    );\n    decodeFragmentChunk(chunk, await response.response.arrayBuffer());\n  }\n}\n\ninterface PrecomputedMultiscaleManifestChunk extends MultiscaleManifestChunk {\n  /**\n   * Byte offsets into data file for each octree node.\n   *\n   * Stored as Float64Array to allow 53-bit integer values.\n   */\n  offsets: Float64Array;\n  shardInfo?: ShardInfo;\n}\n\nfunction decodeMultiscaleManifestChunk(\n  chunk: PrecomputedMultiscaleManifestChunk,\n  response: ArrayBuffer,\n) {\n  if (response.byteLength < 28 || response.byteLength % 4 !== 0) {\n    throw new Error(`Invalid index file size: ${response.byteLength}`);\n  }\n  const dv = new DataView(response);\n  let offset = 0;\n  const chunkShape = vec3.fromValues(\n    dv.getFloat32(offset, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 4, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 8, /*littleEndian=*/ true),\n  );\n  offset += 12;\n  const gridOrigin = vec3.fromValues(\n    dv.getFloat32(offset, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 4, /*littleEndian=*/ true),\n    dv.getFloat32(offset + 8, /*littleEndian=*/ true),\n  );\n  offset += 12;\n  const numStoredLods = dv.getUint32(offset, /*littleEndian=*/ true);\n  offset += 4;\n  if (response.byteLength < offset + (4 + 4 + 4 * 3) * numStoredLods) {\n    throw new Error(\n      `Invalid index file size for ${numStoredLods} lods: ${response.byteLength}`,\n    );\n  }\n  const storedLodScales = new Float32Array(response, offset, numStoredLods);\n  offset += 4 * numStoredLods;\n  convertEndian32(storedLodScales, Endianness.LITTLE);\n  const vertexOffsets = new Float32Array(response, offset, numStoredLods * 3);\n  convertEndian32(vertexOffsets, Endianness.LITTLE);\n  offset += 12 * numStoredLods;\n  const numFragmentsPerLod = new Uint32Array(response, offset, numStoredLods);\n  offset += 4 * numStoredLods;\n  convertEndian32(numFragmentsPerLod, Endianness.LITTLE);\n  const totalFragments = numFragmentsPerLod.reduce((a, b) => a + b);\n  if (response.byteLength !== offset + 16 * totalFragments) {\n    throw new Error(\n      `Invalid index file size for ${numStoredLods} lods and ` +\n        `${totalFragments} total fragments: ${response.byteLength}`,\n    );\n  }\n  const fragmentInfo = new Uint32Array(response, offset);\n  convertEndian32(fragmentInfo, Endianness.LITTLE);\n  const clipLowerBound = vec3.fromValues(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n  const clipUpperBound = vec3.fromValues(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n  let numLods = Math.max(1, storedLodScales.length);\n  // Compute `clipLowerBound` and `clipUpperBound` and `numLods`.  Note that `numLods` is >=\n  // `storedLodScales.length`; it may contain additional levels since at the highest level the\n  // octree must be a single node.\n  {\n    let fragmentBase = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      if (DEBUG_MULTISCALE_INDEX) {\n        for (let i = 1; i < numFragments; ++i) {\n          const x0 = fragmentInfo[fragmentBase + numFragments * 0 + (i - 1)];\n          const y0 = fragmentInfo[fragmentBase + numFragments * 1 + (i - 1)];\n          const z0 = fragmentInfo[fragmentBase + numFragments * 2 + (i - 1)];\n          const x1 = fragmentInfo[fragmentBase + numFragments * 0 + i];\n          const y1 = fragmentInfo[fragmentBase + numFragments * 1 + i];\n          const z1 = fragmentInfo[fragmentBase + numFragments * 2 + i];\n          if (!zorder3LessThan(x0, y0, z0, x1, y1, z1)) {\n            console.log(\n              \"Fragment index violates zorder constraint: \" +\n                `lod=${lodIndex}, ` +\n                `chunk ${i - 1} = [${x0},${y0},${z0}], ` +\n                `chunk ${i} = [${x1},${y1},${z1}]`,\n            );\n          }\n        }\n      }\n      for (let i = 0; i < 3; ++i) {\n        let upperBoundValue = Number.NEGATIVE_INFINITY;\n        let lowerBoundValue = Number.POSITIVE_INFINITY;\n        const base = fragmentBase + numFragments * i;\n        for (let j = 0; j < numFragments; ++j) {\n          const v = fragmentInfo[base + j];\n          upperBoundValue = Math.max(upperBoundValue, v);\n          lowerBoundValue = Math.min(lowerBoundValue, v);\n        }\n        if (numFragments !== 0) {\n          while (\n            upperBoundValue >>> (numLods - lodIndex - 1) !==\n            lowerBoundValue >>> (numLods - lodIndex - 1)\n          ) {\n            ++numLods;\n          }\n          if (lodIndex === 0) {\n            clipLowerBound[i] = Math.min(\n              clipLowerBound[i],\n              (1 << lodIndex) * lowerBoundValue,\n            );\n            clipUpperBound[i] = Math.max(\n              clipUpperBound[i],\n              (1 << lodIndex) * (upperBoundValue + 1),\n            );\n          }\n        }\n      }\n      fragmentBase += numFragments * 4;\n    }\n  }\n\n  // Compute upper bound on number of nodes that will be in the octree, so that we can allocate a\n  // sufficiently large buffer without having to worry about resizing.\n  let maxFragments = 0;\n  {\n    let prevNumFragments = 0;\n    let prevLodIndex = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      maxFragments += prevNumFragments * (lodIndex - prevLodIndex);\n      prevLodIndex = lodIndex;\n      prevNumFragments = numFragments;\n      maxFragments += numFragments;\n    }\n    maxFragments += (numLods - 1 - prevLodIndex) * prevNumFragments;\n  }\n  const octreeTemp = new Uint32Array(5 * maxFragments);\n  const offsetsTemp = new Float64Array(maxFragments + 1);\n  let octree: Uint32Array;\n  {\n    let priorStart = 0;\n    let baseRow = 0;\n    let dataOffset = 0;\n    let fragmentBase = 0;\n    for (let lodIndex = 0; lodIndex < numStoredLods; ++lodIndex) {\n      const numFragments = numFragmentsPerLod[lodIndex];\n      // Copy in indices\n      for (let j = 0; j < numFragments; ++j) {\n        for (let i = 0; i < 3; ++i) {\n          octreeTemp[5 * (baseRow + j) + i] =\n            fragmentInfo[fragmentBase + j + i * numFragments];\n        }\n        const dataSize = fragmentInfo[fragmentBase + j + 3 * numFragments];\n        dataOffset += dataSize;\n        offsetsTemp[baseRow + j + 1] = dataOffset;\n        if (dataSize === 0) {\n          // Mark node as empty.\n          octreeTemp[5 * (baseRow + j) + 4] = 0x80000000;\n        }\n      }\n\n      fragmentBase += 4 * numFragments;\n\n      if (lodIndex !== 0) {\n        // Connect with prior level\n        computeOctreeChildOffsets(\n          octreeTemp,\n          priorStart,\n          baseRow,\n          baseRow + numFragments,\n        );\n      }\n\n      priorStart = baseRow;\n      baseRow += numFragments;\n      while (\n        lodIndex + 1 < numLods &&\n        (lodIndex + 1 >= storedLodScales.length ||\n          storedLodScales[lodIndex + 1] === 0)\n      ) {\n        const curEnd = generateHigherOctreeLevel(\n          octreeTemp,\n          priorStart,\n          baseRow,\n        );\n        offsetsTemp.fill(dataOffset, baseRow + 1, curEnd + 1);\n        priorStart = baseRow;\n        baseRow = curEnd;\n        ++lodIndex;\n      }\n    }\n    octree = octreeTemp.slice(0, 5 * baseRow);\n    chunk.offsets = offsetsTemp.slice(0, baseRow + 1);\n  }\n  const source = chunk.source! as PrecomputedMultiscaleMeshSource;\n  const { lodScaleMultiplier } = source.parameters.metadata;\n  const lodScales = new Float32Array(numLods);\n  lodScales.set(storedLodScales, 0);\n  for (let i = 0; i < storedLodScales.length; ++i) {\n    lodScales[i] *= lodScaleMultiplier;\n  }\n  chunk.manifest = {\n    chunkShape,\n    chunkGridSpatialOrigin: gridOrigin,\n    clipLowerBound: vec3.add(\n      clipLowerBound,\n      gridOrigin,\n      vec3.multiply(clipLowerBound, clipLowerBound, chunkShape),\n    ),\n    clipUpperBound: vec3.add(\n      clipUpperBound,\n      gridOrigin,\n      vec3.multiply(clipUpperBound, clipUpperBound, chunkShape),\n    ),\n    octree,\n    lodScales,\n    vertexOffsets,\n  };\n}\n\nasync function decodeMultiscaleFragmentChunk(\n  chunk: MultiscaleFragmentChunk,\n  response: ArrayBuffer,\n) {\n  const { lod } = chunk;\n  const source = chunk.manifestChunk!\n    .source! as PrecomputedMultiscaleMeshSource;\n  const rawMesh = await decodeDracoPartitioned(\n    new Uint8Array(response),\n    source.parameters.metadata.vertexQuantizationBits,\n    lod !== 0,\n  );\n  assignMultiscaleMeshFragmentData(\n    chunk,\n    rawMesh,\n    source.format.vertexPositionFormat,\n  );\n}\n\n@registerSharedObject() //\nexport class PrecomputedMultiscaleMeshSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(MultiscaleMeshSource),\n  MultiscaleMeshSourceParameters,\n) {\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  shardedKvStore = getShardedKvStoreIfApplicable(\n    this,\n    this.kvStore,\n    this.parameters.metadata.sharding,\n  );\n\n  async download(\n    chunk: PrecomputedMultiscaleManifestChunk,\n    signal: AbortSignal,\n  ): Promise<void> {\n    const { shardedKvStore } = this;\n    let readResponse: ReadResponse | undefined;\n    if (shardedKvStore === undefined) {\n      const { kvStore } = this;\n      readResponse = await kvStore.store.read(\n        `${kvStore.path}${chunk.objectId}.index`,\n        { signal },\n      );\n    } else {\n      ({ response: readResponse, shardInfo: chunk.shardInfo } =\n        getOrNotFoundError(\n          await shardedKvStore.readWithShardInfo(chunk.objectId, {\n            signal,\n          }),\n        ));\n    }\n\n    const data = await getOrNotFoundError(readResponse).response.arrayBuffer();\n\n    decodeMultiscaleManifestChunk(chunk, data);\n  }\n\n  async downloadFragment(\n    chunk: MultiscaleFragmentChunk,\n    signal: AbortSignal,\n  ): Promise<void> {\n    const { kvStore } = this;\n    const manifestChunk =\n      chunk.manifestChunk! as PrecomputedMultiscaleManifestChunk;\n    const chunkIndex = chunk.chunkIndex;\n    const { shardInfo, offsets } = manifestChunk;\n    const startOffset = offsets[chunkIndex];\n    const endOffset = offsets[chunkIndex + 1];\n    let requestPath: string;\n    let adjustedStartOffset: number;\n    let adjustedEndOffset: number;\n    if (shardInfo !== undefined) {\n      requestPath = shardInfo.shardPath;\n      const fullDataSize = offsets[offsets.length - 1];\n      const start = shardInfo.offset - fullDataSize + startOffset;\n      const end = start + endOffset - startOffset;\n      adjustedStartOffset = start;\n      adjustedEndOffset = end;\n    } else {\n      requestPath = `${kvStore.path}${manifestChunk.objectId}`;\n      adjustedStartOffset = startOffset;\n      adjustedEndOffset = endOffset;\n    }\n    const readResponse = await readKvStore(kvStore.store, requestPath, {\n      signal,\n      byteRange: {\n        offset: adjustedStartOffset,\n        length: adjustedEndOffset - adjustedStartOffset,\n      },\n      throwIfMissing: true,\n      strictByteRange: true,\n    });\n    await decodeMultiscaleFragmentChunk(\n      chunk,\n      await readResponse.response.arrayBuffer(),\n    );\n  }\n}\n\nasync function fetchByUint64(\n  chunkSource: {\n    kvStore: KvStoreWithPath;\n    shardedKvStore: ShardedKvStore | undefined;\n  },\n  id: bigint,\n  signal: AbortSignal,\n): Promise<ReadResponse | undefined> {\n  const { shardedKvStore } = chunkSource;\n  if (shardedKvStore === undefined) {\n    const { kvStore } = chunkSource;\n    return kvStore.store.read(`${kvStore.path}${id}`, {\n      signal,\n    });\n  } else {\n    return shardedKvStore.read(id, { signal });\n  }\n}\n\n@registerSharedObject() //\nexport class PrecomputedSkeletonSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(SkeletonSource),\n  SkeletonSourceParameters,\n) {\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  shardedKvStore = getShardedKvStoreIfApplicable(\n    this,\n    this.kvStore,\n    this.parameters.metadata.sharding,\n  );\n  async download(chunk: SkeletonChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const response = getOrNotFoundError(\n      await fetchByUint64(this, chunk.objectId, signal),\n    );\n    decodeSkeletonChunk(\n      chunk,\n      await response.response.arrayBuffer(),\n      parameters.metadata.vertexAttributes,\n    );\n  }\n}\n\nfunction parseAnnotations(\n  buffer: ArrayBuffer,\n  parameters: AnnotationSourceParameters,\n  propertySerializer: AnnotationPropertySerializer,\n): AnnotationGeometryData {\n  const dv = new DataView(buffer);\n  if (buffer.byteLength <= 8) throw new Error(\"Expected at least 8 bytes\");\n  const countLow = dv.getUint32(0, /*littleEndian=*/ true);\n  const countHigh = dv.getUint32(4, /*littleEndian=*/ true);\n  if (countHigh !== 0) throw new Error(\"Annotation count too high\");\n  const numBytes = propertySerializer.serializedBytes;\n  const expectedBytes = 8 + (numBytes + 8) * countLow;\n  if (buffer.byteLength !== expectedBytes) {\n    throw new Error(\n      `Expected ${expectedBytes} bytes, but received: ${buffer.byteLength} bytes`,\n    );\n  }\n  const idOffset = 8 + numBytes * countLow;\n  const ids = new Array<string>(countLow);\n  for (let i = 0; i < countLow; ++i) {\n    ids[i] = dv\n      .getBigUint64(idOffset + i * 8, /*littleEndian=*/ true)\n      .toString();\n  }\n  const geometryData = new AnnotationGeometryData();\n  const origData = new Uint8Array(buffer, 8, numBytes * countLow);\n  let data: Uint8Array<ArrayBuffer>;\n  const { propertyGroupBytes } = propertySerializer;\n  if (propertyGroupBytes.length > 1) {\n    // Need to transpose the property data.\n    data = new Uint8Array(origData.length);\n\n    let origOffset = 0;\n    let groupOffset = 0;\n    for (\n      let groupIndex = 0;\n      groupIndex < propertyGroupBytes.length;\n      ++groupIndex\n    ) {\n      const groupBytesPerAnnotation = propertyGroupBytes[groupIndex];\n      for (\n        let annotationIndex = 0;\n        annotationIndex < countLow;\n        ++annotationIndex\n      ) {\n        const origBase = origOffset + annotationIndex * numBytes;\n        const newBase = groupOffset + annotationIndex * groupBytesPerAnnotation;\n        for (let i = 0; i < groupBytesPerAnnotation; ++i) {\n          data[newBase + i] = origData[origBase + i];\n        }\n      }\n      origOffset += groupBytesPerAnnotation;\n      groupOffset += groupBytesPerAnnotation * countLow;\n    }\n  } else {\n    data = origData;\n  }\n  geometryData.data = data;\n  // FIXME: convert endian in order to support big endian platforms\n  const typeToOffset = (geometryData.typeToOffset = new Array<number>(\n    annotationTypes.length,\n  ));\n  typeToOffset.fill(0);\n  typeToOffset[parameters.type] = 0;\n  const typeToIds = (geometryData.typeToIds = new Array<string[]>(\n    annotationTypes.length,\n  ));\n  const typeToIdMaps = (geometryData.typeToIdMaps = new Array<\n    Map<string, number>\n  >(annotationTypes.length));\n  typeToIds.fill([]);\n  typeToIds[parameters.type] = ids;\n  typeToIdMaps.fill(new Map());\n  typeToIdMaps[parameters.type] = new Map(ids.map((id, i) => [id, i]));\n  return geometryData;\n}\n\nfunction parseSingleAnnotation(\n  buffer: ArrayBuffer,\n  parameters: AnnotationSourceParameters,\n  propertySerializer: AnnotationPropertySerializer,\n  id: string,\n): Annotation {\n  const handler = annotationTypeHandlers[parameters.type];\n  const baseNumBytes = propertySerializer.serializedBytes;\n  const numRelationships = parameters.relationships.length;\n  const minNumBytes = baseNumBytes + 4 * numRelationships;\n  if (buffer.byteLength < minNumBytes) {\n    throw new Error(\n      `Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`,\n    );\n  }\n  const dv = new DataView(buffer);\n  const annotation = handler.deserialize(\n    dv,\n    0,\n    /*isLittleEndian=*/ true,\n    parameters.rank,\n    id,\n  );\n  propertySerializer.deserialize(\n    dv,\n    /*offset=*/ 0,\n    /*annotationIndex=*/ 0,\n    /*annotationCount=*/ 1,\n    /*isLittleEndian=*/ true,\n    (annotation.properties = new Array(parameters.properties.length)),\n  );\n  let offset = baseNumBytes;\n  const relatedSegments: BigUint64Array[] = (annotation.relatedSegments = []);\n  relatedSegments.length = numRelationships;\n  for (let i = 0; i < numRelationships; ++i) {\n    const count = dv.getUint32(offset, /*littleEndian=*/ true);\n    if (buffer.byteLength < minNumBytes + count * 8) {\n      throw new Error(\n        `Expected at least ${minNumBytes} bytes, but received: ${buffer.byteLength}`,\n      );\n    }\n    offset += 4;\n    const segments = (relatedSegments[i] = new BigUint64Array(count));\n    for (let j = 0; j < count; ++j) {\n      segments[j] = dv.getBigUint64(offset, /*littleEndian=*/ true);\n      offset += 8;\n    }\n  }\n  if (offset !== buffer.byteLength) {\n    throw new Error(\n      `Expected ${offset} bytes, but received: ${buffer.byteLength}`,\n    );\n  }\n  return annotation;\n}\n\n@registerSharedObject() //\nexport class PrecomputedAnnotationSpatialIndexSourceBackend extends WithParameters(\n  WithSharedKvStoreContextCounterpart(AnnotationGeometryChunkSourceBackend),\n  AnnotationSpatialIndexSourceParameters,\n) {\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  shardedKvStore = getShardedKvStoreIfApplicable(\n    this,\n    this.kvStore,\n    this.parameters.sharding,\n  );\n  declare parent: PrecomputedAnnotationSourceBackend;\n  async download(chunk: AnnotationGeometryChunk, signal: AbortSignal) {\n    const { shardedKvStore } = this;\n    const { parent } = this;\n    let response: ReadResponse | undefined;\n    const { chunkGridPosition } = chunk;\n    if (shardedKvStore === undefined) {\n      const { kvStore } = this;\n      const path = `${kvStore.path}${chunkGridPosition.join(\"_\")}`;\n      response = await kvStore.store.read(path, { signal });\n    } else {\n      const { upperChunkBound } = this.spec;\n      const { chunkGridPosition } = chunk;\n      const chunkIndex = encodeZIndexCompressed(\n        chunkGridPosition,\n        upperChunkBound,\n      );\n      response = await shardedKvStore.read(chunkIndex, { signal });\n    }\n    if (response !== undefined) {\n      chunk.data = parseAnnotations(\n        await response.response.arrayBuffer(),\n        parent.parameters,\n        parent.annotationPropertySerializer,\n      );\n    }\n  }\n}\n\n@registerSharedObject() //\nexport class PrecomputedAnnotationSourceBackend extends WithParameters(\n  WithSharedKvStoreContextCounterpart(AnnotationSource),\n  AnnotationSourceParameters,\n) {\n  kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.byId.url,\n  );\n  shardedKvStore = getShardedKvStoreIfApplicable(\n    this,\n    this.kvStore,\n    this.parameters.byId.sharding,\n  );\n  private relationshipIndexSource = this.parameters.relationships.map((x) => {\n    const kvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(x.url);\n    const shardedKvStore = getShardedKvStoreIfApplicable(\n      this,\n      kvStore,\n      x.sharding,\n    );\n    return { kvStore, shardedKvStore };\n  });\n  annotationPropertySerializer = new AnnotationPropertySerializer(\n    this.parameters.rank,\n    annotationTypeHandlers[this.parameters.type].serializedBytes(\n      this.parameters.rank,\n    ),\n    this.parameters.properties,\n  );\n\n  async downloadSegmentFilteredGeometry(\n    chunk: AnnotationSubsetGeometryChunk,\n    relationshipIndex: number,\n    signal: AbortSignal,\n  ) {\n    const response = await fetchByUint64(\n      this.relationshipIndexSource[relationshipIndex],\n      chunk.objectId,\n      signal,\n    );\n    if (response !== undefined) {\n      chunk.data = parseAnnotations(\n        await response.response.arrayBuffer(),\n        this.parameters,\n        this.annotationPropertySerializer,\n      );\n    }\n  }\n\n  async downloadMetadata(chunk: AnnotationMetadataChunk, signal: AbortSignal) {\n    const id = BigInt(chunk.key!);\n    const response = await fetchByUint64(this, id, signal);\n    if (response === undefined) {\n      chunk.annotation = null;\n    } else {\n      chunk.annotation = parseSingleAnnotation(\n        await response.response.arrayBuffer(),\n        this.parameters,\n        this.annotationPropertySerializer,\n        chunk.key!,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SkeletonChunk } from \"#src/skeleton/backend.js\";\nimport { decodeSkeletonVertexPositionsAndIndices } from \"#src/skeleton/backend.js\";\nimport type { VertexAttributeInfo } from \"#src/skeleton/base.js\";\nimport { DATA_TYPE_BYTES } from \"#src/util/data_type.js\";\nimport {\n  convertEndian16,\n  convertEndian32,\n  Endianness,\n} from \"#src/util/endian.js\";\n\nexport function decodeSkeletonChunk(\n  chunk: SkeletonChunk,\n  response: ArrayBuffer,\n  vertexAttributes: Map<string, VertexAttributeInfo>,\n) {\n  const dv = new DataView(response);\n  const numVertices = dv.getUint32(0, true);\n  const numEdges = dv.getUint32(4, true);\n\n  const vertexPositionsStartOffset = 8;\n\n  let curOffset = 8 + numVertices * 4 * 3;\n  decodeSkeletonVertexPositionsAndIndices(\n    chunk,\n    response,\n    Endianness.LITTLE,\n    /*vertexByteOffset=*/ vertexPositionsStartOffset,\n    numVertices,\n    /*indexByteOffset=*/ curOffset,\n    /*numEdges=*/ numEdges,\n  );\n  curOffset += numEdges * 4 * 2;\n  const attributes: Uint8Array[] = [];\n  for (const info of vertexAttributes.values()) {\n    const bytesPerVertex = DATA_TYPE_BYTES[info.dataType] * info.numComponents;\n    const totalBytes = bytesPerVertex * numVertices;\n    const attribute = new Uint8Array(response, curOffset, totalBytes);\n    switch (bytesPerVertex) {\n      case 2:\n        convertEndian16(attribute, Endianness.LITTLE);\n        break;\n      case 4:\n      case 8:\n        convertEndian32(attribute, Endianness.LITTLE);\n        break;\n    }\n    attributes.push(attribute);\n    curOffset += totalBytes;\n  }\n  chunk.vertexAttributes = attributes;\n}\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debounce } from \"lodash-es\";\nimport {\n  WithParameters,\n  withChunkManager,\n  Chunk,\n  ChunkSource,\n} from \"#src/chunk_manager/backend.js\";\nimport { ChunkPriorityTier, ChunkState } from \"#src/chunk_manager/base.js\";\nimport type { ChunkedGraphChunkSpecification } from \"#src/datasource/graphene/base.js\";\nimport {\n  getGrapheneFragmentKey,\n  GRAPHENE_MESH_NEW_SEGMENT_RPC_ID,\n  ChunkedGraphSourceParameters,\n  MeshSourceParameters,\n  CHUNKED_GRAPH_LAYER_RPC_ID,\n  CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID,\n  RENDER_RATIO_LIMIT,\n  isBaseSegmentId,\n  parseGrapheneError,\n  getHttpSource,\n} from \"#src/datasource/graphene/base.js\";\nimport { decodeManifestChunk } from \"#src/datasource/precomputed/backend.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { KvStoreWithPath, ReadResponse } from \"#src/kvstore/index.js\";\nimport { readKvStore } from \"#src/kvstore/index.js\";\nimport type { FragmentChunk, ManifestChunk } from \"#src/mesh/backend.js\";\nimport { assignMeshFragmentData, MeshSource } from \"#src/mesh/backend.js\";\nimport { decodeDraco } from \"#src/mesh/draco/index.js\";\nimport type { DisplayDimensionRenderInfo } from \"#src/navigation_state.js\";\nimport type {\n  RenderedViewBackend,\n  RenderLayerBackendAttachment,\n} from \"#src/render_layer_backend.js\";\nimport { RenderLayerBackend } from \"#src/render_layer_backend.js\";\nimport { withSegmentationLayerBackendState } from \"#src/segmentation_display_state/backend.js\";\nimport { forEachVisibleSegment } from \"#src/segmentation_display_state/base.js\";\nimport type { SharedWatchableValue } from \"#src/shared_watchable_value.js\";\nimport type { SliceViewChunkSourceBackend } from \"#src/sliceview/backend.js\";\nimport { deserializeTransformedSources } from \"#src/sliceview/backend.js\";\nimport type {\n  TransformedSource,\n  SliceViewProjectionParameters,\n} from \"#src/sliceview/base.js\";\nimport {\n  forEachPlaneIntersectingVolumetricChunk,\n  getNormalizedChunkLayout,\n} from \"#src/sliceview/base.js\";\nimport { computeChunkBounds } from \"#src/sliceview/volume/backend.js\";\nimport { Uint64Set } from \"#src/uint64_set.js\";\nimport { vec3, vec3Key } from \"#src/util/geom.js\";\nimport { HttpError } from \"#src/util/http_request.js\";\nimport { parseUint64 } from \"#src/util/json.js\";\nimport {\n  getBasePriority,\n  getPriorityTier,\n  withSharedVisibility,\n} from \"#src/visibility_priority/backend.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerSharedObject, registerRPC } from \"#src/worker_rpc.js\";\n\nfunction downloadFragmentWithSharding(\n  fragmentKvStore: KvStoreWithPath,\n  fragmentId: string,\n  signal: AbortSignal,\n): Promise<ReadResponse> {\n  if (fragmentId && fragmentId.charAt(0) === \"~\") {\n    const parts = fragmentId.substring(1).split(\":\");\n    const byteRange = { offset: Number(parts[1]), length: Number(parts[2]) };\n    return readKvStore(\n      fragmentKvStore.store,\n      `${fragmentKvStore.path}initial/${parts[0]}`,\n      { signal, byteRange, throwIfMissing: true },\n    );\n  }\n  return readKvStore(\n    fragmentKvStore.store,\n    `${fragmentKvStore.path}dynamic/${fragmentId}`,\n    { signal, throwIfMissing: true },\n  );\n}\n\nfunction downloadFragment(\n  fragmentKvStore: KvStoreWithPath,\n  fragmentId: string,\n  parameters: MeshSourceParameters,\n  signal: AbortSignal,\n): Promise<ReadResponse> {\n  if (parameters.sharding) {\n    return downloadFragmentWithSharding(fragmentKvStore, fragmentId, signal);\n  } else {\n    return readKvStore(\n      fragmentKvStore.store,\n      `${fragmentKvStore.path}/${fragmentId}`,\n      { signal, throwIfMissing: true },\n    );\n  }\n}\n\nasync function decodeDracoFragmentChunk(\n  chunk: FragmentChunk,\n  response: Uint8Array,\n) {\n  const rawMesh = await decodeDraco(response);\n  assignMeshFragmentData(chunk, rawMesh);\n}\n\n@registerSharedObject()\nexport class GrapheneMeshSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(MeshSource),\n  MeshSourceParameters,\n) {\n  manifestRequestCount = new Map<string, number>();\n  newSegments = new Uint64Set();\n\n  manifestHttpSource = getHttpSource(\n    this.sharedKvStoreContext.kvStoreContext,\n    this.parameters.manifestUrl,\n  );\n  fragmentKvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.fragmentUrl,\n  );\n\n  addNewSegment(segment: bigint) {\n    const { newSegments } = this;\n    newSegments.add(segment);\n    const TEN_MINUTES = 1000 * 60 * 10;\n    setTimeout(() => {\n      newSegments.delete(segment);\n    }, TEN_MINUTES);\n  }\n\n  async download(chunk: ManifestChunk, signal: AbortSignal) {\n    const { parameters, newSegments, manifestRequestCount } = this;\n    if (isBaseSegmentId(chunk.objectId, parameters.nBitsForLayerId)) {\n      return decodeManifestChunk(chunk, { fragments: [] });\n    }\n    const { fetchOkImpl, baseUrl } = this.manifestHttpSource;\n    const manifestPath = `/manifest/${chunk.objectId}:${parameters.lod}?verify=1&prepend_seg_ids=1`;\n    const response = await (\n      await fetchOkImpl(baseUrl + manifestPath, { signal })\n    ).json();\n    const chunkIdentifier = manifestPath;\n    if (newSegments.has(chunk.objectId)) {\n      const requestCount = (manifestRequestCount.get(chunkIdentifier) ?? 0) + 1;\n      manifestRequestCount.set(chunkIdentifier, requestCount);\n      setTimeout(\n        () => {\n          this.chunkManager.queueManager.updateChunkState(\n            chunk,\n            ChunkState.QUEUED,\n          );\n        },\n        2 ** requestCount * 1000,\n      );\n    } else {\n      manifestRequestCount.delete(chunkIdentifier);\n    }\n    return decodeManifestChunk(chunk, response);\n  }\n\n  async downloadFragment(chunk: FragmentChunk, signal: AbortSignal) {\n    const { response } = await downloadFragment(\n      this.fragmentKvStore,\n      chunk.fragmentId!,\n      this.parameters,\n      signal,\n    );\n    await decodeDracoFragmentChunk(\n      chunk,\n      new Uint8Array(await response.arrayBuffer()),\n    );\n  }\n\n  getFragmentKey(objectKey: string | null, fragmentId: string) {\n    objectKey;\n    return getGrapheneFragmentKey(fragmentId);\n  }\n}\n\nexport class ChunkedGraphChunk extends Chunk {\n  chunkGridPosition: Float32Array;\n  source: GrapheneChunkedGraphChunkSource | null = null;\n  segment: bigint;\n  leaves: BigUint64Array = new BigUint64Array(0);\n  chunkDataSize: Uint32Array | null;\n\n  initializeVolumeChunk(key: string, chunkGridPosition: Float32Array) {\n    super.initialize(key);\n    this.chunkGridPosition = Float32Array.from(chunkGridPosition);\n  }\n\n  initializeChunkedGraphChunk(\n    key: string,\n    chunkGridPosition: Float32Array,\n    segment: bigint,\n  ) {\n    this.initializeVolumeChunk(key, chunkGridPosition);\n    this.chunkDataSize = null;\n    this.systemMemoryBytes = 16;\n    this.gpuMemoryBytes = 0;\n    this.segment = segment;\n  }\n\n  downloadSucceeded() {\n    this.systemMemoryBytes = 16; // this.segment\n    this.systemMemoryBytes += this.leaves.byteLength;\n    this.queueManager.updateChunkState(this, ChunkState.SYSTEM_MEMORY_WORKER);\n    if (this.priorityTier < ChunkPriorityTier.RECENT) {\n      this.source!.chunkManager.scheduleUpdateChunkPriorities();\n    }\n    super.downloadSucceeded();\n  }\n\n  freeSystemMemory() {\n    this.leaves = new BigUint64Array(0);\n  }\n}\n\nfunction decodeChunkedGraphChunk(leaves: string[]) {\n  return BigUint64Array.from(leaves, parseUint64);\n}\n\n@registerSharedObject()\nexport class GrapheneChunkedGraphChunkSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(ChunkSource),\n  ChunkedGraphSourceParameters,\n) {\n  spec: ChunkedGraphChunkSpecification;\n  declare chunks: Map<string, ChunkedGraphChunk>;\n  tempChunkDataSize: Uint32Array;\n  tempChunkPosition: Float32Array;\n\n  httpSource = getHttpSource(\n    this.sharedKvStoreContext.kvStoreContext,\n    this.parameters.url,\n  );\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.spec = options.spec;\n    const rank = this.spec.rank;\n    this.tempChunkDataSize = new Uint32Array(rank);\n    this.tempChunkPosition = new Float32Array(rank);\n  }\n\n  async download(chunk: ChunkedGraphChunk, signal: AbortSignal): Promise<void> {\n    const chunkPosition = this.computeChunkBounds(chunk);\n    const chunkDataSize = chunk.chunkDataSize!;\n    const bounds =\n      `${chunkPosition[0]}-${chunkPosition[0] + chunkDataSize[0]}_` +\n      `${chunkPosition[1]}-${chunkPosition[1] + chunkDataSize[1]}_` +\n      `${chunkPosition[2]}-${chunkPosition[2] + chunkDataSize[2]}`;\n\n    const { fetchOkImpl, baseUrl } = this.httpSource;\n    const request = fetchOkImpl(\n      `${baseUrl}/${chunk.segment}/leaves?int64_as_str=1&bounds=${bounds}`,\n      { signal },\n    );\n    await this.withErrorMessage(\n      request,\n      `Fetching leaves of segment ${chunk.segment} in region ${bounds}: `,\n    )\n      .then((res) => res.json())\n      .then((res) => {\n        chunk.leaves = decodeChunkedGraphChunk(res.leaf_ids);\n      })\n      .catch((err) => {\n        if (err instanceof Error && err.name === \"AbortError\") return;\n        console.error(err);\n      });\n  }\n\n  getChunk(chunkGridPosition: Float32Array, segment: bigint) {\n    const key = `${vec3Key(chunkGridPosition)}-${segment}`;\n    let chunk = <ChunkedGraphChunk>this.chunks.get(key);\n\n    if (chunk === undefined) {\n      chunk = this.getNewChunk_(ChunkedGraphChunk);\n      chunk.initializeChunkedGraphChunk(key, chunkGridPosition, segment);\n      this.addChunk(chunk);\n    }\n    return chunk;\n  }\n\n  computeChunkBounds(chunk: ChunkedGraphChunk) {\n    return computeChunkBounds(this, chunk);\n  }\n\n  async withErrorMessage<T>(\n    promise: Promise<T>,\n    errorPrefix: string,\n  ): Promise<T> {\n    return promise.catch(async (e) => {\n      if (e instanceof HttpError && e.response) {\n        const msg = await parseGrapheneError(e);\n        throw new Error(`[${e.response.status}] ${errorPrefix}${msg ?? \"\"}`);\n      }\n      throw e;\n    });\n  }\n}\n\ninterface ChunkedGraphRenderLayerAttachmentState {\n  displayDimensionRenderInfo: DisplayDimensionRenderInfo;\n  transformedSource?: TransformedSource<\n    ChunkedGraphLayer,\n    GrapheneChunkedGraphChunkSource\n  >;\n}\n\nconst tempChunkPosition = vec3.create();\nconst tempCenter = vec3.create();\nconst tempChunkSize = vec3.create();\n\n@registerSharedObject(CHUNKED_GRAPH_LAYER_RPC_ID)\nexport class ChunkedGraphLayer extends withSegmentationLayerBackendState(\n  withSharedVisibility(withChunkManager(RenderLayerBackend)),\n) {\n  source: GrapheneChunkedGraphChunkSource;\n  localPosition: SharedWatchableValue<Float32Array>;\n  leafRequestsActive: SharedWatchableValue<boolean>;\n  nBitsForLayerId: SharedWatchableValue<number>;\n\n  constructor(rpc: RPC, options: any) {\n    super(rpc, options);\n    this.source = this.registerDisposer(\n      rpc.getRef<GrapheneChunkedGraphChunkSource>(options.source),\n    );\n    this.localPosition = rpc.get(options.localPosition);\n    this.leafRequestsActive = rpc.get(options.leafRequestsActive);\n    this.nBitsForLayerId = rpc.get(options.nBitsForLayerId);\n\n    this.registerDisposer(\n      this.chunkManager.recomputeChunkPriorities.add(() => {\n        this.updateChunkPriorities();\n        this.debouncedupdateDisplayState();\n      }),\n    );\n  }\n\n  attach(\n    attachment: RenderLayerBackendAttachment<\n      RenderedViewBackend,\n      ChunkedGraphRenderLayerAttachmentState\n    >,\n  ): void {\n    const scheduleUpdateChunkPriorities = () =>\n      this.chunkManager.scheduleUpdateChunkPriorities();\n    const { view } = attachment;\n    attachment.registerDisposer(scheduleUpdateChunkPriorities);\n    attachment.registerDisposer(\n      view.projectionParameters.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.registerDisposer(\n      view.visibility.changed.add(scheduleUpdateChunkPriorities),\n    );\n    attachment.state = {\n      displayDimensionRenderInfo:\n        view.projectionParameters.value.displayDimensionRenderInfo,\n    };\n  }\n\n  // Used for the sliceview to set a limit on when to\n  // make get_leaves to the ChunkedGraph\n  get renderRatioLimit() {\n    return RENDER_RATIO_LIMIT;\n  }\n\n  private updateChunkPriorities() {\n    const { source, chunkManager } = this;\n    chunkManager.registerLayer(this);\n    for (const attachment of this.attachments.values()) {\n      const { view } = attachment;\n      const visibility = view.visibility.value;\n      if (visibility === Number.NEGATIVE_INFINITY) {\n        continue;\n      }\n\n      const attachmentState =\n        attachment.state! as ChunkedGraphRenderLayerAttachmentState;\n      const { transformedSource: tsource } = attachmentState;\n      const projectionParameters = view.projectionParameters\n        .value as SliceViewProjectionParameters;\n\n      if (!tsource) {\n        continue;\n      }\n\n      const pixelSize = projectionParameters.pixelSize * 1.1;\n      const smallestVoxelSize = tsource.effectiveVoxelSize;\n      this.leafRequestsActive.value =\n        this.renderRatioLimit >= pixelSize / Math.min(...smallestVoxelSize);\n      if (!this.leafRequestsActive.value) {\n        continue;\n      }\n\n      const priorityTier = getPriorityTier(visibility);\n      const basePriority = getBasePriority(visibility);\n\n      const { chunkLayout } = tsource;\n      const { size, finiteRank } = chunkLayout;\n\n      const chunkSize = tempChunkSize;\n      const localCenter = tempCenter;\n      vec3.copy(chunkSize, size);\n      for (let i = finiteRank; i < 3; ++i) {\n        chunkSize[i] = 0;\n        localCenter[i] = 0;\n      }\n      const { centerDataPosition } = projectionParameters;\n      chunkLayout.globalToLocalSpatial(localCenter, centerDataPosition);\n\n      forEachPlaneIntersectingVolumetricChunk(\n        projectionParameters,\n        this.localPosition.value,\n        tsource,\n        getNormalizedChunkLayout(projectionParameters, chunkLayout),\n        (positionInChunks) => {\n          vec3.multiply(tempChunkPosition, positionInChunks, chunkSize);\n          const priority = -vec3.distance(localCenter, tempChunkPosition);\n          const { curPositionInChunks } = tsource;\n\n          forEachVisibleSegment(this, (segment, _) => {\n            if (isBaseSegmentId(segment, this.nBitsForLayerId.value)) return; // TODO maybe support highBitRepresentation?\n            const chunk = source.getChunk(curPositionInChunks, segment);\n            chunkManager.requestChunk(\n              chunk,\n              priorityTier,\n              basePriority + priority,\n              ChunkState.SYSTEM_MEMORY_WORKER,\n            );\n            ++this.numVisibleChunksNeeded;\n            if (chunk.state === ChunkState.GPU_MEMORY) {\n              ++this.numVisibleChunksAvailable;\n            }\n          });\n        },\n      );\n    }\n  }\n\n  private forEachSelectedRootWithLeaves(\n    callback: (rootObject: bigint, leaves: BigUint64Array) => void,\n  ) {\n    const { source } = this;\n\n    for (const chunk of source.chunks.values()) {\n      if (\n        chunk.state === ChunkState.SYSTEM_MEMORY_WORKER &&\n        chunk.priorityTier < ChunkPriorityTier.RECENT\n      ) {\n        if (this.visibleSegments.has(chunk.segment) && chunk.leaves.length) {\n          callback(chunk.segment, chunk.leaves);\n        }\n      }\n    }\n  }\n\n  private debouncedupdateDisplayState = debounce(() => {\n    this.updateDisplayState();\n  }, 100);\n\n  private updateDisplayState() {\n    const visibleLeaves = new Map<bigint, Uint64Set>();\n    const capacities = new Map<bigint, number>();\n\n    // Reserve\n    this.forEachSelectedRootWithLeaves((rootObject, leaves) => {\n      capacities.set(\n        rootObject,\n        (capacities.get(rootObject) ?? 0) + leaves.length,\n      );\n    });\n\n    // Collect unique leaves\n    this.forEachSelectedRootWithLeaves((rootObject, leaves) => {\n      if (!visibleLeaves.has(rootObject)) {\n        visibleLeaves.set(rootObject, new Uint64Set());\n        visibleLeaves.get(rootObject)!.reserve(capacities.get(rootObject)!);\n        visibleLeaves.get(rootObject)!.add(rootObject);\n      }\n      visibleLeaves.get(rootObject)!.add(leaves);\n    });\n\n    for (const [root, leaves] of visibleLeaves) {\n      // TODO: Delete segments not visible anymore from segmentEquivalences - requires a faster data\n      // structure, though.\n\n      /*if (this.segmentEquivalences.has(root)) {\n        this.segmentEquivalences.delete([...this.segmentEquivalences.setElements(root)].filter(x\n      => !leaves.has(x) && !this.visibleSegments.has(x)));\n      }*/\n      const filteredLeaves = [...leaves].filter(\n        (x) => !this.segmentEquivalences.has(x),\n      );\n\n      for (const leaf of filteredLeaves) {\n        this.segmentEquivalences.link(root, leaf);\n      }\n    }\n  }\n}\n\nregisterRPC(CHUNKED_GRAPH_RENDER_LAYER_UPDATE_SOURCES_RPC_ID, function (x) {\n  const view = this.get(x.view) as RenderedViewBackend;\n  const layer = this.get(x.layer) as ChunkedGraphLayer;\n  const attachment = layer.attachments.get(\n    view,\n  )! as RenderLayerBackendAttachment<\n    RenderedViewBackend,\n    ChunkedGraphRenderLayerAttachmentState\n  >;\n  attachment.state!.transformedSource = deserializeTransformedSources<\n    SliceViewChunkSourceBackend,\n    ChunkedGraphLayer\n  >(this, x.sources, layer)[0][0] as unknown as TransformedSource<\n    ChunkedGraphLayer,\n    GrapheneChunkedGraphChunkSource\n  >;\n  attachment.state!.displayDimensionRenderInfo = x.displayDimensionRenderInfo;\n  layer.chunkManager.scheduleUpdateChunkPriorities();\n});\n\nregisterRPC(GRAPHENE_MESH_NEW_SEGMENT_RPC_ID, function (x) {\n  const obj = <GrapheneMeshSource>this.get(x.rpcId);\n  obj.addNewSegment(x.segment);\n});\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeBlosc =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeBlosc\",\n  );\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\n\nexport const decodeZstd =\n  asyncComputation<(data: Uint8Array<ArrayBuffer>) => Uint8Array<ArrayBuffer>>(\n    \"decodeZstd\",\n  );\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBlosc } from \"#src/async_computation/decode_blosc_request.js\";\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport {\n  VolumeChunkEncoding,\n  VolumeChunkSourceParameters,\n} from \"#src/datasource/n5/base.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nasync function decodeChunk(\n  chunk: VolumeChunk,\n  signal: AbortSignal,\n  response: ArrayBuffer,\n  encoding: VolumeChunkEncoding,\n) {\n  const dv = new DataView(response);\n  const mode = dv.getUint16(0, /*littleEndian=*/ false);\n  if (mode !== 0) {\n    throw new Error(`Unsupported mode: ${mode}.`);\n  }\n  const numDimensions = dv.getUint16(2, /*littleEndian=*/ false);\n  if (numDimensions !== chunk.source!.spec.rank) {\n    throw new Error(\"Number of dimensions must be 3.\");\n  }\n  let offset = 4;\n  const shape = new Uint32Array(numDimensions);\n  for (let i = 0; i < numDimensions; ++i) {\n    shape[i] = dv.getUint32(offset, /*littleEndian=*/ false);\n    offset += 4;\n  }\n  chunk.chunkDataSize = shape;\n  let buffer = new Uint8Array(response, offset);\n  switch (encoding) {\n    case VolumeChunkEncoding.ZLIB:\n      buffer = new Uint8Array(await decodeGzip(buffer, \"deflate\"));\n      break;\n    case VolumeChunkEncoding.GZIP:\n      buffer = new Uint8Array(await decodeGzip(buffer, \"gzip\"));\n      break;\n    case VolumeChunkEncoding.BLOSC:\n      buffer = await requestAsyncComputation(\n        decodeBlosc,\n        signal,\n        [buffer.buffer],\n        buffer,\n      );\n      break;\n    case VolumeChunkEncoding.ZSTD:\n      buffer = await requestAsyncComputation(\n        decodeZstd,\n        signal,\n        [buffer.buffer],\n        buffer,\n      );\n      break;\n  }\n  await decodeRawChunk(\n    chunk,\n    signal,\n    buffer.buffer,\n    Endianness.BIG,\n    buffer.byteOffset,\n    buffer.byteLength,\n  );\n}\n\n@registerSharedObject()\nexport class PrecomputedVolumeChunkSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(VolumeChunkSource),\n  VolumeChunkSourceParameters,\n) {\n  private chunkKvStore = this.sharedKvStoreContext.kvStoreContext.getKvStore(\n    this.parameters.url,\n  );\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    const { parameters, chunkKvStore } = this;\n    const { chunkGridPosition } = chunk;\n    let path = chunkKvStore.path;\n    const rank = this.spec.rank;\n    for (let i = 0; i < rank; ++i) {\n      if (i !== 0) {\n        path += \"/\";\n      }\n      path += `${chunkGridPosition[i]}`;\n    }\n    const response = await chunkKvStore.store.read(path, {\n      signal,\n    });\n    if (response === undefined) return;\n    await decodeChunk(\n      chunk,\n      signal,\n      await response.response.arrayBuffer(),\n      parameters.encoding,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\nimport type { SingleMesh } from \"#src/single_mesh/backend.js\";\n\nexport const parseOBJFromArrayBuffer = asyncComputation<\n  (buffer: ArrayBuffer) => {\n    data: SingleMesh;\n    size: number;\n  }\n>(\"parseOBJFromArrayBuffer\");\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { parseOBJFromArrayBuffer } from \"#src/async_computation/obj_mesh_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { getCachedDecodedUrl } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { ReadResponse } from \"#src/kvstore/index.js\";\nimport { registerSingleMeshFactory } from \"#src/single_mesh/backend.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\n/**\n * This needs to be a global function, because it identifies the instance of SimpleAsyncCache\n * to use.\n */\nasync function parse(\n  readResponse: ReadResponse,\n  progressOptions: Partial<ProgressOptions>,\n) {\n  const buffer = await readResponse.response.arrayBuffer();\n  return requestAsyncComputation(\n    parseOBJFromArrayBuffer,\n    progressOptions.signal,\n    [buffer],\n    buffer,\n  );\n}\n\nregisterSingleMeshFactory(\"obj\", {\n  description: \"OBJ\",\n  getMesh: (sharedKvStoreContext, url, options) =>\n    getCachedDecodedUrl(sharedKvStoreContext, url, parse, options),\n});\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeJpeg } from \"#src/async_computation/decode_jpeg_request.js\";\nimport { decodePng } from \"#src/async_computation/decode_png_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { TileChunkSourceParameters } from \"#src/datasource/render/base.js\";\nimport type { ChunkDecoder } from \"#src/sliceview/backend_chunk_decoders/index.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport { decodeRawChunk } from \"#src/sliceview/backend_chunk_decoders/raw.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport { vec3 } from \"#src/util/geom.js\";\nimport { fetchOk } from \"#src/util/http_request.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\nconst chunkDecoders = new Map<string, ChunkDecoder>();\nchunkDecoders.set(\n  \"jpg\",\n  async (chunk: VolumeChunk, signal: AbortSignal, response: ArrayBuffer) => {\n    const chunkDataSize = chunk.chunkDataSize!;\n    const { uint8Array: decoded } = await requestAsyncComputation(\n      decodeJpeg,\n      signal,\n      [response],\n      new Uint8Array(response),\n      undefined,\n      undefined,\n      chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n      3,\n      true,\n    );\n    await postProcessRawData(chunk, signal, decoded);\n  },\n);\nchunkDecoders.set(\n  \"png\",\n  async (chunk: VolumeChunk, signal: AbortSignal, response: ArrayBuffer) => {\n    const chunkDataSize = chunk.chunkDataSize!;\n    const { uint8Array: decoded } = await requestAsyncComputation(\n      decodePng,\n      signal,\n      [response],\n      new Uint8Array(response),\n      chunkDataSize[0],\n      chunkDataSize[1],\n      chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n      4,\n      1,\n      false,\n    );\n    await postProcessRawData(chunk, signal, decoded);\n  },\n);\nchunkDecoders.set(\n  \"png16\",\n  async (chunk: VolumeChunk, signal: AbortSignal, response: ArrayBuffer) => {\n    const chunkDataSize = chunk.chunkDataSize!;\n    const { uint8Array: decoded } = await requestAsyncComputation(\n      decodePng,\n      signal,\n      [response],\n      new Uint8Array(response),\n      chunkDataSize[0],\n      chunkDataSize[1],\n      chunkDataSize[0] * chunkDataSize[1] * chunkDataSize[2],\n      1,\n      2,\n      false,\n    );\n    await postProcessRawData(chunk, signal, decoded);\n  },\n);\nchunkDecoders.set(\"raw16\", (chunk, signal, response) => {\n  return decodeRawChunk(chunk, signal, response, Endianness.BIG);\n});\n\n@registerSharedObject()\nexport class TileChunkSource extends WithParameters(\n  VolumeChunkSource,\n  TileChunkSourceParameters,\n) {\n  chunkDecoder = chunkDecoders.get(this.parameters.encoding)!;\n\n  queryString = (() => {\n    const { parameters } = this;\n    const query_params = new URLSearchParams();\n\n    if (parameters.channel !== undefined) {\n      query_params.append(\"channel\", parameters.channel);\n    }\n\n    // Parse fallback key-value argument\n    for (const [key, value] of Object.entries(parameters.renderArgs)) {\n      query_params.append(key, value);\n    }\n\n    return query_params.toString();\n  })();\n\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    const { parameters } = this;\n    const { chunkGridPosition } = chunk;\n\n    // Calculate scale.\n    const scale = 1.0 / 2 ** parameters.level;\n\n    // Needed by JPEG decoder.\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n\n    const xTileSize = chunk.chunkDataSize[0] * 2 ** parameters.level;\n    const yTileSize = chunk.chunkDataSize[1] * 2 ** parameters.level;\n\n    // Convert grid position to global coordinates position.\n    const chunkPosition = vec3.create();\n\n    chunkPosition[0] = chunkGridPosition[0] * xTileSize;\n    chunkPosition[1] = chunkGridPosition[1] * yTileSize;\n    chunkPosition[2] = chunkGridPosition[2];\n\n    // GET\n    // /v1/owner/{owner}/project/{project}/stack/{stack}/z/{z}/box/{x},{y},{width},{height},{scale}/jpeg-image\n    let imageMethod: string;\n    if (parameters.encoding === \"raw16\") {\n      imageMethod = \"raw16-image\";\n    } else if (parameters.encoding === \"png16\") {\n      imageMethod = \"png16-image\";\n    } else if (parameters.encoding === \"png\") {\n      imageMethod = \"png-image\";\n    } else {\n      imageMethod = \"jpeg-image\";\n    }\n    const path = `/render-ws/v1/owner/${parameters.owner}/project/${parameters.project}/stack/${parameters.stack}/z/${chunkPosition[2]}/box/${chunkPosition[0]},${chunkPosition[1]},${xTileSize},${yTileSize},${scale}/${imageMethod}`;\n    const response = await fetchOk(\n      `${parameters.baseUrl}${path}?${this.queryString}`,\n      { signal: signal },\n    );\n    await this.chunkDecoder(chunk, signal, await response.arrayBuffer());\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { asyncComputation } from \"#src/async_computation/index.js\";\nimport type { TriangularMesh } from \"#src/datasource/vtk/parse.js\";\n\nexport const parseVTKFromArrayBuffer = asyncComputation<\n  (buffer: ArrayBuffer) => {\n    data: TriangularMesh;\n    size: number;\n  }\n>(\"parseVTKFromArrayBuffer\");\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { parseVTKFromArrayBuffer } from \"#src/async_computation/vtk_mesh_request.js\";\nimport { getCachedDecodedUrl } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { ReadResponse } from \"#src/kvstore/index.js\";\nimport type { SingleMesh } from \"#src/single_mesh/backend.js\";\nimport { registerSingleMeshFactory } from \"#src/single_mesh/backend.js\";\nimport { DataType } from \"#src/util/data_type.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\n/**\n * This needs to be a global function, because it identifies the instance of SimpleAsyncCache\n * to use.\n */\nasync function parse(\n  readResponse: ReadResponse,\n  progressOptions: Partial<ProgressOptions>,\n) {\n  const buffer = await readResponse.response.arrayBuffer();\n  return requestAsyncComputation(\n    parseVTKFromArrayBuffer,\n    progressOptions.signal,\n    [buffer],\n    buffer,\n  );\n}\n\nregisterSingleMeshFactory(\"vtk\", {\n  description: \"VTK\",\n  getMesh: async (sharedKvStoreContext, url, options) => {\n    const mesh = await getCachedDecodedUrl(\n      sharedKvStoreContext,\n      url,\n      parse,\n      options,\n    );\n    const result: SingleMesh = {\n      info: {\n        numTriangles: mesh.numTriangles,\n        numVertices: mesh.numVertices,\n        vertexAttributes: [],\n      },\n      indices: mesh.indices,\n      vertexPositions: mesh.vertexPositions,\n      vertexAttributes: [],\n    };\n    for (const attribute of mesh.vertexAttributes) {\n      result.info.vertexAttributes.push({\n        name: attribute.name,\n        dataType: DataType.FLOAT32,\n        numComponents: attribute.numComponents,\n      });\n      result.vertexAttributes.push(attribute.data);\n    }\n    return result;\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport type {\n  CodecArrayInfo,\n  CodecChainSpec,\n} from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { KvStoreWithPath, ReadableKvStore } from \"#src/kvstore/index.js\";\nimport type { RefCounted } from \"#src/util/disposable.js\";\n\nexport interface Codec {\n  name: string;\n  kind: CodecKind;\n}\n\nexport interface ArrayToArrayCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToArray;\n  decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded: ArrayBufferView<ArrayBuffer>,\n    signal: AbortSignal,\n  ): Promise<ArrayBufferView<ArrayBuffer>>;\n}\n\nexport interface ArrayToBytesCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToBytes;\n  decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded: Uint8Array<ArrayBuffer>,\n    signal: AbortSignal,\n  ): Promise<ArrayBufferView<ArrayBuffer>>;\n}\n\nexport type ShardingKey<BaseKey> = {\n  base: BaseKey;\n  subChunk: number[];\n};\n\nexport interface ShardingCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.arrayToBytes;\n  getShardedKvStore<BaseKey>(\n    configuration: Configuration,\n    chunkManager: ChunkManager,\n    base: ReadableKvStore<BaseKey>,\n  ): ReadableKvStore<ShardingKey<BaseKey>> & RefCounted;\n}\n\nexport interface BytesToBytesCodec<Configuration = unknown> extends Codec {\n  kind: CodecKind.bytesToBytes;\n  decode(\n    configuration: Configuration,\n    encoded: Uint8Array<ArrayBuffer>,\n    signal: AbortSignal,\n  ): Promise<Uint8Array<ArrayBuffer>>;\n}\n\nconst codecRegistry = {\n  [CodecKind.arrayToArray]: new Map<string, ArrayToArrayCodec>(),\n  [CodecKind.arrayToBytes]: new Map<string, ArrayToBytesCodec>(),\n  [CodecKind.bytesToBytes]: new Map<string, BytesToBytesCodec>(),\n  sharding: new Map<string, ShardingCodec>(),\n};\n\nexport function registerCodec<Configuration>(\n  codec:\n    | ArrayToArrayCodec<Configuration>\n    | ArrayToBytesCodec<Configuration>\n    | BytesToBytesCodec<Configuration>\n    | ShardingCodec<Configuration>,\n) {\n  if (codec.kind === CodecKind.arrayToBytes && \"getShardedKvStore\" in codec) {\n    codecRegistry.sharding.set(codec.name, codec as any);\n  } else {\n    codecRegistry[codec.kind].set(codec.name, codec as any);\n  }\n}\n\nexport async function decodeArray(\n  codecs: CodecChainSpec,\n  encoded: Uint8Array<ArrayBuffer>,\n  signal: AbortSignal,\n): Promise<ArrayBufferView<ArrayBuffer>> {\n  const bytesToBytes = codecs[CodecKind.bytesToBytes];\n  for (let i = bytesToBytes.length; i--; ) {\n    const codec = bytesToBytes[i];\n    const impl = codecRegistry[CodecKind.bytesToBytes].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    encoded = await impl.decode(codec.configuration, encoded, signal);\n  }\n\n  let decoded: ArrayBufferView<ArrayBuffer>;\n  {\n    const codec = codecs[CodecKind.arrayToBytes];\n    const impl = codecRegistry[CodecKind.arrayToBytes].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    decoded = await impl.decode(\n      codec.configuration,\n      codecs.arrayInfo[codecs.arrayInfo.length - 1],\n      encoded,\n      signal,\n    );\n  }\n\n  const arrayToArray = codecs[CodecKind.arrayToArray];\n  for (let i = arrayToArray.length; i--; ) {\n    const codec = arrayToArray[i];\n    const impl = codecRegistry[CodecKind.arrayToArray].get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    decoded = await impl.decode(\n      codec.configuration,\n      codecs.arrayInfo[i],\n      decoded,\n      signal,\n    );\n  }\n\n  return decoded;\n}\n\nexport function applySharding(\n  chunkManager: ChunkManager,\n  codecs: CodecChainSpec,\n  baseKvStore: KvStoreWithPath,\n): {\n  kvStore: ReadableKvStore<unknown>;\n  getChunkKey: (\n    chunkGridPosition: ArrayLike<number>,\n    baseKey: string,\n  ) => unknown;\n  decodeCodecs: CodecChainSpec;\n} {\n  let kvStore: ReadableKvStore<unknown> = baseKvStore.store;\n  let curCodecs = codecs;\n  while (true) {\n    const { shardingInfo } = curCodecs;\n    if (shardingInfo === undefined) break;\n    const codec = curCodecs[CodecKind.arrayToBytes];\n    const impl = codecRegistry.sharding.get(codec.name);\n    if (impl === undefined) {\n      throw new Error(`Unsupported codec: ${JSON.stringify(codec.name)}`);\n    }\n    kvStore = impl.getShardedKvStore(\n      codec.configuration,\n      chunkManager,\n      kvStore,\n    );\n    curCodecs = shardingInfo.subChunkCodecs;\n  }\n\n  const decodeCodecs = curCodecs;\n\n  const pathPrefix = baseKvStore.path;\n\n  function getChunkKey(\n    chunkGridPosition: ArrayLike<number>,\n    baseKey: string,\n  ): unknown {\n    let key: unknown = pathPrefix + baseKey;\n    const rank = chunkGridPosition.length;\n    let curCodecs = codecs;\n    while (curCodecs.shardingInfo !== undefined) {\n      const layoutInfo = codecs.layoutInfo[codecs.layoutInfo.length - 1];\n      const { physicalToLogicalDimension, readChunkShape } = layoutInfo;\n      const { subChunkShape, subChunkGridShape, subChunkCodecs } =\n        curCodecs.shardingInfo;\n      const subChunk = new Array<number>(rank);\n      for (\n        let fOrderPhysicalDim = 0;\n        fOrderPhysicalDim < rank;\n        ++fOrderPhysicalDim\n      ) {\n        const subChunkDim =\n          physicalToLogicalDimension[rank - 1 - fOrderPhysicalDim];\n        subChunk[subChunkDim] =\n          Math.floor(\n            (chunkGridPosition[fOrderPhysicalDim] *\n              readChunkShape[subChunkDim]) /\n              subChunkShape[subChunkDim],\n          ) % subChunkGridShape[subChunkDim];\n      }\n      key = { base: key, subChunk };\n      curCodecs = subChunkCodecs;\n    }\n    return key;\n  }\n\n  return { kvStore, getChunkKey, decodeCodecs };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBlosc } from \"#src/async_computation/decode_blosc_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/blosc/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\n\nregisterCodec({\n  name: \"blosc\",\n  kind: CodecKind.bytesToBytes,\n  decode(configuration: Configuration, encoded, signal: AbortSignal) {\n    configuration;\n    return requestAsyncComputation(\n      decodeBlosc,\n      signal,\n      [encoded.buffer],\n      encoded,\n    );\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/zstd/resolve.js\";\n\nregisterCodec({\n  name: \"zstd\",\n  kind: CodecKind.bytesToBytes,\n  decode(configuration: Configuration, encoded, signal: AbortSignal) {\n    configuration;\n    return requestAsyncComputation(\n      decodeZstd,\n      signal,\n      [encoded.buffer],\n      encoded,\n    );\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Configuration } from \"#src/datasource/zarr/codec/bytes/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { CodecArrayInfo } from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { DATA_TYPE_BYTES, makeDataTypeArrayView } from \"#src/util/data_type.js\";\nimport { convertEndian } from \"#src/util/endian.js\";\n\nregisterCodec({\n  name: \"bytes\",\n  kind: CodecKind.arrayToBytes,\n  async decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded,\n    signal: AbortSignal,\n  ) {\n    signal;\n    const { dataType, chunkShape } = decodedArrayInfo;\n    const numElements = chunkShape.reduce((a, b) => a * b, 1);\n    const bytesPerElement = DATA_TYPE_BYTES[dataType];\n    const expectedBytes = numElements * bytesPerElement;\n    if (encoded.byteLength !== expectedBytes) {\n      throw new Error(\n        `Raw-format chunk is ${encoded.byteLength} bytes, ` +\n          `but ${numElements} * ${bytesPerElement} = ${expectedBytes} bytes are expected.`,\n      );\n    }\n    const data = makeDataTypeArrayView(\n      dataType,\n      encoded.buffer,\n      encoded.byteOffset,\n      encoded.byteLength,\n    );\n    convertEndian(data, configuration.endian, bytesPerElement);\n    return data;\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Configuration } from \"#src/datasource/zarr/codec/crc32c/resolve.js\";\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\n\nconst checksumSize = 4;\n\nregisterCodec({\n  name: \"crc32c\",\n  kind: CodecKind.bytesToBytes,\n  async decode(configuration: Configuration, encoded, signal: AbortSignal) {\n    configuration;\n    signal;\n    if (encoded.length < checksumSize) {\n      throw new Error(\n        `Expected buffer of size at least ${checksumSize} bytes but received: ${encoded.length} bytes`,\n      );\n    }\n    // TODO(jbms): Actually verify checksum.\n    return encoded.subarray(0, encoded.length - checksumSize);\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/gzip/resolve.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport { decodeGzip } from \"#src/util/gzip.js\";\n\nfor (const [name, compressionFormat] of [\n  [\"gzip\", \"gzip\"],\n  [\"zlib\", \"deflate\"],\n] as const) {\n  registerCodec({\n    name,\n    kind: CodecKind.bytesToBytes,\n    async decode(configuration: Configuration, encoded, signal: AbortSignal) {\n      configuration;\n      return new Uint8Array(\n        await decodeGzip(encoded, compressionFormat, signal),\n      );\n    },\n  });\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  verifyObject,\n  verifyObjectProperty,\n  verifyString,\n} from \"#src/util/json.js\";\n\nexport function parseNameAndConfiguration<Name, Configuration>(\n  obj: unknown,\n  parseName: (name: string) => Name,\n  parseConfiguration: (configuration: unknown, name: Name) => Configuration,\n): { name: Name; configuration: Configuration } {\n  verifyObject(obj);\n  const name = verifyObjectProperty(obj, \"name\", (value) =>\n    parseName(verifyString(value)),\n  );\n  const configuration = verifyObjectProperty(obj, \"configuration\", (value) => {\n    if (value === undefined) {\n      value = {};\n    } else {\n      verifyObject(value);\n    }\n    return parseConfiguration(value, name);\n  });\n  return { name, configuration };\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { parseCodecChainSpec } from \"#src/datasource/zarr/codec/resolve.js\";\nimport type {\n  ArrayMetadata,\n  DimensionSeparator,\n  Metadata,\n  NodeType,\n} from \"#src/datasource/zarr/metadata/index.js\";\nimport { ChunkKeyEncoding } from \"#src/datasource/zarr/metadata/index.js\";\nimport { parseNameAndConfiguration } from \"#src/datasource/zarr/metadata/parse_util.js\";\nimport { DATA_TYPE_BYTES, DataType } from \"#src/util/data_type.js\";\nimport { Endianness } from \"#src/util/endian.js\";\nimport {\n  parseArray,\n  parseFixedLengthArray,\n  verifyConstant,\n  verifyEnumString,\n  verifyInt,\n  verifyObject,\n  verifyObjectProperty,\n  verifyOptionalFixedLengthArrayOfStringOrNull,\n  verifyOptionalObjectProperty,\n  verifyString,\n} from \"#src/util/json.js\";\nimport { parseNumpyDtype } from \"#src/util/numpy_dtype.js\";\nimport { allSiPrefixes } from \"#src/util/si_units.js\";\n\nfunction parseShape(obj: unknown): number[] {\n  return parseArray(obj, (x) => {\n    if (typeof x !== \"number\" || !Number.isInteger(x) || x < 0) {\n      throw new Error(\n        `Expected non-negative integer, but received: ${JSON.stringify(x)}`,\n      );\n    }\n    return x;\n  });\n}\n\nexport function parseChunkShape(obj: unknown, rank: number): number[] {\n  return parseFixedLengthArray(new Array<number>(rank), obj, (x) => {\n    if (typeof x !== \"number\" || !Number.isInteger(x) || x <= 0) {\n      throw new Error(\n        `Expected positive integer, but received: ${JSON.stringify(x)}`,\n      );\n    }\n    return x;\n  });\n}\n\nexport function parseDimensionSeparator(value: unknown): \"/\" | \".\" {\n  if (value !== \".\" && value !== \"/\") {\n    throw new Error(\n      `Expected \".\" or \"/\", but received: ${JSON.stringify(value)}`,\n    );\n  }\n  return value;\n}\n\nconst UNITS = new Map<string, { unit: string; scale: number }>([\n  [\"\", { unit: \"\", scale: 1 }],\n  [\"angstrom\", { unit: \"m\", scale: 1e-10 }],\n  [\"foot\", { unit: \"m\", scale: 0.3048 }],\n  [\"inch\", { unit: \"m\", scale: 0.0254 }],\n  [\"mile\", { unit: \"m\", scale: 1609.34 }],\n  // eslint-disable-next-line no-loss-of-precision\n  [\"parsec\", { unit: \"m\", scale: 3.0856775814913673e16 }],\n  [\"yard\", { unit: \"m\", scale: 0.9144 }],\n  [\"minute\", { unit: \"s\", scale: 60 }],\n  [\"hour\", { unit: \"s\", scale: 60 * 60 }],\n  [\"day\", { unit: \"s\", scale: 60 * 60 * 24 }],\n]);\n\nfor (const unit of [\"meter\", \"second\"]) {\n  for (const siPrefix of allSiPrefixes) {\n    const { longPrefix, prefix } = siPrefix;\n    if (longPrefix === undefined) continue;\n    const unitInfo = { unit: unit[0], scale: 10 ** siPrefix.exponent };\n    UNITS.set(`${longPrefix}${unit}`, unitInfo);\n    UNITS.set(`${prefix}${unit[0]}`, unitInfo);\n  }\n}\n\nexport function parseDimensionUnit(obj: unknown): {\n  scale: number;\n  unit: string;\n} {\n  if (obj === null) {\n    // Default unit\n    return { scale: 1, unit: \"\" };\n  }\n  if (typeof obj !== \"string\") {\n    throw new Error(`Expected string but received: ${JSON.stringify(obj)}`);\n  }\n  const s = obj.trim();\n  const numberPattern =\n    /^([-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)(?:[eE][-+]?\\d+)?)\\s*(.*)/;\n  const m = s.match(numberPattern);\n  let scale: number;\n  let derivedUnit: string;\n  if (m === null) {\n    scale = 1;\n    derivedUnit = s;\n  } else {\n    scale = Number(m[1]);\n    derivedUnit = m[2];\n  }\n  const unitInfo = UNITS.get(derivedUnit);\n  if (unitInfo === undefined) {\n    throw new Error(`Unsupported unit: ${JSON.stringify(derivedUnit)}`);\n  }\n  return { unit: unitInfo.unit, scale: scale * unitInfo.scale };\n}\n\nfunction parseFillValue(dataType: DataType, value: unknown): number | bigint {\n  switch (dataType) {\n    case DataType.UINT8:\n    case DataType.INT8:\n    case DataType.UINT16:\n    case DataType.INT16:\n    case DataType.UINT32:\n    case DataType.INT32:\n    case DataType.UINT64:\n      if (typeof value !== \"number\" || !Number.isInteger(value)) {\n        throw new Error(\n          `Expected integer but received: ${JSON.stringify(value)}`,\n        );\n      }\n      if (dataType === DataType.UINT64) {\n        return BigInt(value);\n      }\n      return value;\n    case DataType.FLOAT32:\n      if (typeof value === \"number\") {\n        return value;\n      }\n      if (typeof value === \"string\") {\n        if (value === \"Infinity\") {\n          return Number.POSITIVE_INFINITY;\n        }\n        if (value === \"-Infinity\") {\n          return Number.NEGATIVE_INFINITY;\n        }\n        if (value === \"NaN\") {\n          return new Float32Array(Uint32Array.of(0x7fc00000).buffer)[0];\n        }\n        if (value.match(/^0x[a-fA-F0-9]+$/)) {\n          return new Float32Array(Uint32Array.of(Number(value)).buffer)[0];\n        }\n      }\n      throw new Error(\n        `Expected number, \"Infinity\", \"-Infinity\", \"NaN\", or hex string but received: ${JSON.stringify(\n          value,\n        )}`,\n      );\n  }\n}\n\nexport function parseV3Metadata(\n  obj: unknown,\n  expectedNodeType: NodeType | undefined,\n): Metadata {\n  try {\n    verifyObject(obj);\n    verifyObjectProperty(obj, \"zarr_format\", (value) => {\n      verifyConstant(value, 3);\n    });\n    const nodeType: NodeType = verifyObjectProperty(\n      obj,\n      \"node_type\",\n      (value) => {\n        if (expectedNodeType !== undefined) {\n          verifyConstant(value, expectedNodeType);\n        }\n        if (value !== \"array\" && value !== \"group\") {\n          throw new Error(\n            `Expected \"array\" or \"group\" but received: ${JSON.stringify(\n              value,\n            )}`,\n          );\n        }\n        return value;\n      },\n    );\n    expectedNodeType = nodeType;\n\n    if (nodeType === \"group\") {\n      return {\n        zarrVersion: 3,\n        nodeType: \"group\",\n        userAttributes: verifyOptionalObjectProperty(\n          obj,\n          \"attributes\",\n          verifyObject,\n          {},\n        ),\n      };\n    }\n\n    const shape = verifyObjectProperty(obj, \"shape\", parseShape);\n    const rank = shape.length;\n\n    const dimensionNames = verifyObjectProperty(\n      obj,\n      \"dimension_names\",\n      (names) =>\n        verifyOptionalFixedLengthArrayOfStringOrNull(names ?? undefined, rank),\n    );\n\n    const dataType = verifyObjectProperty(obj, \"data_type\", (x) =>\n      verifyEnumString(x, DataType, /^[a-z0-9]+$/),\n    );\n\n    const { configuration: chunkShape } = verifyObjectProperty(\n      obj,\n      \"chunk_grid\",\n      (chunkGrid) =>\n        parseNameAndConfiguration(\n          chunkGrid,\n          (name) => verifyConstant(name, \"regular\"),\n          (configuration) =>\n            verifyObjectProperty(configuration, \"chunk_shape\", (chunks) =>\n              parseChunkShape(chunks, rank),\n            ),\n        ),\n    );\n\n    const { userAttributes, dimensionUnits } = verifyObjectProperty(\n      obj,\n      \"attributes\",\n      (x) => {\n        if (x === undefined) {\n          x = {};\n        }\n        verifyObject(x);\n        const dimensionUnits = verifyObjectProperty(\n          x,\n          \"dimension_units\",\n          (units) => verifyOptionalFixedLengthArrayOfStringOrNull(units, rank),\n        );\n        return { userAttributes: x, dimensionUnits };\n      },\n    );\n\n    const { configuration: dimensionSeparator, name: chunkKeyEncoding } =\n      verifyObjectProperty(obj, \"chunk_key_encoding\", (value) =>\n        parseNameAndConfiguration(\n          value,\n          (name) => verifyEnumString(name, ChunkKeyEncoding, /^(v2|default)$/),\n          (configuration, chunkKeyEncoding) =>\n            verifyOptionalObjectProperty(\n              configuration,\n              \"separator\",\n              parseDimensionSeparator,\n              chunkKeyEncoding === ChunkKeyEncoding.DEFAULT ? \"/\" : \".\",\n            ),\n        ),\n      );\n\n    const fillValue = verifyObjectProperty(obj, \"fill_value\", (value) =>\n      parseFillValue(dataType, value),\n    );\n\n    const codecs = verifyObjectProperty(obj, \"codecs\", (value) =>\n      parseCodecChainSpec(value, { dataType, chunkShape }),\n    );\n\n    return {\n      zarrVersion: 3,\n      nodeType,\n      rank,\n      shape,\n      chunkShape,\n      dataType,\n      fillValue,\n      dimensionNames,\n      dimensionUnits,\n      chunkKeyEncoding,\n      dimensionSeparator,\n      userAttributes,\n      codecs,\n    };\n  } catch (e) {\n    const nodeStr =\n      expectedNodeType === undefined ? \"\" : `${expectedNodeType} `;\n    throw new Error(`Error parsing zarr v3 ${nodeStr}metadata: ${e.message}`);\n  }\n}\n\nexport function parseV2Metadata(\n  obj: unknown,\n  attrs: Record<string, unknown>,\n  explicitDimensionSeparator: \".\" | \"/\" | undefined,\n): ArrayMetadata {\n  try {\n    verifyObject(obj);\n    verifyObjectProperty(obj, \"zarr_format\", (value) => {\n      verifyConstant(value, 2);\n    });\n    const shape = verifyObjectProperty(obj, \"shape\", parseShape);\n    const rank = shape.length;\n    const chunkShape = verifyObjectProperty(obj, \"chunks\", (chunks) =>\n      parseChunkShape(chunks, rank),\n    );\n    const order = verifyObjectProperty(obj, \"order\", (order) => {\n      if (order !== \"C\" && order !== \"F\") {\n        throw new Error(\n          `Expected \"C\" or \"F\", but received: ${JSON.stringify(order)}`,\n        );\n      }\n      return order;\n    });\n    const dimensionSeparator: DimensionSeparator = verifyOptionalObjectProperty(\n      obj,\n      \"dimension_separator\",\n      explicitDimensionSeparator === undefined\n        ? parseDimensionSeparator\n        : (value) => verifyConstant(value, explicitDimensionSeparator),\n      explicitDimensionSeparator ?? \".\",\n    );\n    const numpyDtype = verifyObjectProperty(obj, \"dtype\", (dtype) =>\n      parseNumpyDtype(verifyString(dtype)),\n    );\n\n    const dataType = numpyDtype.dataType;\n    const fillValue = verifyObjectProperty(obj, \"fill_value\", (value) => {\n      if (value === null) {\n        return 0;\n      }\n      return parseFillValue(dataType, value);\n    });\n\n    const codecs = [];\n    if (order === \"F\") {\n      codecs.push({\n        name: \"transpose\",\n        configuration: { order: Array.from(shape, (_, i) => rank - i - 1) },\n      });\n    }\n    codecs.push({\n      name: \"bytes\",\n      configuration: {\n        endian: numpyDtype.endianness === Endianness.LITTLE ? \"little\" : \"big\",\n      },\n    });\n    verifyObjectProperty(obj, \"compressor\", (compressor) => {\n      if (compressor === null) return;\n      verifyObject(compressor);\n      const id = verifyObjectProperty(compressor, \"id\", verifyString);\n      switch (id) {\n        case \"blosc\":\n          codecs.push({\n            name: \"blosc\",\n            configuration: {\n              cname: verifyObjectProperty(compressor, \"cname\", verifyString),\n              clevel: verifyObjectProperty(compressor, \"clevel\", verifyInt),\n              typesize: DATA_TYPE_BYTES[dataType],\n              shuffle: verifyObjectProperty(\n                compressor,\n                \"shuffle\",\n                (shuffle) => {\n                  switch (shuffle) {\n                    case -1:\n                      return DATA_TYPE_BYTES[dataType] === 1\n                        ? \"bitshuffle\"\n                        : \"shuffle\";\n                    case 0:\n                      return \"noshuffle\";\n                    case 1:\n                      return \"shuffle\";\n                    case 2:\n                      return \"bitshuffle\";\n                  }\n                  throw new Error(`Invalid value: ${JSON.stringify(shuffle)}`);\n                },\n              ),\n              blocksize: verifyOptionalObjectProperty(\n                compressor,\n                \"blocksize\",\n                verifyInt,\n                0,\n              ),\n            },\n          });\n          break;\n        case \"zlib\":\n        case \"gzip\":\n        case \"zstd\":\n          codecs.push({\n            name: id,\n            configuration: {\n              level: verifyObjectProperty(compressor, \"level\", verifyInt),\n            },\n          });\n          break;\n        default:\n          throw new Error(`Unsupported compressor: ${JSON.stringify(id)}`);\n      }\n    });\n\n    const codecChainSpec = parseCodecChainSpec(codecs, {\n      dataType,\n      chunkShape,\n    });\n\n    return {\n      zarrVersion: 2,\n      nodeType: \"array\",\n      rank,\n      shape,\n      chunkShape,\n      dataType,\n      fillValue,\n      dimensionNames: verifyObjectProperty(\n        attrs,\n        \"_ARRAY_DIMENSIONS\",\n        (names) => verifyOptionalFixedLengthArrayOfStringOrNull(names, rank),\n      ),\n      dimensionUnits: verifyObjectProperty(attrs, \"dimension_units\", (units) =>\n        verifyOptionalFixedLengthArrayOfStringOrNull(units, rank),\n      ),\n      userAttributes: attrs,\n      dimensionSeparator,\n      chunkKeyEncoding: ChunkKeyEncoding.V2,\n      codecs: codecChainSpec,\n    };\n  } catch (e) {\n    throw new Error(`Error parsing zarr v2 metadata: ${e.message}`);\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport {\n  decodeArray,\n  registerCodec,\n} from \"#src/datasource/zarr/codec/decode.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type {\n  Configuration,\n  IndexConfiguration,\n} from \"#src/datasource/zarr/codec/sharding_indexed/resolve.js\";\nimport { ShardIndexLocation } from \"#src/datasource/zarr/codec/sharding_indexed/resolve.js\";\nimport { FileByteRangeHandle } from \"#src/kvstore/byte_range/file_handle.js\";\nimport type {\n  ByteRangeRequest,\n  ReadableKvStore,\n  DriverReadOptions,\n  ReadResponse,\n  StatResponse,\n  StatOptions,\n  ByteRange,\n} from \"#src/kvstore/index.js\";\nimport { KvStoreFileHandle } from \"#src/kvstore/index.js\";\nimport type { Owned } from \"#src/util/disposable.js\";\nimport { RefCounted } from \"#src/util/disposable.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\ntype ShardIndex = BigUint64Array | undefined;\n\nconst MISSING_VALUE = BigInt(\"18446744073709551615\");\n\ntype ShardIndexCache<BaseKey> = SimpleAsyncCache<BaseKey, ShardIndex>;\n\nfunction makeIndexCache<BaseKey>(\n  chunkManager: ChunkManager,\n  base: ReadableKvStore<BaseKey>,\n  configuration: IndexConfiguration,\n): ShardIndexCache<BaseKey> {\n  return new SimpleAsyncCache(chunkManager.addRef(), {\n    get: async (key: BaseKey, progressOptions: ProgressOptions) => {\n      const { indexCodecs } = configuration;\n      const encodedSize =\n        indexCodecs.encodedSize[indexCodecs.encodedSize.length - 1];\n      let byteRange: ByteRangeRequest;\n      switch (configuration.indexLocation) {\n        case ShardIndexLocation.START:\n          byteRange = { offset: 0, length: encodedSize! };\n          break;\n        case ShardIndexLocation.END:\n          byteRange = { suffixLength: encodedSize! };\n          break;\n      }\n      const response = await base.read(key, {\n        ...progressOptions,\n        byteRange,\n      });\n      if (response === undefined) {\n        return { size: 0, data: undefined };\n      }\n      const index = await decodeArray(\n        configuration.indexCodecs,\n        new Uint8Array(await response.response.arrayBuffer()),\n        progressOptions.signal,\n      );\n      return {\n        size: index.byteLength,\n        data: new BigUint64Array(\n          index.buffer,\n          index.byteOffset,\n          index.byteLength / 8,\n        ),\n      };\n    },\n  });\n}\n\nclass ShardedKvStore<BaseKey>\n  extends RefCounted\n  implements ReadableKvStore<{ base: BaseKey; subChunk: number[] }>\n{\n  private indexCache: Owned<ShardIndexCache<BaseKey>>;\n  private indexStrides: number[];\n  constructor(\n    private configuration: Configuration,\n    chunkManager: ChunkManager,\n    private base: ReadableKvStore<BaseKey>,\n  ) {\n    super();\n    this.indexCache = this.registerDisposer(\n      makeIndexCache(chunkManager, base, configuration),\n    );\n    const { subChunkGridShape } = this.configuration;\n    const rank = subChunkGridShape.length;\n    const physicalToLogicalIndexDimension =\n      this.configuration.indexCodecs.layoutInfo[0].physicalToLogicalDimension;\n    const indexStrides = (this.indexStrides = new Array(rank + 1));\n    let stride = 1;\n    for (\n      let physicalIndexDim = rank;\n      physicalIndexDim >= 0;\n      --physicalIndexDim\n    ) {\n      const logicalIndexDim = physicalToLogicalIndexDimension[physicalIndexDim];\n      indexStrides[logicalIndexDim] = stride;\n      stride *=\n        logicalIndexDim === rank ? 2 : subChunkGridShape[logicalIndexDim];\n    }\n  }\n\n  private async findKey(\n    key: {\n      base: BaseKey;\n      subChunk: number[];\n    },\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<ByteRange | undefined> {\n    const shardIndex = await this.indexCache.get(key.base, progressOptions);\n    if (shardIndex === undefined) {\n      // Shard not present.\n      return undefined;\n    }\n    const rank = this.configuration.subChunkShape.length;\n    const { subChunk } = key;\n    const { indexStrides } = this;\n    let indexOffset = 0;\n    for (let logicalIndexDim = 0; logicalIndexDim < rank; ++logicalIndexDim) {\n      const pos = subChunk[logicalIndexDim];\n      indexOffset += pos * indexStrides[logicalIndexDim];\n    }\n    const dataOffset = shardIndex[indexOffset];\n    const dataLength = shardIndex[indexOffset + indexStrides[rank]];\n    if (dataOffset === MISSING_VALUE && dataLength === MISSING_VALUE) {\n      // Sub-chunk not present.\n      return undefined;\n    }\n    return {\n      offset: Number(dataOffset),\n      length: Number(dataLength),\n    };\n  }\n\n  async stat(\n    key: { base: BaseKey; subChunk: number[] },\n    options: StatOptions,\n  ): Promise<StatResponse | undefined> {\n    const fullByteRange = await this.findKey(key, options);\n    if (fullByteRange === undefined) return undefined;\n    return { totalSize: fullByteRange.length };\n  }\n\n  async read(\n    key: { base: BaseKey; subChunk: number[] },\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const fullByteRange = await this.findKey(key, options);\n    if (fullByteRange === undefined) return undefined;\n    return new FileByteRangeHandle(\n      new KvStoreFileHandle(this.base, key.base),\n      fullByteRange,\n    ).read(options);\n  }\n\n  getUrl(key: { base: BaseKey; subChunk: number[] }): string {\n    return `subchunk ${JSON.stringify(key.subChunk)} within shard ${this.base.getUrl(key.base)}`;\n  }\n\n  get supportsOffsetReads() {\n    return true;\n  }\n  get supportsSuffixReads() {\n    return true;\n  }\n}\n\nregisterCodec({\n  name: \"sharding_indexed\",\n  kind: CodecKind.arrayToBytes,\n  getShardedKvStore<BaseKey>(\n    configuration: Configuration,\n    chunkManager: ChunkManager,\n    base: ReadableKvStore<BaseKey>,\n  ): ReadableKvStore<{ base: BaseKey; subChunk: number[] }> & RefCounted {\n    return new ShardedKvStore(configuration, chunkManager, base);\n  },\n});\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { registerCodec } from \"#src/datasource/zarr/codec/decode.js\";\nimport type { CodecArrayInfo } from \"#src/datasource/zarr/codec/index.js\";\nimport { CodecKind } from \"#src/datasource/zarr/codec/index.js\";\nimport type { Configuration } from \"#src/datasource/zarr/codec/transpose/resolve.js\";\n\nregisterCodec({\n  name: \"transpose\",\n  kind: CodecKind.arrayToArray,\n  async decode(\n    configuration: Configuration,\n    decodedArrayInfo: CodecArrayInfo,\n    encoded,\n    signal: AbortSignal,\n  ) {\n    decodedArrayInfo;\n    signal;\n    configuration;\n    return encoded;\n  },\n});\n","/**\n * @license\n * Copyright 2020 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/datasource/zarr/codec/blosc/decode.js\";\nimport \"#src/datasource/zarr/codec/zstd/decode.js\";\nimport \"#src/datasource/zarr/codec/bytes/decode.js\";\nimport \"#src/datasource/zarr/codec/crc32c/decode.js\";\n\nimport { WithParameters } from \"#src/chunk_manager/backend.js\";\nimport { VolumeChunkSourceParameters } from \"#src/datasource/zarr/base.js\";\nimport {\n  applySharding,\n  decodeArray,\n} from \"#src/datasource/zarr/codec/decode.js\";\nimport \"#src/datasource/zarr/codec/gzip/decode.js\";\nimport \"#src/datasource/zarr/codec/sharding_indexed/decode.js\";\nimport \"#src/datasource/zarr/codec/transpose/decode.js\";\nimport { ChunkKeyEncoding } from \"#src/datasource/zarr/metadata/index.js\";\nimport { WithSharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { postProcessRawData } from \"#src/sliceview/backend_chunk_decoders/postprocess.js\";\nimport type { VolumeChunk } from \"#src/sliceview/volume/backend.js\";\nimport { VolumeChunkSource } from \"#src/sliceview/volume/backend.js\";\nimport { registerSharedObject } from \"#src/worker_rpc.js\";\n\n@registerSharedObject()\nexport class ZarrVolumeChunkSource extends WithParameters(\n  WithSharedKvStoreContextCounterpart(VolumeChunkSource),\n  VolumeChunkSourceParameters,\n) {\n  private chunkKvStore = applySharding(\n    this.chunkManager,\n    this.parameters.metadata.codecs,\n    this.sharedKvStoreContext.kvStoreContext.getKvStore(this.parameters.url),\n  );\n\n  async download(chunk: VolumeChunk, signal: AbortSignal) {\n    chunk.chunkDataSize = this.spec.chunkDataSize;\n    const { parameters } = this;\n    const { chunkGridPosition } = chunk;\n    const { metadata } = parameters;\n    let baseKey = \"\";\n    const rank = this.spec.rank;\n    const { physicalToLogicalDimension } = metadata.codecs.layoutInfo[0];\n    let sep: string;\n    if (metadata.chunkKeyEncoding === ChunkKeyEncoding.DEFAULT) {\n      baseKey += \"c\";\n      sep = metadata.dimensionSeparator;\n    } else {\n      sep = \"\";\n      if (rank === 0) {\n        baseKey += \"0\";\n      }\n    }\n    const keyCoords = new Array<number>(rank);\n    const { readChunkShape } = metadata.codecs.layoutInfo[0];\n    const { chunkShape } = metadata;\n    for (\n      let fOrderPhysicalDim = 0;\n      fOrderPhysicalDim < rank;\n      ++fOrderPhysicalDim\n    ) {\n      const decodedDim =\n        physicalToLogicalDimension[rank - 1 - fOrderPhysicalDim];\n      keyCoords[decodedDim] = Math.floor(\n        (chunkGridPosition[fOrderPhysicalDim] * readChunkShape[decodedDim]) /\n          chunkShape[decodedDim],\n      );\n    }\n    for (let i = 0; i < rank; ++i) {\n      baseKey += `${sep}${keyCoords[i]}`;\n      sep = metadata.dimensionSeparator;\n    }\n    const { chunkKvStore } = this;\n    const response = await chunkKvStore.kvStore.read(\n      chunkKvStore.getChunkKey(chunkGridPosition, baseKey),\n      { signal },\n    );\n    if (response !== undefined) {\n      const decoded = await decodeArray(\n        chunkKvStore.decodeCodecs,\n        new Uint8Array(await response.response.arrayBuffer()),\n        signal,\n      );\n      await postProcessRawData(chunk, signal, decoded);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { CompletionResult } from \"#src/kvstore/context.js\";\nimport type {\n  ByteRange,\n  DriverListOptions,\n  DriverReadOptions,\n  ListResponse,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport type { SharedKvStoreContextBase } from \"#src/kvstore/register.js\";\nimport {\n  LIST_RPC_ID,\n  READ_RPC_ID,\n  STAT_RPC_ID,\n  COMPLETE_URL_RPC_ID,\n} from \"#src/kvstore/shared_common.js\";\nimport {\n  finalPipelineUrlComponent,\n  parsePipelineUrlComponent,\n} from \"#src/kvstore/url.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport type { RPC } from \"#src/worker_rpc.js\";\nimport { registerPromiseRPC } from \"#src/worker_rpc.js\";\n\nexport function proxyStat(\n  sharedKvStoreContext: SharedKvStoreContextBase,\n  url: string,\n  options: StatOptions,\n): Promise<StatResponse | undefined> {\n  return sharedKvStoreContext.rpc!.promiseInvoke<StatResponse | undefined>(\n    STAT_RPC_ID,\n    { sharedKvStoreContext: sharedKvStoreContext.rpcId, url },\n    { signal: options.signal, progressListener: options.progressListener },\n  );\n}\n\nregisterPromiseRPC(\n  STAT_RPC_ID,\n  async function (\n    this: RPC,\n    options: { sharedKvStoreContext: number; url: string },\n    progressOptions,\n  ) {\n    const sharedKvStoreContext: SharedKvStoreContextBase = this.get(\n      options.sharedKvStoreContext,\n    );\n    return {\n      value: await sharedKvStoreContext.kvStoreContext.stat(\n        options.url,\n        progressOptions,\n      ),\n    };\n  },\n);\n\nexport async function proxyRead(\n  sharedKvStoreContext: SharedKvStoreContextBase,\n  url: string,\n  options: DriverReadOptions,\n): Promise<ReadResponse | undefined> {\n  const response = await sharedKvStoreContext.rpc!.promiseInvoke<\n    | { data: ArrayBuffer; offset: number; totalSize: number | undefined }\n    | undefined\n  >(\n    READ_RPC_ID,\n    {\n      sharedKvStoreContext: sharedKvStoreContext.rpcId,\n      url,\n      byteRange: options.byteRange,\n      throwIfMissing: options.throwIfMissing,\n    },\n    { signal: options.signal, progressListener: options.progressListener },\n  );\n  if (response === undefined) return undefined;\n  return {\n    response: new Response(response.data),\n    offset: response.offset,\n    length: response.data.byteLength,\n    totalSize: response.totalSize,\n  };\n}\n\nregisterPromiseRPC(\n  READ_RPC_ID,\n  async function (\n    this: RPC,\n    options: {\n      sharedKvStoreContext: number;\n      url: string;\n      byteRange?: ByteRange;\n      throwIfMissing?: boolean;\n    },\n    progressOptions,\n  ) {\n    const sharedKvStoreContext: SharedKvStoreContextBase = this.get(\n      options.sharedKvStoreContext,\n    );\n    const readResponse = await sharedKvStoreContext.kvStoreContext.read(\n      options.url,\n      {\n        ...progressOptions,\n        byteRange: options.byteRange,\n        throwIfMissing: options.throwIfMissing,\n      },\n    );\n    if (readResponse === undefined) {\n      return { value: undefined };\n    }\n    const arrayBuffer = await readResponse.response.arrayBuffer();\n    return {\n      value: {\n        data: arrayBuffer,\n        offset: readResponse.offset,\n        totalSize: readResponse.totalSize,\n      },\n      transfers: [arrayBuffer],\n    };\n  },\n);\n\nexport function proxyList(\n  sharedKvStoreContext: SharedKvStoreContextBase,\n  url: string,\n  options: DriverListOptions,\n): Promise<ListResponse> {\n  return sharedKvStoreContext.rpc!.promiseInvoke<ListResponse>(\n    LIST_RPC_ID,\n    {\n      sharedKvStoreContext: sharedKvStoreContext.rpcId,\n      url,\n    },\n    { signal: options.signal, progressListener: options.progressListener },\n  );\n}\n\nregisterPromiseRPC(\n  LIST_RPC_ID,\n  async function (\n    this: RPC,\n    options: { sharedKvStoreContext: number; url: string },\n    progressOptions,\n  ) {\n    const sharedKvStoreContext: SharedKvStoreContextBase = this.get(\n      options.sharedKvStoreContext,\n    );\n    const { store, path } = sharedKvStoreContext.kvStoreContext.getKvStore(\n      options.url,\n    );\n    return {\n      value: await store.list!(path, progressOptions),\n    };\n  },\n);\n\nexport function proxyCompleteUrl(\n  sharedKvStoreContext: SharedKvStoreContextBase,\n  url: string,\n  options: Partial<ProgressOptions>,\n): Promise<CompletionResult> {\n  return sharedKvStoreContext.rpc!.promiseInvoke<CompletionResult>(\n    COMPLETE_URL_RPC_ID,\n    {\n      sharedKvStoreContext: sharedKvStoreContext.rpcId,\n      url,\n    },\n    { signal: options.signal, progressListener: options.progressListener },\n  );\n}\n\nregisterPromiseRPC(\n  COMPLETE_URL_RPC_ID,\n  async function (\n    this: RPC,\n    options: { sharedKvStoreContext: number; url: string },\n    progressOptions,\n  ) {\n    const sharedKvStoreContext: SharedKvStoreContextBase = this.get(\n      options.sharedKvStoreContext,\n    );\n    const { kvStoreContext } = sharedKvStoreContext;\n    const { url } = options;\n    const finalComponent = finalPipelineUrlComponent(url);\n    let result: CompletionResult | undefined;\n    if (finalComponent === url) {\n      // Base kvstore\n      const parsedUrl = parsePipelineUrlComponent(finalComponent);\n      const provider = kvStoreContext.getBaseKvStoreProvider(parsedUrl);\n      if (provider.completeUrl !== undefined) {\n        result = await provider.completeUrl({\n          url: parsedUrl,\n          ...progressOptions,\n        });\n      }\n    } else {\n      const adapterUrl = parsePipelineUrlComponent(finalComponent);\n      const provider = kvStoreContext.getKvStoreAdapterProvider(adapterUrl);\n      const baseUrl = url.slice(0, url.length - finalComponent.length - 1);\n      const base = kvStoreContext.getKvStore(baseUrl);\n      if (provider.completeUrl !== undefined) {\n        result = await provider.completeUrl({\n          url: adapterUrl,\n          base,\n          ...progressOptions,\n        });\n      }\n    }\n    return {\n      value: result,\n    };\n  },\n);\n\nexport abstract class ProxyReadableKvStore<Key> {\n  constructor(public sharedKvStoreContext: SharedKvStoreContextBase) {}\n\n  abstract getUrl(key: Key): string;\n\n  stat(key: Key, options: StatOptions): Promise<StatResponse | undefined> {\n    return proxyStat(this.sharedKvStoreContext, this.getUrl(key), options);\n  }\n  read(\n    key: Key,\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    return proxyRead(this.sharedKvStoreContext, this.getUrl(key), options);\n  }\n}\n\nexport abstract class ProxyKvStore extends ProxyReadableKvStore<string> {\n  list(prefix: string, options: DriverListOptions): Promise<ListResponse> {\n    return proxyList(this.sharedKvStoreContext, this.getUrl(prefix), options);\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { ReadableHttpKvStore } from \"#src/kvstore/http/common.js\";\nimport type { DriverListOptions, ListResponse } from \"#src/kvstore/index.js\";\nimport { proxyList } from \"#src/kvstore/proxy.js\";\n\nexport class HttpKvStore extends ReadableHttpKvStore<SharedKvStoreContextCounterpart> {\n  list(prefix: string, options: DriverListOptions): Promise<ListResponse> {\n    return proxyList(this.sharedKvStoreContext, this.getUrl(prefix), options);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport { HttpKvStore } from \"#src/kvstore/http/backend.js\";\nimport { registerProviders } from \"#src/kvstore/http/common.js\";\n\nregisterProviders(backendOnlyKvStoreProviderRegistry, HttpKvStore);\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Derived from: https://github.com/LinusU/base32-encode/\n\n/**\n * @license\n * MIT License\n *\n * Copyright (c) 2016-2021 Linus Unnebäck\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nconst ALPHABET = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\n\nexport function crockfordBase32Encode(input: Uint8Array) {\n  const numBytes = input.length;\n  let value = 0;\n  let output = \"\";\n  let bits = 0;\n  for (let i = 0; i < numBytes; ++i) {\n    value = (value << 8) | input[i];\n    for (bits += 8; bits >= 5; bits -= 5) {\n      output += ALPHABET[(value >>> (bits - 5)) & 31];\n    }\n  }\n\n  if (bits > 0) {\n    output += ALPHABET[(value << (5 - bits)) & 31];\n  }\n  return output;\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Unpackr } from \"msgpackr\";\nimport * as v from \"valibot\";\nimport { decodeZstd } from \"#src/async_computation/decode_zstd_request.js\";\nimport { requestAsyncComputation } from \"#src/async_computation/request.js\";\nimport { crockfordBase32Encode } from \"#src/kvstore/icechunk/crockford_base32.js\";\n\nexport const LATEST_KNOWN_SPEC_VERSION = 1;\n\n// \"ICE🧊CHUNK\" as UTF-8\nconst MAGIC = Uint8Array.of(\n  0x49,\n  0x43,\n  0x45,\n  0xf0,\n  0x9f,\n  0xa7,\n  0x8a,\n  0x43,\n  0x48,\n  0x55,\n  0x4e,\n  0x4b,\n);\n\nconst IMPLEMENTATION_NAME_LENGTH = 24;\n\nconst ENVELOPE_HEADER_SIZE =\n  MAGIC.length + // magic\n  IMPLEMENTATION_NAME_LENGTH + // implementation name\n  1 + // spec_version\n  1 + // file type\n  1; // compression\n\nexport enum CompressionMethod {\n  UNCOMPRESSED = 0,\n  ZSTD = 1,\n}\n\nexport async function decodeEnvelope(\n  buffer: ArrayBuffer,\n  maxVersion: number,\n  fileType: number,\n  signal: AbortSignal,\n): Promise<{ content: Uint8Array; specVersion: number }> {\n  if (buffer.byteLength < ENVELOPE_HEADER_SIZE) {\n    throw new Error(\n      `Expected icechunk header of ${ENVELOPE_HEADER_SIZE} bytes, but received: ${buffer.byteLength} bytes`,\n    );\n  }\n  const dv = new DataView(buffer);\n  let offset = 0;\n  for (let i = 0, n = MAGIC.length; i < n; ++i) {\n    if (dv.getUint8(i) !== MAGIC[i]) {\n      throw new Error(\n        `Expected magic bytes of ${MAGIC.join()} but received: ${new Uint8Array(buffer, 0, n).join()}`,\n      );\n    }\n  }\n  offset += MAGIC.length;\n  offset += IMPLEMENTATION_NAME_LENGTH;\n  const specVersion = dv.getUint8(offset++);\n  if (specVersion > maxVersion) {\n    throw new Error(\n      `Expected version <= ${maxVersion} but received: ${specVersion}`,\n    );\n  }\n  const storedFileType = dv.getUint8(offset++);\n  if (storedFileType !== fileType) {\n    throw new Error(\n      `Expected file type of ${fileType}, but received: ${storedFileType}`,\n    );\n  }\n  const compressionMethod = dv.getUint8(offset++);\n  let content = new Uint8Array(buffer, offset);\n  switch (compressionMethod) {\n    case CompressionMethod.UNCOMPRESSED:\n      break;\n    case CompressionMethod.ZSTD:\n      content = await requestAsyncComputation(\n        decodeZstd,\n        signal,\n        [buffer],\n        content,\n      );\n      content = new Uint8Array(\n        content.buffer,\n        content.byteOffset,\n        content.byteLength,\n      );\n      break;\n    default:\n      throw new Error(`Unknown compression method: ${compressionMethod}`);\n  }\n\n  return { content, specVersion };\n}\n\nexport interface DecodedIcechunkMessage {\n  content: unknown;\n  specVersion: number;\n  estimatedSize: number;\n}\n\nexport async function decodeMsgpack(\n  buffer: ArrayBuffer,\n  maxVersion: number,\n  fileType: number,\n  signal: AbortSignal,\n): Promise<DecodedIcechunkMessage> {\n  const { content, specVersion } = await decodeEnvelope(\n    buffer,\n    maxVersion,\n    fileType,\n    signal,\n  );\n  return {\n    content: new Unpackr({\n      mapsAsObjects: false,\n      int64AsType: \"bigint\",\n    }).unpack(content),\n    specVersion,\n    estimatedSize: buffer.byteLength * 3,\n  };\n}\n\nconst DataId = v.pipe(\n  v.tuple([v.instance(Uint8Array)]),\n  v.transform((obj) => obj[0]),\n);\n\nexport const DataId12 = v.pipe(\n  DataId,\n  v.length(12),\n  v.transform<Uint8Array<ArrayBuffer>, string>(crockfordBase32Encode),\n);\nexport const DataId8 = v.pipe(\n  DataId,\n  v.length(8),\n  v.transform<Uint8Array<ArrayBuffer>, string>(crockfordBase32Encode),\n);\n\nconst MIN_SAFE_INTEGER_BIGINT = BigInt(Number.MIN_SAFE_INTEGER);\nconst MAX_SAFE_INTEGER_BIGINT = BigInt(Number.MAX_SAFE_INTEGER);\n\nconst bigIntToSafeNumber = v.pipe(\n  v.bigint(),\n  v.check(\n    (x) => x >= MIN_SAFE_INTEGER_BIGINT && x <= MAX_SAFE_INTEGER_BIGINT,\n    `Number outside supported range: [${Number.MIN_SAFE_INTEGER}, ${Number.MAX_SAFE_INTEGER}]`,\n  ),\n  v.transform(Number),\n);\n\nexport const Integer = v.union([\n  bigIntToSafeNumber,\n  v.pipe(v.number(), v.integer()),\n]);\n\nexport function tupleToObject<TEntries extends v.ObjectEntries>(\n  entries: TEntries,\n) {\n  const keys = Object.keys(entries);\n  return v.pipe(\n    v.array(v.any()),\n    v.length(keys.length),\n    v.transform((x: unknown[]) =>\n      Object.fromEntries(keys.map((key, i) => [key, x[i]])),\n    ),\n    v.strictObject(entries),\n  );\n}\n\nexport const ManifestId = DataId12;\nexport type ManifestId = v.InferOutput<typeof ManifestId>;\nexport const ChunkId = DataId12;\nexport type ChunkId = v.InferOutput<typeof ChunkId>;\nexport const NodeId = DataId8;\nexport type NodeId = v.InferOutput<typeof NodeId>;\n\nexport function parseDecodedMsgpack<\n  TOutput,\n  TIssue extends v.BaseIssue<unknown>,\n>(\n  schema: v.BaseSchema<unknown, TOutput, TIssue>,\n  name: string,\n  decoded: DecodedIcechunkMessage,\n): TOutput & { estimatedSize: number } {\n  try {\n    return {\n      ...v.parse(schema, decoded.content),\n      estimatedSize: decoded.estimatedSize,\n    };\n  } catch (e) {\n    if (v.isValiError(e)) {\n      throw new Error(\n        `Error parsing icechunk ${name}: ${JSON.stringify(v.flatten(e.issues))}`,\n      );\n    }\n    throw e;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as v from \"valibot\";\nimport {\n  ChunkId,\n  decodeMsgpack,\n  Integer,\n  LATEST_KNOWN_SPEC_VERSION,\n  ManifestId,\n  NodeId,\n  parseDecodedMsgpack,\n  tupleToObject,\n} from \"#src/kvstore/icechunk/decode_utils.js\";\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\n\nconst MANIFEST_FILE_TYPE = 2;\n\nconst InlineChunkPayload = v.strictObject({\n  Inline: v.instance(Uint8Array),\n});\n\nconst Chunksum = v.any();\n\nconst VirtualChunkLocation = v.string();\n\nconst VirtualChunkRef = tupleToObject({\n  location: VirtualChunkLocation,\n  offset: Integer,\n  length: Integer,\n  chunksum: Chunksum,\n});\n\nconst VirtualChunkRefPayload = v.strictObject({\n  Virtual: VirtualChunkRef,\n});\n\nconst ChunkRef = tupleToObject({\n  id: ChunkId,\n  offset: Integer,\n  length: Integer,\n});\n\nconst ChunkRefPayload = v.strictObject({\n  Ref: ChunkRef,\n});\n\nconst ChunkPayload = v.pipe(\n  v.map(v.string(), v.any()),\n  v.transform<Map<string, any>, Record<string, any>>(Object.fromEntries),\n  v.union([InlineChunkPayload, VirtualChunkRefPayload, ChunkRefPayload]),\n);\n\nexport type ChunkPayload = v.InferOutput<typeof ChunkPayload>;\n\nconst Manifest = tupleToObject({\n  id: ManifestId,\n  chunks: v.map(\n    NodeId,\n    v.map(\n      v.pipe(\n        v.array(Integer),\n        v.transform((chunk) => chunk.join()),\n      ),\n      ChunkPayload,\n    ),\n  ),\n});\n\nexport type Manifest = v.InferOutput<typeof Manifest> & {\n  estimatedSize: number;\n};\n\nexport async function decodeManifest(\n  buffer: ArrayBuffer,\n  signal: AbortSignal,\n): Promise<Manifest> {\n  const decoded = await decodeMsgpack(\n    buffer,\n    LATEST_KNOWN_SPEC_VERSION,\n    MANIFEST_FILE_TYPE,\n    signal,\n  );\n  return parseDecodedMsgpack(Manifest, \"chunk manifest\", decoded);\n}\n\nexport function getManifestUrl(baseUrl: string, id: ManifestId): string {\n  return pipelineUrlJoin(baseUrl, `manifests/${id}`);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  verifyObject,\n  verifyObjectProperty,\n  verifyString,\n} from \"#src/util/json.js\";\n\nexport function decodeRef(obj: unknown): string {\n  verifyObject(obj);\n  if (Object.keys(obj as object).length !== 1) {\n    throw new Error(\n      `Expected object with only a \"snapshot\" property, but received: ${JSON.stringify(obj)}`,\n    );\n  }\n  const id = verifyObjectProperty(obj, \"snapshot\", verifyString);\n  if (!isSnapshotId(id)) {\n    throw new Error(\n      `Expected icechunk snapshot id but received: ${JSON.stringify(id)}`,\n    );\n  }\n  return id;\n}\n\nexport function isSnapshotId(id: string) {\n  return id.match(/^[0-9ABCDEFGHJKMNPQRSTVWXYZ]{20}$/) !== null;\n}\n\n// Checks if a given basename is a valid branch ref file.\nexport function isBranchRef(name: string): boolean {\n  // This is not strictly precise because this allows for any 100-bit value,\n  // while icechunk only allows for 96-bits.\n  return name.match(/^[0-9ABCDEFGHJKMNPQRSTVWXYZ]{8}\\.json$/) !== null;\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as v from \"valibot\";\nimport {\n  DataId12,\n  decodeMsgpack,\n  Integer,\n  LATEST_KNOWN_SPEC_VERSION,\n  ManifestId,\n  NodeId,\n  parseDecodedMsgpack,\n  tupleToObject,\n} from \"#src/kvstore/icechunk/decode_utils.js\";\n\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\nimport { binarySearch } from \"#src/util/array.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\n\nconst SNAPSHOT_FILE_TYPE = 1;\n// const ATTRIBUTES_FILE_TYPE = 3;\n\nconst SnapshotId = DataId12;\nexport type SnapshotId = v.InferOutput<typeof SnapshotId>;\nconst AttributesId = DataId12;\n\nconst ManifestFileInfo = tupleToObject({\n  id: ManifestId,\n  sizeBytes: Integer,\n  numRows: Integer,\n});\n\nconst AttributeFileInfo = tupleToObject({\n  id: AttributesId,\n});\n\n// const UserAttributesRef = tupleToObject({\n//   objectId: AttributesId,\n//   location: Integer,\n// });\n\nconst UserAttributesSnapshot = v.pipe(\n  v.map(v.string(), v.any()),\n  v.transform<Map<string, any>, Record<string, any>>(Object.fromEntries),\n  v.union([\n    v.strictObject({\n      Inline: v.any(),\n    }),\n  ]),\n  // v.map(v.picklist([\"Ref\"]), UserAttributesRef),\n);\n\nconst ChunkKeyEncoding = v.picklist([\"Slash\", \"Dot\"]);\n\nconst Configuration = v.map(v.string(), v.any());\n\nconst Codec = tupleToObject({\n  name: v.string(),\n  configuration: Configuration,\n});\n\nconst FillValue = v.pipe(\n  v.map(v.string(), v.any()),\n  v.transform((obj) => {\n    const values = Array.from(obj.values());\n    if (values.length !== 1) {\n      throw new Error(\n        `Expected a single key, but received: ${JSON.stringify(Array.from(obj.keys()))}`,\n      );\n    }\n    return values[0];\n  }),\n);\n\nconst StorageTransformer = tupleToObject({\n  name: v.string(),\n  configuration: Configuration,\n});\n\nconst DimensionNames = v.array(v.nullable(v.string()));\n\nconst ZarrArrayMetadata = tupleToObject({\n  shape: v.array(Integer),\n  dataType: v.string(),\n  chunkShape: v.array(Integer),\n  chunkKeyEncoding: ChunkKeyEncoding,\n  fillValue: FillValue,\n  codecs: v.array(Codec),\n  storageTransformers: v.array(StorageTransformer),\n  dimensionNames: v.nullable(DimensionNames),\n});\n\nexport type ZarrArrayMetadata = v.InferOutput<typeof ZarrArrayMetadata>;\n\nconst ChunkIndices = v.array(Integer);\n\nconst ManifestExtents = v.strictTuple([ChunkIndices, ChunkIndices]);\nexport type ManifestExtents = v.InferOutput<typeof ManifestExtents>;\nconst ManifestRef = tupleToObject({\n  objectId: ManifestId,\n  extents: ManifestExtents,\n});\nexport type ManifestRef = v.InferOutput<typeof ManifestRef>;\n\nconst NodeDataGroup = v.picklist([\"Group\"]);\nconst NodeDataArray = v.strictObject({\n  Array: tupleToObject({\n    metadata: ZarrArrayMetadata,\n    manifests: v.array(ManifestRef),\n  }),\n});\nexport type NodeDataArray = v.InferOutput<typeof NodeDataArray>;\n\nconst NodeData = v.union([\n  NodeDataGroup,\n  v.pipe(\n    v.map(v.string(), v.any()),\n    v.transform<Map<string, any>, Record<string, any>>(Object.fromEntries),\n    NodeDataArray,\n  ),\n]);\n\nconst NodeSnapshot = tupleToObject({\n  id: NodeId,\n  path: v.pipe(\n    v.string(),\n    v.transform((s) => (s === \"/\" ? \"\" : s.slice(1) + \"/\")),\n  ),\n  userAttributes: UserAttributesSnapshot,\n  nodeData: NodeData,\n});\n\nexport type NodeSnapshot = v.InferOutput<typeof NodeSnapshot>;\n\nconst Nodes = v.pipe(\n  v.map(v.string(), NodeSnapshot),\n  v.transform((obj) =>\n    Array.from(obj.values()).sort((a, b) =>\n      defaultStringCompare(a.path, b.path),\n    ),\n  ),\n);\n\nconst Snapshot = tupleToObject({\n  id: SnapshotId,\n  parentId: v.nullable(SnapshotId),\n  flushedAt: v.string(),\n  message: v.string(),\n  metadata: v.record(v.string(), v.any()),\n  manifestFiles: v.pipe(\n    v.array(ManifestFileInfo),\n    v.transform((obj) => {\n      const map = new Map();\n      for (const entry of obj) {\n        map.set(entry.id, entry);\n      }\n      return map;\n    }),\n  ),\n  attributeFiles: v.array(AttributeFileInfo),\n  nodes: Nodes,\n});\n\nexport type Snapshot = v.InferOutput<typeof Snapshot> & {\n  estimatedSize: number;\n};\n\nexport async function decodeSnapshot(\n  buffer: ArrayBuffer,\n  signal: AbortSignal,\n): Promise<Snapshot> {\n  const decoded = await decodeMsgpack(\n    buffer,\n    LATEST_KNOWN_SPEC_VERSION,\n    SNAPSHOT_FILE_TYPE,\n    signal,\n  );\n  return parseDecodedMsgpack(Snapshot, \"snapshot\", decoded);\n}\n\nexport function encodeZarrJson(node: NodeSnapshot) {\n  const { userAttributes, nodeData } = node;\n  let attributes: Map<string, any>;\n  if (userAttributes === null) {\n    attributes = new Map();\n  } else {\n    attributes = userAttributes.Inline;\n  }\n\n  const obj =\n    nodeData !== \"Group\"\n      ? encodeArrayZarrJson(nodeData.Array.metadata, attributes)\n      : { zarr_format: 3, node_type: \"group\", attributes };\n\n  return JSON.stringify(obj, (_key, value) => {\n    if (value instanceof Map) {\n      return Object.fromEntries(value);\n    }\n    return value;\n  });\n}\n\nfunction encodeArrayZarrJson(\n  metadata: ZarrArrayMetadata,\n  attributes: Record<string, any>,\n) {\n  const {\n    shape,\n    chunkShape,\n    chunkKeyEncoding,\n    dataType,\n    fillValue,\n    codecs,\n    storageTransformers,\n    dimensionNames,\n  } = metadata;\n  return {\n    zarr_format: 3,\n    node_type: \"array\",\n    shape,\n    data_type: dataType,\n    chunk_grid: { name: \"regular\", configuration: { chunk_shape: chunkShape } },\n    chunk_key_encoding: {\n      name: \"default\",\n      configuration: { separator: chunkKeyEncoding === \"Dot\" ? \".\" : \"/\" },\n    },\n    fill_value: fillValue,\n    codecs,\n    storage_transformers: storageTransformers,\n    dimension_names: dimensionNames ?? undefined,\n    attributes,\n  };\n}\n\nexport function findNode(snapshot: Snapshot, path: string) {\n  const { nodes } = snapshot;\n  const index = binarySearch(nodes, path, (a, b) =>\n    defaultStringCompare(a, b.path),\n  );\n  if (index < 0) {\n    throw new Error(`Node not found: ${JSON.stringify(path)}`);\n  }\n  return nodes[index];\n}\n\nexport function getSnapshotUrl(baseUrl: string, id: SnapshotId): string {\n  return pipelineUrlJoin(baseUrl, `snapshots/${id}`);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { ManifestId } from \"#src/kvstore/icechunk/decode_utils.js\";\nimport {\n  decodeManifest,\n  getManifestUrl,\n} from \"#src/kvstore/icechunk/manifest.js\";\nimport { decodeRef, isBranchRef } from \"#src/kvstore/icechunk/ref.js\";\nimport type { SnapshotId } from \"#src/kvstore/icechunk/snapshot.js\";\nimport {\n  decodeSnapshot,\n  getSnapshotUrl,\n} from \"#src/kvstore/icechunk/snapshot.js\";\nimport type { RefSpec } from \"#src/kvstore/icechunk/url.js\";\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\nimport {\n  ProgressSpan,\n  type ProgressOptions,\n} from \"#src/util/progress_listener.js\";\n\nfunction makeMetadataCache<T>(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  description: string,\n  decode: (\n    response: Response,\n    signal: AbortSignal,\n  ) => Promise<{ data: T; size: number }>,\n) {\n  const cache = new SimpleAsyncCache<string, T>(\n    sharedKvStoreContext.chunkManager.addRef(),\n    {\n      get: async (url: string, progressOptions: ProgressOptions) => {\n        const readResponse = await sharedKvStoreContext.kvStoreContext.read(\n          url,\n          {\n            ...progressOptions,\n            throwIfMissing: true,\n          },\n        );\n        try {\n          return await decode(readResponse.response, progressOptions.signal);\n        } catch (e) {\n          throw new Error(`Error reading icechunk ${description} from ${url}`, {\n            cause: e,\n          });\n        }\n      },\n    },\n  );\n  cache.registerDisposer(sharedKvStoreContext.addRef());\n  return cache;\n}\n\nexport function getSnapshot(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  id: SnapshotId,\n  options: Partial<ProgressOptions>,\n) {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"icechunk:snapshot\",\n    () =>\n      makeMetadataCache(\n        sharedKvStoreContext,\n        \"snapshot\",\n        async (response, signal) => {\n          const value = await decodeSnapshot(\n            await response.arrayBuffer(),\n            signal,\n          );\n          return { data: value, size: value.estimatedSize };\n        },\n      ),\n  );\n  return cache.get(getSnapshotUrl(baseUrl, id), options);\n}\n\nexport function getManifest(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  id: ManifestId,\n  options: Partial<ProgressOptions>,\n) {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"icechunk:manifest\",\n    () =>\n      makeMetadataCache(\n        sharedKvStoreContext,\n        \"manifest\",\n        async (response, signal) => {\n          const value = await decodeManifest(\n            await response.arrayBuffer(),\n            signal,\n          );\n          return { data: value, size: value.estimatedSize };\n        },\n      ),\n  );\n  return cache.get(getManifestUrl(baseUrl, id), options);\n}\n\nexport function getRef(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"icechunk:ref\",\n    () =>\n      makeMetadataCache(sharedKvStoreContext, \"ref\", async (response) => ({\n        data: decodeRef(await response.json()),\n        size: 0,\n      })),\n  );\n  return cache.get(url, options);\n}\n\nexport function getBranch(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"icechunk:branch\",\n    () => {\n      const cache = new SimpleAsyncCache<string, string>(\n        sharedKvStoreContext.chunkManager.addRef(),\n        {\n          get: async (url: string, progressOptions: ProgressOptions) => {\n            using _span = new ProgressSpan(progressOptions.progressListener, {\n              message: `Resolving icechunk branch at ${url}`,\n            });\n            try {\n              const listResponse =\n                await sharedKvStoreContext.kvStoreContext.list(url, {\n                  ...progressOptions,\n                  responseKeys: \"suffix\",\n                });\n              const headKey = listResponse.entries.find((entry) =>\n                isBranchRef(entry.key),\n              );\n              if (headKey === undefined) {\n                throw new Error(`Failed to find any refs`);\n              }\n              const snapshotId = await getRef(\n                sharedKvStoreContext,\n                pipelineUrlJoin(url, headKey.key),\n                progressOptions,\n              );\n              return { data: snapshotId, size: 0 };\n            } catch (e) {\n              throw new Error(`Error resolving icechunk branch at ${url}`, {\n                cause: e,\n              });\n            }\n          },\n        },\n      );\n      cache.registerDisposer(sharedKvStoreContext.addRef());\n      return cache;\n    },\n  );\n  return cache.get(url, options);\n}\n\nexport function getTag(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n) {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"icechunk:tag\",\n    () => {\n      const cache = new SimpleAsyncCache<string, string>(\n        sharedKvStoreContext.chunkManager.addRef(),\n        {\n          get: async (url: string, progressOptions: ProgressOptions) => {\n            using _span = new ProgressSpan(progressOptions.progressListener, {\n              message: `Resolving icechunk tag at ${url}`,\n            });\n            try {\n              const [tagResponse, deletedResponse] = await Promise.all([\n                getRef(\n                  sharedKvStoreContext,\n                  pipelineUrlJoin(url, \"ref.json\"),\n                  progressOptions,\n                ),\n                sharedKvStoreContext.kvStoreContext.stat(\n                  pipelineUrlJoin(url, \"ref.json.deleted\"),\n                  progressOptions,\n                ),\n              ]);\n              if (deletedResponse !== undefined) {\n                throw new Error(`Tag is marked as deleted`);\n              }\n              return { data: tagResponse, size: 0 };\n            } catch (e) {\n              throw new Error(`Error resolving icechunk tag at ${url}`, {\n                cause: e,\n              });\n            }\n          },\n        },\n      );\n      cache.registerDisposer(sharedKvStoreContext.addRef());\n      return cache;\n    },\n  );\n  return cache.get(url, options);\n}\n\nexport function resolveRefSpec(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  refSpec: RefSpec,\n  options: Partial<ProgressOptions>,\n): Promise<string> {\n  if (\"snapshot\" in refSpec) {\n    return Promise.resolve(refSpec.snapshot);\n  }\n  if (\"branch\" in refSpec) {\n    return getBranch(\n      sharedKvStoreContext,\n      pipelineUrlJoin(url, `refs/branch.${refSpec.branch}/`),\n      options,\n    );\n  }\n  return getTag(\n    sharedKvStoreContext,\n    pipelineUrlJoin(url, `refs/tag.${refSpec.tag}/`),\n    options,\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport {\n  FileByteRangeHandle,\n  handleByteRangeRequestFromUint8Array,\n} from \"#src/kvstore/byte_range/file_handle.js\";\nimport type { ChunkId } from \"#src/kvstore/icechunk/decode_utils.js\";\nimport type { ChunkPayload } from \"#src/kvstore/icechunk/manifest.js\";\nimport { getManifest } from \"#src/kvstore/icechunk/metadata_cache.js\";\nimport type {\n  ManifestExtents,\n  NodeDataArray,\n  NodeSnapshot,\n  Snapshot,\n} from \"#src/kvstore/icechunk/snapshot.js\";\nimport { encodeZarrJson, findNode } from \"#src/kvstore/icechunk/snapshot.js\";\nimport type {\n  DriverReadOptions,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nexport interface ResolvedIcechunkPath {\n  node: NodeSnapshot;\n  chunk?: number[];\n}\n\nexport function resolveIcechunkPath(\n  snapshot: Snapshot,\n  path: string,\n): ResolvedIcechunkPath | undefined {\n  let nodePath: string;\n  let chunk: number[] | undefined;\n  const zarrJsonMatch = path.match(/(?:^|\\/)(zarr\\.json)$/);\n  if (zarrJsonMatch !== null) {\n    nodePath = path.slice(0, -zarrJsonMatch[1].length);\n  } else {\n    const chunkMatch = path.match(/c(?:[./][0-9]+)*$/);\n    if (chunkMatch === null) {\n      return undefined;\n    }\n    nodePath = path.slice(0, -chunkMatch[0].length);\n    const parts = chunkMatch[0].split(/[./]/);\n    const n = parts.length - 1;\n    chunk = new Array<number>(n);\n    for (let i = 0; i < n; ++i) {\n      chunk[i] = Number(parts[i + 1]);\n    }\n  }\n  const node = findNode(snapshot, nodePath);\n  if (chunk === undefined) {\n    return { node };\n  }\n  if (node.nodeData === \"Group\") {\n    // chunk path not valid for groups\n    return undefined;\n  }\n  const { shape, chunkShape } = node.nodeData.Array.metadata;\n  const rank = shape.length;\n  if (rank !== chunk.length) {\n    return undefined;\n  }\n  for (let i = 0; i < rank; ++i) {\n    if (chunk[i] * chunkShape[i] >= shape[i]) {\n      return undefined;\n    }\n  }\n  return { node, chunk };\n}\n\nfunction manifestExtentsContain(\n  [lower, upper]: ManifestExtents,\n  chunk: number[],\n) {\n  for (let i = 0, n = chunk.length; i < n; ++i) {\n    const c = chunk[i];\n    if (c < lower[i] || c >= upper[i]) return false;\n  }\n  return true;\n}\n\nexport async function resolveChunkPayload(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  node: NodeSnapshot,\n  chunk: number[],\n  options: Partial<ProgressOptions>,\n): Promise<ChunkPayload | undefined> {\n  const { manifests } = (node.nodeData as NodeDataArray).Array;\n  const chunkKey = chunk.join();\n  const nodeId = node.id;\n  for (const manifestRef of manifests) {\n    if (!manifestExtentsContain(manifestRef.extents, chunk)) continue;\n    const manifest = await getManifest(\n      sharedKvStoreContext,\n      baseUrl,\n      manifestRef.objectId,\n      options,\n    );\n    const chunks = manifest.chunks.get(nodeId);\n    if (chunks === undefined) continue;\n    const chunkPayload = chunks.get(chunkKey);\n    if (chunkPayload !== undefined) return chunkPayload;\n  }\n  return undefined;\n}\n\nexport async function stat(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  snapshot: Snapshot,\n  path: string,\n  options: StatOptions,\n): Promise<StatResponse | undefined> {\n  const resolvedPath = resolveIcechunkPath(snapshot, path);\n  if (resolvedPath === undefined) return undefined;\n  const { node, chunk } = resolvedPath;\n  if (chunk === undefined) {\n    // zarr.json file.\n    return { totalSize: undefined };\n  }\n  const payload = await resolveChunkPayload(\n    sharedKvStoreContext,\n    baseUrl,\n    node,\n    chunk,\n    options,\n  );\n  if (payload === undefined) return undefined;\n  let totalSize: number;\n  if (\"Inline\" in payload) {\n    totalSize = payload.Inline.length;\n  } else if (\"Virtual\" in payload) {\n    totalSize = payload.Virtual.length;\n  } else {\n    totalSize = payload.Ref.length;\n  }\n  return { totalSize };\n}\n\nasync function readFromChunkPayload(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  payload: ChunkPayload,\n  options: DriverReadOptions,\n): Promise<ReadResponse> {\n  if (\"Inline\" in payload) {\n    return handleByteRangeRequestFromUint8Array(\n      payload.Inline,\n      options.byteRange,\n    );\n  }\n  let offset: number;\n  let length: number;\n  let url: string;\n  if (\"Virtual\" in payload) {\n    ({ location: url, offset, length } = payload.Virtual);\n  } else {\n    const { Ref: ref } = payload;\n    ({ offset, length } = ref);\n    url = getChunkUrl(baseUrl, ref.id);\n  }\n  return new FileByteRangeHandle(\n    sharedKvStoreContext.kvStoreContext.getFileHandle(url),\n    { offset, length },\n  ).read(options);\n}\n\nfunction getChunkUrl(baseUrl: string, id: ChunkId) {\n  return pipelineUrlJoin(baseUrl, `chunks/${id}`);\n}\n\nexport async function read(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  baseUrl: string,\n  snapshot: Snapshot,\n  path: string,\n  options: DriverReadOptions,\n): Promise<ReadResponse | undefined> {\n  const resolvedPath = resolveIcechunkPath(snapshot, path);\n  if (resolvedPath === undefined) return undefined;\n  const { node, chunk } = resolvedPath;\n  if (chunk === undefined) {\n    // zarr.json file.\n    const data = encodeZarrJson(node);\n    const encoded = new TextEncoder().encode(data);\n    return handleByteRangeRequestFromUint8Array(encoded, options.byteRange);\n  }\n  const payload = await resolveChunkPayload(\n    sharedKvStoreContext,\n    baseUrl,\n    node,\n    chunk,\n    options,\n  );\n  if (payload === undefined) return undefined;\n  return readFromChunkPayload(sharedKvStoreContext, baseUrl, payload, options);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isSnapshotId } from \"#src/kvstore/icechunk/ref.js\";\nimport type { KvStoreWithPath } from \"#src/kvstore/index.js\";\nimport type { UrlWithParsedScheme } from \"#src/kvstore/url.js\";\nimport {\n  encodePathForUrl,\n  ensureNoQueryOrFragmentParameters,\n  ensurePathIsDirectory,\n} from \"#src/kvstore/url.js\";\n\nexport type RefSpec =\n  | { snapshot: string }\n  | { branch: string }\n  | { tag: string };\n\nconst BRANCH_PREFIX = \"branch.\";\nconst TAG_PREFIX = \"tag.\";\n\nexport function getIcechunkUrl(\n  options: { baseUrl: string; refSpec: RefSpec | undefined },\n  key: string,\n) {\n  const { baseUrl, refSpec } = options;\n  const versionString =\n    refSpec === undefined ? \"\" : `@${formatRefSpec(refSpec)}/`;\n  return baseUrl + `|icechunk:${versionString}${encodePathForUrl(key)}`;\n}\n\nexport function formatRefSpec(refSpec: RefSpec) {\n  if (\"branch\" in refSpec) {\n    return BRANCH_PREFIX + encodePathForUrl(refSpec.branch);\n  }\n  if (\"tag\" in refSpec) {\n    return TAG_PREFIX + encodePathForUrl(refSpec.tag);\n  }\n  return refSpec.snapshot;\n}\n\nexport function isValidBranchName(name: string) {\n  return name.length > 0 && !name.includes(\"/\");\n}\n\nexport function parseRefSpec(\n  versionString: string | undefined,\n): RefSpec | undefined {\n  if (versionString === undefined) return undefined;\n  if (versionString.startsWith(BRANCH_PREFIX)) {\n    const branch = versionString.substring(BRANCH_PREFIX.length);\n    if (!isValidBranchName(branch)) {\n      throw new Error(`Invalid branch name: ${JSON.stringify(branch)}`);\n    }\n    return { branch: decodeURIComponent(branch) };\n  }\n  if (versionString.startsWith(TAG_PREFIX)) {\n    const tag = versionString.substring(TAG_PREFIX.length);\n    if (!isValidBranchName(tag)) {\n      throw new Error(`Invalid tag name: ${JSON.stringify(tag)}`);\n    }\n    return { tag: decodeURIComponent(tag) };\n  }\n  if (isSnapshotId(versionString)) {\n    return { snapshot: versionString };\n  }\n  throw new Error(`Invalid ref spec: ${JSON.stringify(versionString)}`);\n}\n\nexport function parseIcechunkUrl(\n  parsedUrl: UrlWithParsedScheme,\n  base: KvStoreWithPath,\n) {\n  ensureNoQueryOrFragmentParameters(parsedUrl);\n  try {\n    const m = (parsedUrl.suffix ?? \"\").match(/^(?:@([^/]*)(?:\\/|$))?(.*)$/)!;\n    const [, refSpecString, path] = m;\n    return {\n      baseUrl: base.store.getUrl(ensurePathIsDirectory(base.path)),\n      version: parseRefSpec(refSpecString),\n      path: decodeURIComponent(path),\n    };\n  } catch (e) {\n    throw new Error(`Invalid URL: ${parsedUrl.url}`, { cause: e });\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { getListResponseFromSnapshot } from \"#src/kvstore/icechunk/list.js\";\nimport {\n  resolveRefSpec,\n  getSnapshot,\n} from \"#src/kvstore/icechunk/metadata_cache.js\";\nimport { read, stat } from \"#src/kvstore/icechunk/read.js\";\nimport type { Snapshot } from \"#src/kvstore/icechunk/snapshot.js\";\nimport type { RefSpec } from \"#src/kvstore/icechunk/url.js\";\nimport { getIcechunkUrl } from \"#src/kvstore/icechunk/url.js\";\nimport type {\n  DriverListOptions,\n  DriverReadOptions,\n  KvStore,\n  ListResponse,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nexport class IcechunkKvStore implements KvStore {\n  constructor(\n    public sharedKvStoreContext: SharedKvStoreContextCounterpart,\n    public baseUrl: string,\n    public refSpec: RefSpec | undefined,\n  ) {}\n\n  private snapshot: Snapshot | undefined;\n\n  private async getSnapshot(options: Partial<ProgressOptions>) {\n    let { snapshot } = this;\n    if (snapshot === undefined) {\n      const snapshotId = await resolveRefSpec(\n        this.sharedKvStoreContext,\n        this.baseUrl,\n        this.refSpec ?? { branch: \"main\" },\n        options,\n      );\n      snapshot = this.snapshot = await getSnapshot(\n        this.sharedKvStoreContext,\n        this.baseUrl,\n        snapshotId,\n        options,\n      );\n    }\n    return snapshot;\n  }\n\n  getUrl(key: string) {\n    return getIcechunkUrl(this, key);\n  }\n\n  async stat(\n    key: string,\n    options: StatOptions,\n  ): Promise<StatResponse | undefined> {\n    const snapshot = await this.getSnapshot(options);\n    return stat(\n      this.sharedKvStoreContext,\n      this.baseUrl,\n      snapshot,\n      key,\n      options,\n    );\n  }\n\n  async read(\n    key: string,\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const snapshot = await this.getSnapshot(options);\n    return read(\n      this.sharedKvStoreContext,\n      this.baseUrl,\n      snapshot,\n      key,\n      options,\n    );\n  }\n\n  async list(\n    prefix: string,\n    options: DriverListOptions,\n  ): Promise<ListResponse> {\n    const snapshot = await this.getSnapshot(options);\n    return getListResponseFromSnapshot(snapshot, prefix);\n  }\n\n  get supportsOffsetReads() {\n    return true;\n  }\n  get supportsSuffixReads() {\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Snapshot } from \"#src/kvstore/icechunk/snapshot.js\";\nimport {\n  normalizeListResponse,\n  type ListResponse,\n} from \"#src/kvstore/index.js\";\nimport { binarySearch, binarySearchLowerBound } from \"#src/util/array.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\n\nexport function getListResponseFromSnapshot(\n  snapshot: Snapshot,\n  prefix: string,\n): ListResponse {\n  const { nodes } = snapshot;\n  const startIndex = binarySearchLowerBound(\n    0,\n    nodes.length,\n    (index) => nodes[index].path >= prefix,\n  );\n  const endIndex = binarySearchLowerBound(\n    Math.min(nodes.length, startIndex + 1),\n    nodes.length,\n    (index) => !nodes[index].path.startsWith(prefix),\n  );\n  const response: ListResponse = { entries: [], directories: [] };\n  for (let index = startIndex; index < endIndex; ) {\n    const node = nodes[index];\n    const { path } = node;\n    const i = path.indexOf(\"/\", prefix.length);\n    if (i === -1) {\n      // Node must exactly match prefix.\n      ++index;\n    } else {\n      if (i + 1 === path.length) {\n        // Direct child node, include in results.\n        response.directories.push(path.slice(0, i));\n      }\n      // Skip over non-direct descedant nodes.\n      const directoryPrefix = path.substring(0, i + 1);\n      index = binarySearchLowerBound(\n        index + 1,\n        endIndex,\n        (index) => !nodes[index].path.startsWith(directoryPrefix),\n      );\n    }\n  }\n\n  // Also add `zarr.json` file if it would match.\n  const lastSlash = prefix.lastIndexOf(\"/\");\n  if (\"zarr.json\".startsWith(prefix.slice(lastSlash + 1))) {\n    const parentPath = prefix.substring(0, lastSlash + 1);\n    const parentNodeIndex = binarySearch(nodes, parentPath, (path, node) =>\n      defaultStringCompare(path, node.path),\n    );\n    if (parentNodeIndex >= 0) {\n      response.entries.push({ key: parentPath + \"zarr.json\" });\n    } else {\n      throw new Error(`Parent node ${JSON.stringify(parentPath)} not found`);\n    }\n  }\n  return normalizeListResponse(response);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type {\n  CompletionResult,\n  KvStoreAdapterCompleteUrlOptions,\n} from \"#src/kvstore/context.js\";\nimport { isSnapshotId } from \"#src/kvstore/icechunk/ref.js\";\nimport { parseRefSpec } from \"#src/kvstore/icechunk/url.js\";\nimport { listKvStore } from \"#src/kvstore/index.js\";\nimport { encodePathForUrl, joinPath } from \"#src/kvstore/url.js\";\nimport type { CompletionWithDescription } from \"#src/util/completion.js\";\n\nexport async function completeIcechunkUrl(\n  _sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  options: KvStoreAdapterCompleteUrlOptions,\n): Promise<CompletionResult | undefined> {\n  const { url } = options;\n  const suffix = url.suffix ?? \"\";\n  if (suffix === \"\") {\n    return {\n      offset: 0,\n      completions: [{ value: \"@\", description: \"Ref specifier\" }],\n    };\n  }\n  const m = suffix.match(/^@([^/]*)((?:\\/|$).*)/);\n  if (m === null) return undefined;\n  const [, version, rest] = m;\n  if (rest !== \"\") {\n    parseRefSpec(version);\n    return undefined;\n  }\n\n  let refCompletionsPromise: Promise<CompletionWithDescription[]> | undefined;\n  if (\n    version.match(\n      /^(?:(?:(?:t|$)(?:a|$)(?:g|$)(?:\\.|$))|(?:(?:b|$)(?:r|$)(?:a|$)(?:n|$)(?:c|$)(?:h|$)(?:\\.|$)))/,\n    )\n  ) {\n    const refsPath = joinPath(options.base.path, `refs/`);\n    refCompletionsPromise = listKvStore(\n      options.base.store,\n      refsPath + decodeURIComponent(version),\n      { signal: options.signal, progressListener: options.progressListener },\n    ).then(({ directories }) =>\n      directories.map((path) => {\n        const ref = path.slice(refsPath.length);\n        return {\n          value: encodePathForUrl(ref) + \"/\",\n          description: ref.startsWith(\"tag.\") ? \"Tag\" : \"Branch\",\n        };\n      }),\n    );\n  }\n\n  let snapshotCompletionsPromise:\n    | Promise<CompletionWithDescription[]>\n    | undefined;\n  if (version.match(/^[0-9ABCDEFGHJKMNPQRSTVWXYZ]{0,20}$/)) {\n    const snapshotsPath = joinPath(options.base.path, `snapshots/`);\n    snapshotCompletionsPromise = listKvStore(\n      options.base.store,\n      snapshotsPath + version,\n      { signal: options.signal, progressListener: options.progressListener },\n    ).then(({ entries }) => {\n      const results: CompletionWithDescription[] = [];\n      for (const { key } of entries) {\n        const snapshotId = key.slice(snapshotsPath.length);\n        if (!isSnapshotId(snapshotId)) continue;\n        results.push({\n          value: snapshotId + \"/\",\n          description: \"Snapshot\",\n        });\n      }\n      return results;\n    });\n  }\n\n  return {\n    offset: 1,\n    completions: [\n      ...((await refCompletionsPromise) ?? []),\n      ...((await snapshotCompletionsPromise) ?? []),\n    ],\n  };\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport type { KvStoreAdapterProvider } from \"#src/kvstore/context.js\";\nimport { IcechunkKvStore } from \"#src/kvstore/icechunk/backend.js\";\nimport { completeIcechunkUrl } from \"#src/kvstore/icechunk/complete_url.js\";\nimport { parseIcechunkUrl } from \"#src/kvstore/icechunk/url.js\";\n\nfunction icechunkProvider(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n): KvStoreAdapterProvider {\n  return {\n    scheme: \"icechunk\",\n    description: \"Icechunk repository\",\n    getKvStore(parsedUrl, base) {\n      const { baseUrl, version, path } = parseIcechunkUrl(parsedUrl, base);\n      return {\n        store: new IcechunkKvStore(sharedKvStoreContext, baseUrl, version),\n        path,\n      };\n    },\n\n    completeUrl(options) {\n      return completeIcechunkUrl(sharedKvStoreContext, options);\n    },\n  };\n}\n\nbackendOnlyKvStoreProviderRegistry.registerKvStoreAdapterProvider(\n  icechunkProvider,\n);\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport { HttpKvStore } from \"#src/kvstore/http/backend.js\";\nimport { registerProviders } from \"#src/kvstore/middleauth/common.js\";\n\nregisterProviders(backendOnlyKvStoreProviderRegistry, HttpKvStore);\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function decodeLeb128(\n  array: DataView,\n  offset: number,\n): { offset: number; value: number } {\n  let result = 0;\n  let shift = 0;\n  for (let i = offset, length = array.byteLength; i < length; ++i) {\n    const byte = array.getUint8(i);\n    result += (byte & 0x7f) << shift;\n    if ((byte & 0x80) === 0) {\n      if (result > Number.MAX_SAFE_INTEGER) {\n        throw new Error(`Value exceeded ${Number.MAX_SAFE_INTEGER}`);\n      }\n      return { offset: i + 1, value: result };\n    }\n    shift += 7;\n  }\n  throw new Error(\"Unexpected EOF\");\n}\n\nexport function decodeLeb128Bigint(\n  array: DataView,\n  offset: number,\n): { offset: number; value: bigint } {\n  let result = 0n;\n  let shift = 0n;\n  for (let i = offset, length = array.byteLength; i < length; ++i) {\n    const byte = array.getUint8(i);\n    result |= BigInt(byte & 0x7f) << BigInt(shift);\n    if ((byte & 0x80) === 0) {\n      return { offset: i + 1, value: result };\n    }\n    shift += 7n;\n  }\n  throw new Error(\"Unexpected EOF\");\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const EMPTY_KEY = new Uint8Array(0);\n\nexport type Key = Uint8Array<ArrayBuffer>;\n\nexport function compareArraysLexicographically(\n  a: ArrayLike<number>,\n  b: ArrayLike<number>,\n) {\n  const minLength = Math.min(a.length, b.length);\n  for (let i = 0; i < minLength; ++i) {\n    const d = a[i] - b[i];\n    if (d !== 0) return d;\n  }\n  return a.length - b.length;\n}\n\nexport function findFirstMismatch(a: ArrayLike<number>, b: ArrayLike<number>) {\n  const minLength = Math.min(a.length, b.length);\n  for (let i = 0; i < minLength; ++i) {\n    const d = a[i] - b[i];\n    if (d !== 0) return { offset: i, difference: d };\n  }\n  return { offset: minLength, difference: a.length - b.length };\n}\n\nexport interface KeyRange {\n  inclusiveMin: Key;\n  exclusiveMax: Key;\n}\n\nconst EMPTY_KEY_RANGE: KeyRange = {\n  inclusiveMin: EMPTY_KEY,\n  exclusiveMax: Uint8Array.of(0),\n};\n\nexport function removeKeyRangePrefix(\n  keyRange: KeyRange,\n  prefix: Key,\n): KeyRange {\n  if (prefix.length === 0) return keyRange;\n  let { inclusiveMin, exclusiveMax } = keyRange;\n  {\n    const { offset, difference } = findFirstMismatch(prefix, inclusiveMin);\n    if (difference >= 0) {\n      inclusiveMin = EMPTY_KEY;\n    } else if (offset < prefix.length) {\n      return EMPTY_KEY_RANGE;\n    } else {\n      inclusiveMin = inclusiveMin.subarray(prefix.length);\n    }\n  }\n  if (exclusiveMax.length !== 0) {\n    const { offset, difference } = findFirstMismatch(prefix, exclusiveMax);\n    if (difference >= 0) {\n      return EMPTY_KEY_RANGE;\n    }\n    if (offset < prefix.length) {\n      exclusiveMax = EMPTY_KEY;\n    } else {\n      exclusiveMax = exclusiveMax.subarray(prefix.length);\n    }\n  }\n  return { inclusiveMin, exclusiveMax };\n}\n\nexport function concatKeys(...keys: Key[]): Key {\n  let length = 0;\n  for (const key of keys) {\n    length += key.length;\n  }\n  const newKey = new Uint8Array(length);\n  let offset = 0;\n  for (const key of keys) {\n    newKey.set(key, offset);\n    offset += key.length;\n  }\n  return newKey;\n}\n\nexport function keyStartsWith(key: Key, prefix: Key): boolean {\n  return (\n    key.length >= prefix.length &&\n    findFirstMismatch(key, prefix).offset === prefix.length\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Reader } from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport {\n  readArrayOf,\n  readBytes,\n  readLeb128,\n  readLeb128Bigint,\n  readLeb128Bounded,\n  readStructOfArrays,\n} from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport { EMPTY_KEY } from \"#src/kvstore/ocdbt/key.js\";\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\n\nexport interface IndirectDataReference {\n  dataFile: DataFileId;\n  offset: bigint;\n  length: bigint;\n}\n\nexport interface ReadIndirectDataReferenceOptions {\n  allowMissing?: boolean;\n  dataFileTable: DataFileTable;\n}\n\nexport function readDataFileId(\n  reader: Reader,\n  options: { dataFileTable: DataFileTable },\n) {\n  const { dataFileTable } = options;\n  const index = readLeb128(reader);\n  if (index >= dataFileTable.length) {\n    throw new Error(\n      `Invalid data file index ${index}, expected value <= ${dataFileTable.length}`,\n    );\n  }\n  return dataFileTable[index];\n}\n\nexport const readIndirectDataReferences = readStructOfArrays<\n  IndirectDataReference,\n  ReadIndirectDataReferenceOptions\n>(\n  {\n    dataFile: readArrayOf(readDataFileId),\n    offset: readArrayOf(readLeb128Bigint),\n    length: readArrayOf(readLeb128Bigint),\n  },\n  (value, options) => {\n    if (locationIsMissing(value)) {\n      if (options.allowMissing !== true) {\n        throw new Error(`Reference to missing value not allowed`);\n      }\n    } else {\n      if (value.offset + value.length > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\n          `Offset=${value.offset} + length=${value.length} exceeds maximum of ${Number.MAX_SAFE_INTEGER}`,\n        );\n      }\n    }\n  },\n);\n\nexport function locationIsMissing(location: IndirectDataReference): boolean {\n  return (\n    location.offset === 0xffffffffffffffffn &&\n    location.length === 0xffffffffffffffffn\n  );\n}\n\nconst MAX_PATH_LENGTH = 0xffff;\n\nexport interface DataFileId {\n  baseUrl: string;\n  relativePath: string;\n}\n\nexport type DataFileTable = DataFileId[];\n\nexport function readDataFileTable(\n  reader: Reader,\n  transitiveBaseUrl: string,\n): DataFileTable {\n  const numFiles = readLeb128(reader);\n  const pathLengthBuffer = new Uint16Array(numFiles * 3);\n  for (let i = 1, count = numFiles * 3; i < count; ++i) {\n    pathLengthBuffer[i] = readLeb128Bounded(reader, MAX_PATH_LENGTH);\n  }\n  const dataFileIds: DataFileId[] = [];\n  let prevBasePath = EMPTY_KEY;\n  let prevRelativePathEncoded = EMPTY_KEY;\n  const textDecoder = new TextDecoder(\"utf-8\", { fatal: true });\n  for (let i = 0; i < numFiles; ++i) {\n    let prefixLength = pathLengthBuffer[i];\n    let suffixLength = pathLengthBuffer[i + numFiles];\n    const basePathLength = pathLengthBuffer[i + 2 * numFiles];\n    const pathLength = prefixLength + suffixLength;\n    if (pathLength > MAX_PATH_LENGTH) {\n      throw new Error(\n        `path_length[${i} = prefix_length(${prefixLength}) + suffix_length(${suffixLength}) = ${pathLength} > ${MAX_PATH_LENGTH}`,\n      );\n    }\n    if (basePathLength > pathLength) {\n      throw new Error(\n        `base_path_length[${i}] = ${basePathLength} > path_length(${pathLength}) = prefix_length(${prefixLength}) + suffix_length(${suffixLength})`,\n      );\n    }\n    if (\n      prefixLength > Math.min(prevBasePath.length, basePathLength) &&\n      basePathLength !== prevBasePath.length\n    ) {\n      throw new Error(\n        `path_prefix_length[${i - 1}] = ${prefixLength} > min(base_path_length[${i - 1}] = ${prevBasePath.length}, base_path_length[${i}] = ${basePathLength}) is not valid if base_path_length[${i - 1}] != base_path_length[${i}]`,\n      );\n    }\n\n    const relativePathLength = prefixLength + suffixLength - basePathLength;\n\n    let baseUrl: string;\n    let relativePath: string;\n    if (basePathLength === 0) {\n      baseUrl = transitiveBaseUrl;\n      prevBasePath = EMPTY_KEY;\n    } else if (prefixLength >= basePathLength) {\n      baseUrl = dataFileIds[i - 1].baseUrl;\n      // prevBasePath remains unchanged\n    } else {\n      const basePath = new Uint8Array(basePathLength);\n      let offset = 0;\n      const baseSuffixLength = Math.max(basePathLength - prefixLength, 0);\n      if (prefixLength > 0) {\n        const basePrefixLength = Math.min(prefixLength, basePathLength);\n        basePath.set(prevBasePath.subarray(0, basePrefixLength));\n        offset = basePrefixLength;\n        prefixLength -= basePrefixLength;\n      }\n      if (baseSuffixLength !== 0) {\n        basePath.set(readBytes(reader, baseSuffixLength), offset);\n        suffixLength -= baseSuffixLength;\n      }\n\n      baseUrl = pipelineUrlJoin(\n        transitiveBaseUrl,\n        textDecoder.decode(basePath),\n      );\n      prevBasePath = basePath;\n    }\n\n    if (relativePathLength === 0) {\n      relativePath = \"\";\n      prevRelativePathEncoded = EMPTY_KEY;\n    } else if (\n      suffixLength === 0 &&\n      relativePathLength === prevRelativePathEncoded.length\n    ) {\n      relativePath = dataFileIds[i - 1].relativePath;\n      // prevRelativePathEncoded remains unchanged\n    } else {\n      const relativePathEncoded = new Uint8Array(relativePathLength);\n      let offset = 0;\n      if (prefixLength !== 0) {\n        relativePathEncoded.set(\n          prevRelativePathEncoded.subarray(0, prefixLength),\n          0,\n        );\n        offset += prefixLength;\n      }\n      if (suffixLength > 0) {\n        relativePathEncoded.set(readBytes(reader, suffixLength), offset);\n      }\n      relativePath = textDecoder.decode(relativePathEncoded);\n      prevRelativePathEncoded = relativePathEncoded;\n    }\n    dataFileIds[i] = { baseUrl, relativePath };\n  }\n\n  return dataFileIds;\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Reader } from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport {\n  readStructOfArrays,\n  decodeEnvelope,\n  readUint8,\n  readLeb128,\n  readLeb128Bounded,\n  readArrayOf,\n  readLeb128Bigint,\n  toArrayOfStructs,\n  readBytes,\n} from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport type {\n  DataFileTable,\n  IndirectDataReference,\n  ReadIndirectDataReferenceOptions,\n} from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport {\n  readDataFileId,\n  readDataFileTable,\n  readIndirectDataReferences,\n} from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type { Key } from \"#src/kvstore/ocdbt/key.js\";\nimport {\n  compareArraysLexicographically,\n  findFirstMismatch,\n  keyStartsWith,\n} from \"#src/kvstore/ocdbt/key.js\";\nimport { binarySearch, binarySearchLowerBound } from \"#src/util/array.js\";\n\nexport type BtreeLeafNodeValueReference =\n  | Uint8Array<ArrayBuffer>\n  | IndirectDataReference;\n\nexport interface BtreeLeafNodeEntry {\n  key: Uint8Array<ArrayBuffer>;\n  value: BtreeLeafNodeValueReference;\n}\n\nexport interface BtreeInteriorNodeEntry {\n  key: Uint8Array<ArrayBuffer>;\n  subtreeCommonPrefixLength: number;\n  node: BtreeNodeReference;\n}\n\nexport interface BtreeNode {\n  height: BtreeNodeHeight;\n  keyPrefix: Uint8Array<ArrayBuffer>;\n  entries: BtreeLeafNodeEntry[] | BtreeInteriorNodeEntry[];\n  estimatedSize: number;\n}\n\nexport type BtreeNodeHeight = number;\n\nexport interface BtreeNodeReference {\n  location: IndirectDataReference;\n  statistics: BtreeNodeStatistics;\n}\n\nexport interface BtreeNodeStatistics {\n  numIndirectValueBytes: bigint;\n  numTreeBytes: bigint;\n  numKeys: bigint;\n}\n\nconst BTREE_NODE_MAGIC_VALUE = 0x0cdb20de;\nconst BTREE_NODE_FORMAT_VERSION = 0;\nconst MAX_BTREE_NODE_ARITY = 1024 * 1024;\n\nexport async function decodeBtreeNode(\n  buffer: ArrayBuffer,\n  baseUrl: string,\n  signal: AbortSignal,\n): Promise<BtreeNode> {\n  try {\n    const { reader } = await decodeEnvelope(\n      buffer,\n      BTREE_NODE_MAGIC_VALUE,\n      BTREE_NODE_FORMAT_VERSION,\n      signal,\n    );\n    const height = readUint8(reader);\n    const dataFileTable = readDataFileTable(reader, baseUrl);\n    const numEntries = readLeb128(reader);\n    if (numEntries === 0) {\n      throw new Error(`Empty b+tree node`);\n    }\n    if (numEntries > MAX_BTREE_NODE_ARITY) {\n      throw new Error(\n        `B+tree node has arity ${numEntries}, which exceeds limit of ${MAX_BTREE_NODE_ARITY}`,\n      );\n    }\n\n    return {\n      height,\n      ...(height === 0\n        ? readBtreeLeafNodeEntries(reader, dataFileTable, numEntries)\n        : readBtreeInteriorNodeEntries(reader, dataFileTable, numEntries)),\n      estimatedSize: reader.data.byteLength * 3,\n    };\n  } catch (e) {\n    throw new Error(`Error decoding OCDBT b+tree node`, { cause: e });\n  }\n}\n\nconst MAX_KEY_LENGTH = 0xffff;\n\nfunction readKeyLength(reader: Reader): number {\n  return readLeb128Bounded(reader, MAX_KEY_LENGTH);\n}\n\nfunction readKeys<IsInteriorNode extends boolean>(\n  reader: Reader,\n  count: number,\n  interiorNode: IsInteriorNode,\n): {\n  commonPrefix: Key;\n  keys: Key[];\n  subtreeCommonPrefixLengths: IsInteriorNode extends true\n    ? Uint16Array<ArrayBuffer>\n    : undefined;\n} {\n  const keyLengthBuffer = new Uint16Array(count * 2);\n  for (let i = 1, n = keyLengthBuffer.length; i < n; ++i) {\n    keyLengthBuffer[i] = readKeyLength(reader);\n  }\n  // common prefix limited to length of first key\n  let commonPrefixLength = keyLengthBuffer[count];\n  for (let i = 1; i < count; ++i) {\n    commonPrefixLength = Math.min(commonPrefixLength, keyLengthBuffer[i]);\n  }\n  let subtreeCommonPrefixLengths: Uint16Array<ArrayBuffer> | undefined;\n  if (interiorNode) {\n    subtreeCommonPrefixLengths = new Uint16Array(count);\n    for (let i = 0; i < count; ++i) {\n      const x = (subtreeCommonPrefixLengths[i] = readKeyLength(reader));\n      commonPrefixLength = Math.min(commonPrefixLength, x);\n    }\n  }\n  commonPrefixLength = Math.min(keyLengthBuffer[count], commonPrefixLength);\n\n  for (let i = 0, prevLength = 0; i < count; ++i) {\n    const prefixLength = keyLengthBuffer[i];\n    if (prefixLength > prevLength) {\n      throw new Error(\n        `Child ${i}: Prefix length of ${prefixLength} exceeds previous key length ${prevLength}`,\n      );\n    }\n    const suffixLength = keyLengthBuffer[i + count];\n    const keyLength = prefixLength + suffixLength;\n    if (keyLength > MAX_KEY_LENGTH) {\n      throw new Error(\n        `Child ${i}: Key length ${keyLength} exceeds limit of ${MAX_KEY_LENGTH}`,\n      );\n    }\n    if (interiorNode) {\n      const subtreeCommonPrefixLength = subtreeCommonPrefixLengths![i];\n      if (subtreeCommonPrefixLength > keyLength) {\n        throw new Error(\n          `Child ${i}: subtree common prefix length of ${subtreeCommonPrefixLength} exceeds key length of ${keyLength}`,\n        );\n      }\n      subtreeCommonPrefixLengths![i] -= commonPrefixLength;\n    }\n    prevLength = keyLength;\n  }\n\n  const keys = new Array<Key>(count);\n\n  let commonPrefix: Key;\n\n  // Read first `key_suffix` and extract common prefix.\n  {\n    const keyLength = keyLengthBuffer[count];\n    const key = readBytes(reader, keyLength);\n    commonPrefix = key.slice(0, commonPrefixLength);\n    keys[0] = key.slice(commonPrefixLength);\n  }\n\n  for (let i = 1; i < count; ++i) {\n    const prefixLength = keyLengthBuffer[i] - commonPrefixLength;\n    const suffixLength = keyLengthBuffer[i + count];\n    const suffix = readBytes(reader, suffixLength);\n    const prevKey = keys[i - 1];\n    if (\n      compareArraysLexicographically(prevKey.subarray(prefixLength), suffix) >=\n      0\n    ) {\n      throw new Error(`Invalid key order`);\n    }\n    const key = new Uint8Array(prefixLength + suffixLength);\n    key.set(prevKey.subarray(0, prefixLength));\n    key.set(suffix, prefixLength);\n    keys[i] = key;\n  }\n\n  return {\n    keys,\n    subtreeCommonPrefixLengths:\n      subtreeCommonPrefixLengths as IsInteriorNode extends true\n        ? Uint16Array<ArrayBuffer>\n        : undefined,\n    commonPrefix,\n  };\n}\n\nenum LeafNodeValueKind {\n  INLINE_VALUE = 0,\n  OUT_OF_LINE_VALUE = 1,\n}\n\nconst MAX_INLINE_VALUE_LENGTH = 1024 * 1024;\n\nfunction readLeafNodeValueReferences(\n  reader: Reader,\n  dataFileTable: DataFileTable,\n  numEntries: number,\n): BtreeLeafNodeValueReference[] {\n  const lengths = readArrayOf(readLeb128Bigint)(reader, numEntries, {});\n  const valueKinds = readBytes(reader, numEntries);\n  for (let i = 0; i < numEntries; ++i) {\n    const valueKind = valueKinds[i];\n    if (valueKind > LeafNodeValueKind.OUT_OF_LINE_VALUE) {\n      throw new Error(\n        `value_kind[${i}]=${valueKind} is outside valid range [0, ${LeafNodeValueKind.OUT_OF_LINE_VALUE}]`,\n      );\n    }\n    if (valueKind === LeafNodeValueKind.INLINE_VALUE) {\n      const length = lengths[i];\n      if (length > BigInt(MAX_INLINE_VALUE_LENGTH)) {\n        throw new Error(\n          `value_length[${i}]=${length} exceeds maximum of ${MAX_INLINE_VALUE_LENGTH} for an inline value`,\n        );\n      }\n    }\n  }\n\n  const values = new Array<BtreeLeafNodeValueReference>(numEntries);\n\n  // Read data file ids for indirect values.\n  for (let i = 0; i < numEntries; ++i) {\n    if (valueKinds[i] !== LeafNodeValueKind.OUT_OF_LINE_VALUE) continue;\n    const dataFile = readDataFileId(reader, { dataFileTable });\n    values[i] = {\n      dataFile,\n      offset: 0n,\n      length: lengths[i],\n    };\n  }\n\n  // Read offsets for indirect values.\n  for (let i = 0; i < numEntries; ++i) {\n    if (valueKinds[i] !== LeafNodeValueKind.OUT_OF_LINE_VALUE) continue;\n    const offset = readLeb128Bigint(reader);\n    (values[i] as IndirectDataReference).offset = offset;\n  }\n\n  // Read inline values.\n  for (let i = 0; i < numEntries; ++i) {\n    if (valueKinds[i] !== LeafNodeValueKind.INLINE_VALUE) continue;\n    values[i] = readBytes(reader, Number(lengths[i]));\n  }\n\n  return values;\n}\n\nfunction readBtreeLeafNodeEntries(\n  reader: Reader,\n  dataFileTable: DataFileTable,\n  numEntries: number,\n): { keyPrefix: Key; entries: BtreeLeafNodeEntry[] } {\n  const { keys, commonPrefix } = readKeys(\n    reader,\n    numEntries,\n    /*interiorNode=*/ false,\n  );\n\n  const values = readLeafNodeValueReferences(reader, dataFileTable, numEntries);\n\n  return {\n    keyPrefix: commonPrefix,\n    entries: toArrayOfStructs<BtreeLeafNodeEntry>(numEntries, {\n      key: keys,\n      value: values,\n    }),\n  };\n}\n\nfunction readBtreeInteriorNodeEntries(\n  reader: Reader,\n  dataFileTable: DataFileTable,\n  numEntries: number,\n): { keyPrefix: Key; entries: BtreeInteriorNodeEntry[] } {\n  const { keys, commonPrefix, subtreeCommonPrefixLengths } = readKeys(\n    reader,\n    numEntries,\n    /*interiorNode=*/ true,\n  );\n\n  const nodes = readBtreeNodeReferences(reader, numEntries, { dataFileTable });\n  return {\n    keyPrefix: commonPrefix,\n    entries: toArrayOfStructs<BtreeInteriorNodeEntry>(numEntries, {\n      key: keys,\n      subtreeCommonPrefixLength: subtreeCommonPrefixLengths,\n      node: nodes,\n    }),\n  };\n}\n\nconst readBtreeNodeStatistics = readStructOfArrays<BtreeNodeStatistics>({\n  numKeys: readArrayOf(readLeb128Bigint),\n  numTreeBytes: readArrayOf(readLeb128Bigint),\n  numIndirectValueBytes: readArrayOf(readLeb128Bigint),\n});\n\nexport const readBtreeNodeReferences = readStructOfArrays<\n  BtreeNodeReference,\n  ReadIndirectDataReferenceOptions\n>({\n  location: readIndirectDataReferences,\n  statistics: readBtreeNodeStatistics,\n});\n\nexport function validateBtreeNodeReference(\n  node: BtreeNode,\n  height: BtreeNodeHeight,\n  inclusiveMinKey: Key,\n) {\n  if (node.height !== height) {\n    throw new Error(`Expected height of ${height} but received ${node.height}`);\n  }\n  const { keyPrefix } = node;\n  if (inclusiveMinKey.length < keyPrefix.length) {\n    if (compareArraysLexicographically(keyPrefix, inclusiveMinKey) >= 0) {\n      return;\n    }\n  } else {\n    const c = compareArraysLexicographically(\n      keyPrefix,\n      inclusiveMinKey.subarray(0, keyPrefix.length),\n    );\n    if (c >= 0) {\n      if (\n        compareArraysLexicographically(\n          node.entries[0].key,\n          inclusiveMinKey.subarray(keyPrefix.length),\n        ) >= 0\n      ) {\n        return;\n      }\n    }\n  }\n  throw new Error(\n    `First key [${keyPrefix}]+[${node.entries[0].key}] < inclusive_min [${inclusiveMinKey}] specified by parent node`,\n  );\n}\n\nexport function findBtreeInteriorEntryLowerBound(\n  entries: BtreeInteriorNodeEntry[],\n  inclusiveMin: Key,\n) {\n  // Find first entry with key *after* inclusiveMin.\n  const index = binarySearchLowerBound(\n    0,\n    entries.length,\n    (i) => compareArraysLexicographically(entries[i].key, inclusiveMin) > 0,\n  );\n  return Math.max(0, index - 1);\n}\n\nexport function findBtreeLeafEntryLowerBound(\n  entries: BtreeNode[\"entries\"],\n  inclusiveMin: Key,\n) {\n  return binarySearchLowerBound(\n    0,\n    entries.length,\n    (i) => compareArraysLexicographically(entries[i].key, inclusiveMin) >= 0,\n  );\n}\n\nexport function findBtreeInteriorEntryPrefixRange(\n  entries: BtreeInteriorNodeEntry[],\n  prefix: Key,\n): [number, number] {\n  const lower = findBtreeInteriorEntryLowerBound(entries, prefix);\n  const upper = findBtreeEntryPrefixUpperBound(\n    entries,\n    lower,\n    entries.length,\n    prefix,\n  );\n  return [lower, upper];\n}\n\nexport function findBtreeEntryPrefixUpperBound(\n  entries: BtreeNode[\"entries\"],\n  lower: number,\n  upper: number,\n  prefix: Key,\n) {\n  if (lower === upper || prefix.length === 0) return upper;\n  return binarySearchLowerBound(lower, upper, (i) => {\n    const { offset, difference } = findFirstMismatch(prefix, entries[i].key);\n    return difference < 0 && offset < prefix.length;\n  });\n}\n\nexport function findBtreeLeafEntryPrefixRange(\n  entries: BtreeLeafNodeEntry[],\n  prefix: Key,\n): [number, number] {\n  const lower = findBtreeLeafEntryLowerBound(entries, prefix);\n  const upper = findBtreeEntryPrefixUpperBound(\n    entries,\n    lower,\n    entries.length,\n    prefix,\n  );\n  return [lower, upper];\n}\n\nexport function findBtreeLeafEntry(\n  entries: BtreeLeafNodeEntry[],\n  key: Key,\n): BtreeLeafNodeEntry | undefined {\n  const index = binarySearch(entries, key, (a, b) =>\n    compareArraysLexicographically(a, b.key),\n  );\n  if (index < 0) return undefined;\n  return entries[index];\n}\n\nexport function findBtreeInteriorEntry(\n  entries: BtreeInteriorNodeEntry[],\n  key: Key,\n): BtreeInteriorNodeEntry | undefined {\n  // Find first entry that is *after* key.\n  const index = binarySearchLowerBound(\n    0,\n    entries.length,\n    (i) => compareArraysLexicographically(entries[i].key, key) > 0,\n  );\n  if (index === 0) {\n    // First entry is already *after* key, which means key is not present.\n    return undefined;\n  }\n  const entry = entries[index - 1];\n  const { subtreeCommonPrefixLength } = entry;\n  if (\n    subtreeCommonPrefixLength !== 0 &&\n    !keyStartsWith(key, entry.key.subarray(0, subtreeCommonPrefixLength))\n  ) {\n    return undefined;\n  }\n  return entry;\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { BtreeNodeReference } from \"#src/kvstore/ocdbt/btree.js\";\nimport { readBtreeNodeReferences } from \"#src/kvstore/ocdbt/btree.js\";\nimport type { Reader } from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport {\n  decodeEnvelope,\n  readArrayOf,\n  readLeb128Bigint,\n  readLeb128Bounded,\n  readStructOfArrays,\n  readUint64le,\n  readUint8,\n} from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport type {\n  DataFileTable,\n  IndirectDataReference,\n  ReadIndirectDataReferenceOptions,\n} from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport {\n  locationIsMissing,\n  readDataFileTable,\n  readIndirectDataReferences,\n} from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type { Config } from \"#src/kvstore/ocdbt/manifest.js\";\nimport type { VersionSpecifier } from \"#src/kvstore/ocdbt/version_specifier.js\";\nimport { binarySearch, binarySearchLowerBound } from \"#src/util/array.js\";\nimport { bigintCompare } from \"#src/util/bigint.js\";\n\nexport type GenerationNumber = bigint;\nexport type GenerationIndex = bigint;\nexport type VersionTreeHeight = number;\nexport type CommitTime = bigint;\n\nexport interface BtreeGenerationReference {\n  root: BtreeNodeReference;\n  generationNumber: GenerationNumber;\n  rootHeight: VersionTreeHeight;\n  commitTime: CommitTime;\n}\n\nexport interface VersionNodeReference {\n  location: IndirectDataReference;\n  generationNumber: GenerationNumber;\n  height: VersionTreeHeight;\n  numGenerations: GenerationIndex;\n  commitTime: CommitTime;\n\n  // Cumulative sum of `numGenerations`, including this one, starting from the\n  // first `VersionNodeReference` entry.\n  cumulativeNumGenerations: GenerationIndex;\n}\n\nexport type VersionTreeArityLog2 = number;\n\nexport interface VersionTreeNode {\n  height: VersionTreeHeight;\n  versionTreeArityLog2: VersionTreeArityLog2;\n  entries: VersionNodeReference[] | BtreeGenerationReference[];\n  estimatedSize: number;\n}\n\nconst MAX_VERSION_TREE_ARITY_LOG2 = 16;\n\nexport function readVersionTreeLeafNode(\n  reader: Reader,\n  versionTreeArityLog2: number,\n  dataFileTable: DataFileTable,\n): BtreeGenerationReference[] {\n  const maxNumEntries = 2 ** versionTreeArityLog2;\n  const numEntries = readLeb128Bounded(reader, maxNumEntries);\n  const entries = readVersionTreeLeafNodeEntries(reader, numEntries, {\n    allowMissing: true,\n    dataFileTable,\n  });\n  validateVersionTreeLeafNodeEntries(entries, versionTreeArityLog2);\n  return entries;\n}\n\nfunction readVersionTreeInteriorNode(\n  reader: Reader,\n  versionTreeArityLog2: number,\n  dataFileTable: DataFileTable,\n  height: number,\n): VersionNodeReference[] {\n  const maxHeight = getMaxVersionTreeHeight(versionTreeArityLog2);\n\n  if (height > maxHeight) {\n    throw new Error(\n      `height=${height} exceeds maximum of ${maxHeight} for version_tree_arity_log2=${versionTreeArityLog2}`,\n    );\n  }\n  const maxArity = 2 ** versionTreeArityLog2;\n  const entries = readVersionTreeInteriorNodeEntries(\n    reader,\n    dataFileTable,\n    maxArity,\n    height - 1,\n  );\n  validateVersionTreeInteriorNodeEntries(entries, versionTreeArityLog2, height);\n  return entries;\n}\n\nfunction validateVersionTreeLeafNodeEntries(\n  entries: BtreeGenerationReference[],\n  versionTreeArityLog2: number,\n): void {\n  const maxNumEntries = 2 ** versionTreeArityLog2;\n  if (entries.length === 0 || entries.length > maxNumEntries) {\n    throw new Error(\n      `num_children=${entries.length} outside valid range [1, ${maxNumEntries}]`,\n    );\n  }\n  for (const [i, entry] of entries.entries()) {\n    if (locationIsMissing(entry.root.location)) {\n      if (entry.rootHeight !== 0) {\n        throw new Error(\n          `non-zero root_height=${entry.rootHeight} for empty generation ${entry.generationNumber}`,\n        );\n      }\n      const { statistics } = entry.root;\n      if (\n        statistics.numKeys !== 0n ||\n        statistics.numTreeBytes !== 0n ||\n        statistics.numIndirectValueBytes !== 0n\n      ) {\n        throw new Error(\n          `non-zero statistics for empty generation_number[${i}]=${entry.generationNumber}`,\n        );\n      }\n    }\n    if (entry.generationNumber === 0n) {\n      throw new Error(`generation_number[${i}] must be non-zero`);\n    }\n    if (i !== 0) {\n      if (entry.generationNumber <= entries[i - 1].generationNumber) {\n        throw new Error(\n          `generation_number[${i}]=${entry.generationNumber} <= generation_number[${i - 1}]=${entries[i - 1].generationNumber}`,\n        );\n      }\n    }\n  }\n  const lastGenerationNumber = entries.at(-1)!.generationNumber;\n  const firstGenerationNumber = entries[0].generationNumber;\n  const minGenerationNumber = getMinVersionTreeNodeGenerationNumber(\n    versionTreeArityLog2,\n    0,\n    lastGenerationNumber,\n  );\n  if (firstGenerationNumber < minGenerationNumber) {\n    throw new Error(\n      `Generation range [${firstGenerationNumber}, ${lastGenerationNumber}] exceeds maximum of [${minGenerationNumber}, ${lastGenerationNumber}]`,\n    );\n  }\n}\n\nfunction validateVersionTreeInteriorNodeEntries(\n  entries: VersionNodeReference[],\n  versionTreeArityLog2: number,\n  height: number,\n): void {\n  const maxNumEntries = 2 ** versionTreeArityLog2;\n  if (entries.length === 0 || entries.length > maxNumEntries) {\n    throw new Error(\n      `num_children=${entries.length} outside valid range [1, ${maxNumEntries}]`,\n    );\n  }\n  const childGenerationNumberStride =\n    1n << BigInt(versionTreeArityLog2 * height);\n  for (const [i, entry] of entries.entries()) {\n    if (entry.generationNumber === 0n) {\n      throw new Error(`generation_number[${i}] must be non-zero`);\n    }\n    if (i !== 0) {\n      const prev = entries[i - 1];\n      if (entry.generationNumber <= prev.generationNumber) {\n        throw new Error(\n          `generation_number[${i}]=${entry.generationNumber} >= generation_number[${i - 1}]=${prev.generationNumber}`,\n        );\n      }\n      if (\n        (entry.generationNumber - 1n) / childGenerationNumberStride ===\n        (prev.generationNumber - 1n) / childGenerationNumberStride\n      ) {\n        throw new Error(\n          `generation_number[${i}]=${entry.generationNumber} should be in the same child node as generation_number[${i - 1}]=${prev.generationNumber}`,\n        );\n      }\n    }\n    if (entry.generationNumber % childGenerationNumberStride !== 0n) {\n      throw new Error(\n        `generation_number[${i}]=${entry.generationNumber} is not a multiple of ${childGenerationNumberStride}`,\n      );\n    }\n    if (entry.numGenerations > childGenerationNumberStride) {\n      throw new Error(\n        `num_generations[${i}]=${entry.numGenerations} for generation_number=${entry.generationNumber} is greater than ${childGenerationNumberStride}`,\n      );\n    }\n  }\n\n  const maxArity = 1n << BigInt(versionTreeArityLog2);\n  const lastEntry = entries.at(-1)!;\n  if (\n    (lastEntry.generationNumber - 1n) /\n      childGenerationNumberStride /\n      maxArity !==\n    (entries[0].generationNumber - 1n) / childGenerationNumberStride / maxArity\n  ) {\n    throw new Error(\n      `generation_number[0]=${entries[0].generationNumber} cannot be in the same node as generation_number[${entries.length - 1}]=${lastEntry.generationNumber}`,\n    );\n  }\n}\n\nfunction getMinVersionTreeNodeGenerationNumber(\n  versionTreeArityLog2: number,\n  height: number,\n  lastGenerationNumber: GenerationNumber,\n): GenerationNumber {\n  return (\n    lastGenerationNumber -\n    ((lastGenerationNumber - 1n) %\n      (1n << BigInt(versionTreeArityLog2 * (height + 1))))\n  );\n}\n\nexport function readVersionTreeArityLog2(reader: Reader) {\n  const value = readUint8(reader);\n  if (value === 0 || value > MAX_VERSION_TREE_ARITY_LOG2) {\n    throw new Error(\n      `Expected version_tree_arity_log2 in range [1, ${MAX_VERSION_TREE_ARITY_LOG2}] but received: ${value}`,\n    );\n  }\n  return value;\n}\n\nconst VERSION_TREE_NODE_MAGIC_VALUE = 0x0cdb1234;\nconst VERSION_TREE_NODE_FORMAT_VERSION = 0;\n\nexport async function decodeVersionTreeNode(\n  buffer: ArrayBuffer,\n  baseUrl: string,\n  signal: AbortSignal,\n): Promise<VersionTreeNode> {\n  try {\n    const { reader } = await decodeEnvelope(\n      buffer,\n      VERSION_TREE_NODE_MAGIC_VALUE,\n      VERSION_TREE_NODE_FORMAT_VERSION,\n      signal,\n    );\n    const versionTreeArityLog2 = readVersionTreeArityLog2(reader);\n    const height = readUint8(reader);\n    const dataFileTable = readDataFileTable(reader, baseUrl);\n    return {\n      versionTreeArityLog2,\n      height,\n      entries:\n        height === 0\n          ? readVersionTreeLeafNode(reader, versionTreeArityLog2, dataFileTable)\n          : readVersionTreeInteriorNode(\n              reader,\n              versionTreeArityLog2,\n              dataFileTable,\n              height,\n            ),\n      estimatedSize: reader.data.byteLength * 3,\n    };\n  } catch (e) {\n    throw new Error(`Error decoding OCDBT version tree node`, { cause: e });\n  }\n}\n\nconst readVersionTreeNodeInteriorNodeEntriesWithKnownCount = readStructOfArrays<\n  VersionNodeReference,\n  { dataFileTable: DataFileTable; height: number | undefined }\n>({\n  generationNumber: readArrayOf(readLeb128Bigint),\n  location: readIndirectDataReferences,\n  numGenerations: readArrayOf(readLeb128Bigint),\n  commitTime: readArrayOf(readUint64le),\n  height: readArrayOf((reader, { height }) =>\n    height === undefined ? readUint8(reader) : height,\n  ),\n  cumulativeNumGenerations: readArrayOf(() => 0n),\n});\n\nfunction computeCumulativeNumGenerations(versionNodes: VersionNodeReference[]) {\n  let sum = 0n;\n  for (const ref of versionNodes) {\n    sum += ref.numGenerations;\n    ref.cumulativeNumGenerations = sum;\n  }\n}\n\nexport function readVersionTreeInteriorNodeEntries(\n  reader: Reader,\n  dataFileTable: DataFileTable,\n  maxNumEntries: number,\n  height: number | undefined,\n) {\n  const numEntries = readLeb128Bounded(reader, maxNumEntries);\n  const entries = readVersionTreeNodeInteriorNodeEntriesWithKnownCount(\n    reader,\n    numEntries,\n    { dataFileTable, height },\n  );\n  computeCumulativeNumGenerations(entries);\n  return entries;\n}\n\nexport function getMaxVersionTreeHeight(versionTreeArityLog2: number): number {\n  return Math.floor(63 / versionTreeArityLog2) - 1;\n}\n\nexport const readVersionTreeLeafNodeEntries = readStructOfArrays<\n  BtreeGenerationReference,\n  ReadIndirectDataReferenceOptions\n>({\n  generationNumber: readArrayOf(readLeb128Bigint),\n  rootHeight: readArrayOf(readUint8),\n  root: readBtreeNodeReferences,\n  commitTime: readArrayOf(readUint64le),\n});\n\nexport type VersionQuery =\n  | VersionSpecifier\n  | { generationIndex: GenerationIndex };\n\nexport function compareVersionSpecToVersion(\n  versionSpec: VersionSpecifier,\n  ref: BtreeGenerationReference,\n) {\n  return \"generationNumber\" in versionSpec\n    ? bigintCompare(versionSpec.generationNumber, ref.generationNumber)\n    : bigintCompare(versionSpec.commitTime, ref.commitTime);\n}\n\nexport function findLeafVersion(\n  generationIndex: GenerationIndex,\n  versions: BtreeGenerationReference[],\n  version: VersionQuery,\n): number {\n  if (\"generationNumber\" in version) {\n    return findLeafVersionByGenerationNumber(\n      versions,\n      version.generationNumber,\n    );\n  } else if (\"generationIndex\" in version) {\n    let { generationIndex: i } = version;\n    i -= generationIndex;\n    if (i < 0n) return -1;\n    if (i >= BigInt(versions.length)) return versions.length;\n    return Number(i);\n  } else {\n    return findLeafVersionByCommitTime(versions, version.commitTime);\n  }\n}\n\nfunction findLeafVersionByGenerationNumber(\n  versions: BtreeGenerationReference[],\n  generationNumber: GenerationNumber,\n): number {\n  const index = binarySearch(versions, generationNumber, (a, b) =>\n    bigintCompare(a, b.generationNumber),\n  );\n  if (index < 0) return versions.length;\n  return index;\n}\n\nfunction findLeafVersionByCommitTime(\n  versions: BtreeGenerationReference[],\n  commitTime: CommitTime,\n): number {\n  const index = binarySearchLowerBound(\n    0,\n    versions.length,\n    (i) => versions[i].commitTime > commitTime,\n  );\n  if (index === 0) return versions.length;\n  return index - 1;\n}\n\n// Finds the index of the first version >= version\nexport function findLeafVersionIndexByLowerBound(\n  generationIndex: GenerationIndex,\n  versions: BtreeGenerationReference[],\n  version: VersionQuery,\n): number {\n  if (\"generationIndex\" in version) {\n    const index = version.generationIndex - generationIndex;\n    if (index < 0n) return 0;\n    if (index > BigInt(versions.length)) return versions.length;\n    return Number(index);\n  }\n  return binarySearchLowerBound(\n    0,\n    versions.length,\n    (i) => compareVersionSpecToVersion(version, versions[i]) <= 0,\n  );\n}\n\nexport function findVersionNode(\n  versionTreeArityLog2: VersionTreeArityLog2,\n  generationIndex: GenerationIndex,\n  versionNodes: VersionNodeReference[],\n  version: VersionQuery,\n): VersionNodeReference | undefined {\n  if (\"generationIndex\" in version) {\n    return versionNodes[\n      findVersionNodeIndexByGenerationIndex(\n        versionNodes,\n        version.generationIndex - generationIndex,\n      )\n    ];\n  }\n  return \"generationNumber\" in version\n    ? findVersionNodeByGenerationNumber(\n        versionTreeArityLog2,\n        versionNodes,\n        version.generationNumber,\n      )\n    : findVersionNodeByCommitTime(versionNodes, version.commitTime);\n}\n\nfunction findVersionNodeIndexByGenerationIndex(\n  versionNodes: VersionNodeReference[],\n  generationIndex: GenerationIndex,\n): number {\n  return binarySearchLowerBound(\n    0,\n    versionNodes.length,\n    (i) => versionNodes[i].cumulativeNumGenerations > generationIndex,\n  );\n}\n\nfunction findVersionNodeByGenerationNumber(\n  versionTreeArityLog2: VersionTreeArityLog2,\n  versionNodes: VersionNodeReference[],\n  generationNumber: GenerationNumber,\n): VersionNodeReference | undefined {\n  const index = binarySearchLowerBound(\n    0,\n    versionNodes.length,\n    (i) => versionNodes[i].generationNumber >= generationNumber,\n  );\n  if (index === versionNodes.length) return undefined;\n  const ref = versionNodes[index];\n  if (\n    getMinVersionTreeNodeGenerationNumber(\n      versionTreeArityLog2,\n      ref.height,\n      ref.generationNumber,\n    ) > generationNumber\n  ) {\n    return undefined;\n  }\n  return ref;\n}\n\nfunction findVersionNodeByCommitTime(\n  versionNodes: VersionNodeReference[],\n  commitTime: CommitTime,\n): VersionNodeReference | undefined {\n  const index = binarySearchLowerBound(\n    0,\n    versionNodes.length,\n    (i) => versionNodes[i].commitTime > commitTime,\n  );\n  if (index === 0) return undefined;\n  return versionNodes[index - 1];\n}\n\nexport function findVersionNodeIndexByLowerBound(\n  versionTreeArityLog2: VersionTreeArityLog2,\n  generationIndex: GenerationIndex,\n  versionNodes: VersionNodeReference[],\n  version: VersionQuery,\n): number {\n  if (\"generationIndex\" in version) {\n    return findVersionNodeIndexByGenerationIndex(\n      versionNodes,\n      version.generationIndex - generationIndex,\n    );\n  }\n  if (\"generationNumber\" in version) {\n    return findVersionNodeIndexByGenerationNumberLowerBound(\n      versionTreeArityLog2,\n      versionNodes,\n      version.generationNumber,\n    );\n  }\n  return findVersionNodeIndexByCommitTimeLowerBound(\n    versionNodes,\n    version.commitTime,\n  );\n}\n\nfunction findVersionNodeIndexByGenerationNumberLowerBound(\n  versionTreeArityLog2: VersionTreeArityLog2,\n  versionNodes: VersionNodeReference[],\n  generationNumber: GenerationNumber,\n): number {\n  return binarySearchLowerBound(0, versionNodes.length, (i) => {\n    const ref = versionNodes[i];\n    return (\n      getMinVersionTreeNodeGenerationNumber(\n        versionTreeArityLog2,\n        ref.height,\n        ref.generationNumber,\n      ) >= generationNumber\n    );\n  });\n}\n\nfunction findVersionNodeIndexByCommitTimeLowerBound(\n  versionNodes: VersionNodeReference[],\n  commitTime: CommitTime,\n): number {\n  const index = binarySearchLowerBound(\n    0,\n    versionNodes.length,\n    (i) => versionNodes[i].commitTime > commitTime,\n  );\n  return Math.max(0, index - 1);\n}\n\nexport function findVersionNodeIndexByUpperBound(\n  generationIndex: GenerationIndex,\n  versionNodes: VersionNodeReference[],\n  version: VersionQuery,\n): number {\n  if (\"generationIndex\" in version) {\n    return findVersionNodeIndexByGenerationIndexUpperBound(\n      versionNodes,\n      version.generationIndex - generationIndex,\n    );\n  }\n  if (\"generationNumber\" in version) {\n    return findVersionNodeIndexByGenerationNumberUpperBound(\n      versionNodes,\n      version.generationNumber,\n    );\n  }\n  return findVersionNodeIndexByCommitTimeLowerBound(\n    versionNodes,\n    version.commitTime,\n  );\n}\n\nfunction findVersionNodeIndexByGenerationIndexUpperBound(\n  versionNodes: VersionNodeReference[],\n  generationIndex: GenerationIndex,\n): number {\n  return binarySearchLowerBound(0, versionNodes.length, (i) => {\n    const node = versionNodes[i];\n    return (\n      node.cumulativeNumGenerations - node.numGenerations >= generationIndex\n    );\n  });\n}\n\nfunction findVersionNodeIndexByGenerationNumberUpperBound(\n  versionNodes: VersionNodeReference[],\n  generationNumber: GenerationNumber,\n): number {\n  return binarySearchLowerBound(\n    0,\n    versionNodes.length,\n    (i) => versionNodes[i].generationNumber >= generationNumber,\n  );\n}\n\nexport function validateVersionTreeNodeReference(\n  node: VersionTreeNode,\n  config: Config,\n  lastGenerationNumber: GenerationNumber,\n  height: VersionTreeHeight,\n  numGenerations: GenerationNumber,\n): void {\n  if (node.height !== height) {\n    throw new Error(\n      `Expected height of ${height} but received: ${node.height}`,\n    );\n  }\n  if (node.versionTreeArityLog2 !== config.versionTreeArityLog2) {\n    throw new Error(\n      `Expected version_tree_arity_log2=${config.versionTreeArityLog2} but received: ${node.versionTreeArityLog2}`,\n    );\n  }\n  const { generationNumber } = node.entries.at(-1)!;\n  if (generationNumber !== lastGenerationNumber) {\n    throw new Error(\n      `Expected generation number ${lastGenerationNumber} but received: ${generationNumber}`,\n    );\n  }\n  const actualNumGenerations =\n    node.height === 0\n      ? BigInt(node.entries.length)\n      : (node.entries.at(-1) as VersionNodeReference).cumulativeNumGenerations;\n  if (actualNumGenerations !== numGenerations) {\n    throw new Error(\n      `Expected ${numGenerations}, but received: ${actualNumGenerations}`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Reader } from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport {\n  CompressionMethod,\n  decodeEnvelope,\n  readBytes,\n  readInt32le,\n  readLeb128,\n  ensureEof,\n} from \"#src/kvstore/ocdbt/decode_utils.js\";\nimport type { DataFileTable } from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport { readDataFileTable } from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type {\n  BtreeGenerationReference,\n  GenerationIndex,\n  GenerationNumber,\n  VersionNodeReference,\n  VersionTreeArityLog2,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport {\n  getMaxVersionTreeHeight,\n  readVersionTreeArityLog2,\n  readVersionTreeInteriorNodeEntries,\n  readVersionTreeLeafNode,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\n\nexport interface ManifestVersionTree {\n  inlineVersions: BtreeGenerationReference[];\n  versionTreeNodes: VersionNodeReference[];\n  numGenerations: GenerationIndex;\n}\n\nexport enum ManifestKind {\n  single = 0,\n  numbered = 1,\n}\n\nexport interface Config {\n  uuid: Uint8Array<ArrayBuffer>;\n  manifestKind: ManifestKind;\n  maxInlineValueBytes: number;\n  maxDecodedNodeBytes: number;\n  versionTreeArityLog2: VersionTreeArityLog2;\n  compressionMethod: CompressionMethod;\n  zstdLevel?: number;\n}\n\nexport interface Manifest {\n  config: Config;\n  versionTree?: ManifestVersionTree;\n  estimatedSize: number;\n}\n\nexport interface ManifestWithVersionTree extends Manifest {\n  versionTree: ManifestVersionTree;\n}\n\nfunction decodeConfig(reader: Reader): Config {\n  const uuid = readBytes(reader, 16).slice();\n  const manifestKind = readLeb128(reader);\n  if (manifestKind > 1) {\n    throw new Error(`Unknown manifest kind: ${manifestKind}`);\n  }\n  const maxInlineValueBytes = readLeb128(reader);\n  const maxDecodedNodeBytes = readLeb128(reader);\n  const versionTreeArityLog2 = readVersionTreeArityLog2(reader);\n  const compressionMethod = readLeb128(reader);\n  let zstdLevel: number | undefined;\n  switch (compressionMethod) {\n    case CompressionMethod.UNCOMPRESSED:\n      break;\n    case CompressionMethod.ZSTD:\n      zstdLevel = readInt32le(reader);\n      break;\n    default:\n      throw new Error(`Invalid compression method: ${compressionMethod}`);\n  }\n  return {\n    uuid,\n    manifestKind,\n    maxInlineValueBytes,\n    maxDecodedNodeBytes,\n    versionTreeArityLog2,\n    compressionMethod,\n    zstdLevel,\n  };\n}\n\nfunction decodeManifestVersionTree(\n  reader: Reader,\n  config: Config,\n  baseUrl: string,\n): ManifestVersionTree {\n  const dataFileTable = readDataFileTable(reader, baseUrl);\n\n  const inlineVersions = readVersionTreeLeafNode(\n    reader,\n    config.versionTreeArityLog2,\n    dataFileTable,\n  );\n\n  const versionTreeNodes = readManifestVersionTreeNodes(\n    reader,\n    config.versionTreeArityLog2,\n    dataFileTable,\n    inlineVersions.at(-1)!.generationNumber,\n  );\n  return {\n    inlineVersions,\n    versionTreeNodes,\n    numGenerations:\n      BigInt(inlineVersions.length) +\n      (versionTreeNodes.at(-1)?.cumulativeNumGenerations ?? 0n),\n  };\n}\n\nfunction readManifestVersionTreeNodes(\n  reader: Reader,\n  versionTreeArityLog2: number,\n  dataFileTable: DataFileTable,\n  lastGenerationNumber: GenerationNumber,\n): VersionNodeReference[] {\n  const maxNumEntries = getMaxVersionTreeHeight(versionTreeArityLog2);\n  const entries = readVersionTreeInteriorNodeEntries(\n    reader,\n    dataFileTable,\n    maxNumEntries,\n    /* height=*/ undefined,\n  );\n  validateManifestVersionTreeNodes(\n    versionTreeArityLog2,\n    lastGenerationNumber,\n    entries,\n  );\n  return entries;\n}\n\nfunction validateManifestVersionTreeNodes(\n  versionTreeArityLog2: number,\n  lastGenerationNumber: GenerationNumber,\n  entries: VersionNodeReference[],\n): void {\n  const maxHeight = getMaxVersionTreeHeight(versionTreeArityLog2);\n  for (const [i, entry] of entries.entries()) {\n    if (entry.height === 0 || entry.height > maxHeight) {\n      throw new Error(\n        `entry_height[${i}]=${entry.height} outside valid range [1, ${maxHeight}]`,\n      );\n    }\n    if (entry.generationNumber === 0n) {\n      throw new Error(`generation_number[${i}] must be non-zero`);\n    }\n    if (i > 0) {\n      const prev = entries[i - 1];\n      if (entry.generationNumber <= prev.generationNumber) {\n        throw new Error(\n          `generation_number[${i}]=${entry.generationNumber} <= generation_number[${i - 1}]=${prev.generationNumber}`,\n        );\n      }\n      if (entry.height >= prev.height) {\n        throw new Error(\n          `entry_height[${i}]=${entry.height} >= entry_height[${i - 1}]=${prev.height}`,\n        );\n      }\n    }\n  }\n  let i = entries.length;\n  for (const {\n    minGenerationNumber,\n    maxGenerationNumber,\n    height,\n  } of getPossibleManifestVersionTreeNodeReferences(\n    lastGenerationNumber,\n    versionTreeArityLog2,\n  )) {\n    if (i === 0) {\n      // Height not present.\n      break;\n    }\n    const entry = entries[i - 1];\n    if (entry.height !== height) {\n      // Height not present\n      continue;\n    }\n    --i;\n    const { generationNumber } = entry;\n    if (\n      generationNumber < minGenerationNumber ||\n      generationNumber > maxGenerationNumber\n    ) {\n      throw new Error(\n        `generation_number[${i}]=${generationNumber} is outside expected range [${minGenerationNumber}, ${maxGenerationNumber}] for height ${height}`,\n      );\n    }\n  }\n\n  if (i !== 0) {\n    throw new Error(\n      `Unexpected child with generation_number[${i - 1}]=${entries[i - 1].generationNumber} and entry_height=${entries[i - 1].height} given last generation_number=${lastGenerationNumber}`,\n    );\n  }\n}\n\ninterface PossibleManifestVersionTreeNodeReferences {\n  minGenerationNumber: GenerationNumber;\n  maxGenerationNumber: GenerationNumber;\n  height: number;\n}\n\nfunction getPossibleManifestVersionTreeNodeReferences(\n  generationNumber: GenerationNumber,\n  versionTreeArityLog2: number,\n): PossibleManifestVersionTreeNodeReferences[] {\n  generationNumber =\n    ((generationNumber - 1n) >> BigInt(versionTreeArityLog2)) <<\n    BigInt(versionTreeArityLog2);\n  let height = 1;\n  const results: PossibleManifestVersionTreeNodeReferences[] = [];\n  while (generationNumber !== 0n) {\n    const shift = BigInt((height + 1) * versionTreeArityLog2);\n    const nextGenerationNumber = ((generationNumber - 1n) >> shift) << shift;\n    const minGenerationNumber = nextGenerationNumber + 1n;\n    results.push({\n      minGenerationNumber,\n      maxGenerationNumber: generationNumber,\n      height,\n    });\n    ++height;\n    generationNumber = nextGenerationNumber;\n  }\n  return results;\n}\n\nconst MANIFEST_MAGIC_VALUE = 0x0cdb3a2a;\nconst MANIFEST_FORMAT_VERSION = 0;\n\nexport async function decodeManifest(\n  buffer: ArrayBuffer,\n  baseUrl: string,\n  signal: AbortSignal,\n): Promise<Manifest> {\n  try {\n    const { reader } = await decodeEnvelope(\n      buffer,\n      MANIFEST_MAGIC_VALUE,\n      MANIFEST_FORMAT_VERSION,\n      signal,\n    );\n\n    const config = decodeConfig(reader);\n    const versionTree =\n      config.manifestKind === ManifestKind.single\n        ? decodeManifestVersionTree(reader, config, baseUrl)\n        : undefined;\n    ensureEof(reader);\n    return { config, versionTree, estimatedSize: reader.data.byteLength * 3 };\n  } catch (e) {\n    throw new Error(`Error decoding OCDBT manifest`, { cause: e });\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { BtreeNode } from \"#src/kvstore/ocdbt/btree.js\";\nimport { decodeBtreeNode } from \"#src/kvstore/ocdbt/btree.js\";\nimport type {\n  DataFileId,\n  IndirectDataReference,\n} from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type {\n  Manifest,\n  ManifestWithVersionTree,\n} from \"#src/kvstore/ocdbt/manifest.js\";\nimport { decodeManifest } from \"#src/kvstore/ocdbt/manifest.js\";\nimport type { VersionTreeNode } from \"#src/kvstore/ocdbt/version_tree.js\";\nimport { decodeVersionTreeNode } from \"#src/kvstore/ocdbt/version_tree.js\";\nimport { pipelineUrlJoin } from \"#src/kvstore/url.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\nimport { ProgressSpan } from \"#src/util/progress_listener.js\";\n\nexport function getManifest(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  dataFile: DataFileId,\n  options: Partial<ProgressOptions>,\n): Promise<Manifest> {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"ocdbt:manifest\",\n    () => {\n      const cache = new SimpleAsyncCache<DataFileId, Manifest>(\n        sharedKvStoreContext.chunkManager.addRef(),\n        {\n          get: async (\n            dataFile: DataFileId,\n            progressOptions: ProgressOptions,\n          ) => {\n            const fullUrl = pipelineUrlJoin(\n              dataFile.baseUrl,\n              dataFile.relativePath,\n            );\n            using _span = new ProgressSpan(progressOptions.progressListener, {\n              message: `Reading OCDBT manifest from ${fullUrl}`,\n            });\n            const readResponse = await sharedKvStoreContext.kvStoreContext.read(\n              fullUrl,\n              {\n                ...progressOptions,\n                throwIfMissing: true,\n              },\n            );\n            try {\n              const manifest = await decodeManifest(\n                await readResponse.response.arrayBuffer(),\n                dataFile.baseUrl,\n                progressOptions.signal,\n              );\n              return { data: manifest, size: manifest.estimatedSize };\n            } catch (e) {\n              throw new Error(`Error reading OCDBT manifest from ${fullUrl}`, {\n                cause: e,\n              });\n            }\n          },\n        },\n      );\n      cache.registerDisposer(sharedKvStoreContext.addRef());\n      return cache;\n    },\n  );\n  return cache.get(dataFile, options);\n}\n\nexport async function getResolvedManifest(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  options: Partial<ProgressOptions>,\n): Promise<ManifestWithVersionTree> {\n  const manifest = await getManifest(\n    sharedKvStoreContext,\n    { baseUrl: url, relativePath: \"manifest.ocdbt\" },\n    options,\n  );\n  if (manifest.versionTree === undefined) {\n    throw new Error(\"only manifest_kind=single is supported\");\n  }\n  return manifest as ManifestWithVersionTree;\n}\n\nfunction makeIndirectDataReferenceCache<T extends { estimatedSize: number }>(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  description: string,\n  decode: (\n    data: ArrayBuffer,\n    baseUrl: string,\n    signal: AbortSignal,\n  ) => Promise<T>,\n) {\n  const cache = new SimpleAsyncCache<IndirectDataReference, T>(\n    sharedKvStoreContext.chunkManager.addRef(),\n    {\n      get: async (\n        location: IndirectDataReference,\n        progressOptions: ProgressOptions,\n      ) => {\n        const { dataFile } = location;\n        const fullUrl = pipelineUrlJoin(\n          dataFile.baseUrl,\n          dataFile.relativePath,\n        );\n        const readResponse = await sharedKvStoreContext.kvStoreContext.read(\n          fullUrl,\n          {\n            ...progressOptions,\n            throwIfMissing: true,\n            byteRange: {\n              offset: Number(location.offset),\n              length: Number(location.length),\n            },\n          },\n        );\n        try {\n          const node = await decode(\n            await readResponse.response.arrayBuffer(),\n            dataFile.baseUrl,\n            progressOptions.signal,\n          );\n          return { data: node, size: node.estimatedSize };\n        } catch (e) {\n          throw new Error(\n            `Error reading OCDBT ${description} from ${fullUrl}`,\n            {\n              cause: e,\n            },\n          );\n        }\n      },\n      encodeKey: ({ dataFile, offset, length }) =>\n        JSON.stringify([dataFile, `${offset}/${length}`]),\n    },\n  );\n  cache.registerDisposer(sharedKvStoreContext.addRef());\n  return cache;\n}\n\nexport function getBtreeNode(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  location: IndirectDataReference,\n  options: Partial<ProgressOptions>,\n): Promise<BtreeNode> {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"ocdbt:btree\",\n    () =>\n      makeIndirectDataReferenceCache(\n        sharedKvStoreContext,\n        \"b+tree node\",\n        decodeBtreeNode,\n      ),\n  );\n  return cache.get(location, options);\n}\n\nexport function getVersionTreeNode(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  location: IndirectDataReference,\n  options: Partial<ProgressOptions>,\n): Promise<VersionTreeNode> {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"ocdbt:versionnode\",\n    () =>\n      makeIndirectDataReferenceCache(\n        sharedKvStoreContext,\n        \"version tree node\",\n        decodeVersionTreeNode,\n      ),\n  );\n  return cache.get(location, options);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport {\n  normalizeListResponse,\n  type ListEntry,\n  type ListResponse,\n} from \"#src/kvstore/index.js\";\nimport type {\n  BtreeInteriorNodeEntry,\n  BtreeLeafNodeEntry,\n  BtreeNodeReference,\n} from \"#src/kvstore/ocdbt/btree.js\";\nimport {\n  findBtreeInteriorEntryPrefixRange,\n  findBtreeEntryPrefixUpperBound,\n  validateBtreeNodeReference,\n  findBtreeLeafEntryPrefixRange,\n} from \"#src/kvstore/ocdbt/btree.js\";\nimport { locationIsMissing } from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type { Key } from \"#src/kvstore/ocdbt/key.js\";\nimport {\n  concatKeys,\n  EMPTY_KEY,\n  findFirstMismatch,\n} from \"#src/kvstore/ocdbt/key.js\";\nimport { getBtreeNode } from \"#src/kvstore/ocdbt/metadata_cache.js\";\nimport type { BtreeGenerationReference } from \"#src/kvstore/ocdbt/version_tree.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nconst DEBUG = false;\n\nexport async function listRoot(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  root: BtreeGenerationReference,\n  prefix: Key,\n  options: Partial<ProgressOptions>,\n): Promise<ListResponse> {\n  const entries: ListEntry[] = [];\n  const directories = new Set<string>();\n  if (!locationIsMissing(root.root.location)) {\n    await listSubtree(root.root, root.rootHeight, EMPTY_KEY, 0, {\n      sharedKvStoreContext,\n      prefix,\n      entries: entries,\n      directories,\n      signal: options.signal,\n      progressListener: options.progressListener,\n    });\n  }\n  const response = normalizeListResponse({\n    entries,\n    directories: Array.from(directories),\n  });\n  if (DEBUG) {\n    console.log(JSON.stringify(response));\n  }\n  return response;\n}\n\ninterface ListSubtreeOptions extends Partial<ProgressOptions> {\n  sharedKvStoreContext: SharedKvStoreContextCounterpart;\n  prefix: Key;\n  directories: Set<string>;\n  entries: ListEntry[];\n}\n\nasync function listSubtree(\n  nodeReference: BtreeNodeReference,\n  height: number,\n  inclusiveMinKey: Uint8Array<ArrayBuffer>,\n  subtreeCommonPrefixLength: number,\n  options: ListSubtreeOptions,\n): Promise<void> {\n  options.signal?.throwIfAborted();\n  const node = await getBtreeNode(\n    options.sharedKvStoreContext,\n    nodeReference.location,\n    options,\n  );\n  validateBtreeNodeReference(\n    node,\n    height,\n    inclusiveMinKey.subarray(subtreeCommonPrefixLength),\n  );\n  const subtreeKeyPrefix = concatKeys(\n    inclusiveMinKey.subarray(0, subtreeCommonPrefixLength),\n    node.keyPrefix,\n  );\n  if (DEBUG) {\n    console.log(\"listSubtree\", {\n      nodeReference,\n      height,\n      inclusiveMinKey,\n      subtreeCommonPrefixLength,\n    });\n  }\n  const addDirectoryIfValid = (key: Key) => {\n    try {\n      options.directories.add(\n        new TextDecoder(\"utf-8\", { fatal: true }).decode(key),\n      );\n    } catch {\n      // Skip invalid utf-8 keys.\n    }\n  };\n  const { prefix } = options;\n  {\n    const { offset, difference } = findFirstMismatch(prefix, subtreeKeyPrefix);\n    if (\n      difference !== 0 &&\n      offset < Math.min(prefix.length, subtreeKeyPrefix.length)\n    ) {\n      // No keys in node match prefix.\n      return;\n    }\n  }\n\n  if (prefix.length < subtreeKeyPrefix.length) {\n    // Check if there is a directory separator in `subtreeKeyPrefix` after `prefix`.\n    const separatorIndex = subtreeKeyPrefix.indexOf(0x2f, prefix.length);\n    if (separatorIndex !== -1) {\n      // All keys in the node are part of a common directory.\n      addDirectoryIfValid(subtreeKeyPrefix.subarray(0, separatorIndex));\n      return;\n    }\n  }\n\n  const prefixForCurrentNode = prefix.subarray(subtreeKeyPrefix.length);\n  if (node.height > 0) {\n    const entries = node.entries as BtreeInteriorNodeEntry[];\n    const [lower, upper] = findBtreeInteriorEntryPrefixRange(\n      entries,\n      prefixForCurrentNode,\n    );\n    if (DEBUG) {\n      console.log(\n        \"Got entry range\",\n        lower,\n        upper,\n        entries.length,\n        prefixForCurrentNode,\n      );\n    }\n    const promises: Promise<void>[] = [];\n    for (let entryIndex = lower; entryIndex < upper; ) {\n      const entry = entries[entryIndex];\n      ++entryIndex;\n      const { key } = entry;\n      const { subtreeCommonPrefixLength } = entry;\n      if (subtreeCommonPrefixLength > prefixForCurrentNode.length) {\n        const separatorIndex = key.indexOf(\n          0x2f /* \"/\".charCodeAt(0) */,\n          prefixForCurrentNode.length,\n        );\n        if (separatorIndex !== -1) {\n          // Since there is an additional directory separator after `prefix`\n          // within the common key prefix for the subtree, it is not necessary\n          // to traverse down into the child.\n          const directoryPrefix = key.subarray(0, separatorIndex);\n          addDirectoryIfValid(concatKeys(subtreeKeyPrefix, directoryPrefix));\n          entryIndex = findBtreeEntryPrefixUpperBound(\n            entries,\n            entryIndex,\n            upper,\n            directoryPrefix,\n          );\n          continue;\n        }\n      }\n      promises.push(\n        listSubtree(\n          entry.node,\n          height - 1,\n          concatKeys(subtreeKeyPrefix, entry.key),\n          subtreeKeyPrefix.length + entry.subtreeCommonPrefixLength,\n          options,\n        ),\n      );\n    }\n    await Promise.all(promises);\n  } else {\n    const entries = node.entries as BtreeLeafNodeEntry[];\n    const [lower, upper] = findBtreeLeafEntryPrefixRange(\n      entries,\n      prefixForCurrentNode,\n    );\n    for (let entryIndex = lower; entryIndex < upper; ) {\n      const entry = entries[entryIndex];\n      ++entryIndex;\n      const { key } = entry;\n      const separatorIndex = key.indexOf(\n        0x2f /* \"/\".charCodeAt(0) */,\n        prefixForCurrentNode.length,\n      );\n      if (separatorIndex !== -1) {\n        const directoryPrefix = key.subarray(0, separatorIndex);\n        addDirectoryIfValid(concatKeys(subtreeKeyPrefix, directoryPrefix));\n        entryIndex = findBtreeEntryPrefixUpperBound(\n          entries,\n          entryIndex,\n          upper,\n          key.subarray(0, separatorIndex + 1),\n        );\n        continue;\n      }\n      try {\n        options.entries.push({\n          key: new TextDecoder(\"utf-8\", { fatal: true }).decode(\n            concatKeys(subtreeKeyPrefix, key),\n          ),\n        });\n      } catch {\n        // Ignore invalid utf-8 keys.\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport {\n  FileByteRangeHandle,\n  handleByteRangeRequestFromUint8Array,\n} from \"#src/kvstore/byte_range/file_handle.js\";\nimport type { DriverReadOptions, ReadResponse } from \"#src/kvstore/index.js\";\nimport { KvStoreFileHandle } from \"#src/kvstore/index.js\";\nimport type {\n  BtreeInteriorNodeEntry,\n  BtreeLeafNodeEntry,\n  BtreeNodeHeight,\n  BtreeNodeReference,\n} from \"#src/kvstore/ocdbt/btree.js\";\nimport {\n  findBtreeInteriorEntry,\n  findBtreeLeafEntry,\n  validateBtreeNodeReference,\n} from \"#src/kvstore/ocdbt/btree.js\";\nimport { locationIsMissing } from \"#src/kvstore/ocdbt/indirect_data_reference.js\";\nimport type { Key } from \"#src/kvstore/ocdbt/key.js\";\nimport { EMPTY_KEY, keyStartsWith } from \"#src/kvstore/ocdbt/key.js\";\nimport { getBtreeNode } from \"#src/kvstore/ocdbt/metadata_cache.js\";\nimport type { BtreeGenerationReference } from \"#src/kvstore/ocdbt/version_tree.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nconst DEBUG = false;\n\nexport async function findEntryInRoot(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  root: BtreeGenerationReference,\n  key: Key,\n  options: Partial<ProgressOptions>,\n): Promise<BtreeLeafNodeEntry | undefined> {\n  if (locationIsMissing(root.root.location)) {\n    return undefined;\n  }\n  return await findEntryInSubtree(\n    sharedKvStoreContext,\n    root.root,\n    root.rootHeight,\n    EMPTY_KEY,\n    key,\n    options,\n  );\n}\n\nexport async function readFromRoot(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  root: BtreeGenerationReference,\n  key: Key,\n  options: DriverReadOptions,\n): Promise<ReadResponse | undefined> {\n  if (locationIsMissing(root.root.location)) {\n    return undefined;\n  }\n  const entry = await findEntryInSubtree(\n    sharedKvStoreContext,\n    root.root,\n    root.rootHeight,\n    EMPTY_KEY,\n    key,\n    options,\n  );\n  if (entry === undefined) return undefined;\n  return await readFromLeafNodeEntry(sharedKvStoreContext, entry, options);\n}\n\nexport async function findEntryInSubtree(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  nodeReference: BtreeNodeReference,\n  nodeHeight: BtreeNodeHeight,\n  inclusiveMinKey: Key,\n  queryKey: Key,\n  options: Partial<ProgressOptions>,\n): Promise<BtreeLeafNodeEntry | undefined> {\n  while (true) {\n    const node = await getBtreeNode(\n      sharedKvStoreContext,\n      nodeReference.location,\n      options,\n    );\n    if (DEBUG) {\n      console.log(nodeReference, nodeHeight, node, inclusiveMinKey, queryKey);\n    }\n    validateBtreeNodeReference(node, nodeHeight, inclusiveMinKey);\n    if (!keyStartsWith(queryKey, node.keyPrefix)) {\n      if (DEBUG) {\n        console.log(\n          \"not found due to key prefix mismatch\",\n          queryKey,\n          node.keyPrefix,\n        );\n      }\n      return undefined;\n    }\n    if (node.height === 0) {\n      const entry = findBtreeLeafEntry(\n        node.entries as BtreeLeafNodeEntry[],\n        queryKey,\n      );\n      return entry;\n    }\n    const entry = findBtreeInteriorEntry(\n      node.entries as BtreeInteriorNodeEntry[],\n      queryKey,\n    );\n    if (entry === undefined) {\n      return undefined;\n    }\n    const { subtreeCommonPrefixLength } = entry;\n    queryKey = queryKey.subarray(subtreeCommonPrefixLength);\n    nodeReference = entry.node;\n    inclusiveMinKey = entry.key.subarray(subtreeCommonPrefixLength);\n    --nodeHeight;\n  }\n}\n\nexport async function readFromLeafNodeEntry(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  entry: BtreeLeafNodeEntry,\n  options: DriverReadOptions,\n): Promise<ReadResponse | undefined> {\n  const { value } = entry;\n  if (value instanceof Uint8Array) {\n    return handleByteRangeRequestFromUint8Array(value, options.byteRange);\n  }\n  const {\n    offset,\n    length,\n    dataFile: { baseUrl, relativePath },\n  } = value;\n  const { store, path } =\n    sharedKvStoreContext.kvStoreContext.getKvStore(baseUrl);\n  return await new FileByteRangeHandle(\n    new KvStoreFileHandle(store, path + relativePath),\n    { offset: Number(offset), length: Number(length) },\n  ).read(options);\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type {\n  Config,\n  ManifestWithVersionTree,\n} from \"#src/kvstore/ocdbt/manifest.js\";\nimport {\n  getResolvedManifest,\n  getVersionTreeNode,\n} from \"#src/kvstore/ocdbt/metadata_cache.js\";\nimport type { VersionSpecifier } from \"#src/kvstore/ocdbt/version_specifier.js\";\nimport { formatVersion } from \"#src/kvstore/ocdbt/version_specifier.js\";\nimport type {\n  VersionNodeReference,\n  BtreeGenerationReference,\n  GenerationIndex,\n  VersionQuery,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport {\n  compareVersionSpecToVersion,\n  findLeafVersion,\n  findLeafVersionIndexByLowerBound,\n  findVersionNode,\n  findVersionNodeIndexByLowerBound,\n  findVersionNodeIndexByUpperBound,\n  validateVersionTreeNodeReference,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nexport async function getRoot(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  url: string,\n  version: VersionSpecifier | undefined,\n  options: Partial<ProgressOptions>,\n): Promise<BtreeGenerationReference> {\n  const cache = sharedKvStoreContext.chunkManager.memoize.get(\n    \"ocdbt:version\",\n    () => {\n      const cache = new SimpleAsyncCache<\n        { url: string; version: VersionSpecifier | undefined },\n        BtreeGenerationReference\n      >(sharedKvStoreContext.chunkManager.addRef(), {\n        get: async ({ url, version }, progressOptions) => {\n          const manifest = await getResolvedManifest(\n            sharedKvStoreContext,\n            url,\n            progressOptions,\n          );\n          const root = await readVersion(\n            sharedKvStoreContext,\n            manifest,\n            version,\n            options,\n          );\n          if (root === undefined) {\n            throw new Error(`Version ${formatVersion(version)} not found`);\n          }\n          return {\n            data: root.ref,\n            // BtreeGenerationReference is a tiny object, size may as well be 0\n            size: 0,\n          };\n        },\n        encodeKey: ({ url, version }) => {\n          let versionString: string | undefined;\n          if (version !== undefined) {\n            versionString = formatVersion(version);\n          }\n          return JSON.stringify([url, versionString]);\n        },\n      });\n      cache.registerDisposer(sharedKvStoreContext.addRef());\n      return cache;\n    },\n  );\n  return cache.get({ url, version }, options);\n}\n\nexport async function readVersion(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  version: VersionQuery | undefined,\n  options: Partial<ProgressOptions>,\n): Promise<\n  | { ref: BtreeGenerationReference; generationIndex: GenerationIndex }\n  | undefined\n> {\n  const { versionTree } = manifest;\n  if (version === undefined) {\n    const { versionTreeNodes, inlineVersions } = versionTree;\n    const index = inlineVersions.length - 1;\n    return {\n      ref: inlineVersions[index],\n      generationIndex:\n        (versionTreeNodes.at(-1)?.cumulativeNumGenerations ?? 0n) +\n        BigInt(index),\n    };\n  }\n  const { ref, generationIndex } = await findVersion(\n    sharedKvStoreContext,\n    manifest,\n    version,\n    options,\n  );\n  if (ref === undefined) return undefined;\n  return { ref, generationIndex };\n}\n\nexport async function findVersionIndexByLowerBound(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  version: VersionSpecifier,\n  options: Partial<ProgressOptions>,\n): Promise<GenerationIndex> {\n  const { generationIndex } = await findVersionLowerBoundImpl(\n    sharedKvStoreContext,\n    manifest,\n    version,\n    options,\n  );\n  return generationIndex;\n}\n\nexport async function findVersionIndexByUpperBound(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  version: VersionSpecifier,\n  options: Partial<ProgressOptions>,\n): Promise<GenerationIndex> {\n  const { generationIndex } = await findVersionUpperBoundImpl(\n    sharedKvStoreContext,\n    manifest,\n    version,\n    options,\n  );\n  return generationIndex;\n}\n\ninterface FindVersionImplOptions<Query> {\n  isInline(\n    config: Config,\n    generationIndex: GenerationIndex,\n    versions: BtreeGenerationReference[],\n    query: Query,\n  ): boolean;\n  findInLeaf(\n    config: Config,\n    generationIndex: GenerationIndex,\n    versions: BtreeGenerationReference[],\n    query: Query,\n  ): number;\n  findInInterior(\n    config: Config,\n    generationIndex: GenerationIndex,\n    versionNodes: VersionNodeReference[],\n    query: Query,\n  ): VersionNodeReference | undefined;\n}\n\nfunction findVersionImpl<Query>(options: FindVersionImplOptions<Query>): (\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  query: Query,\n  options: Partial<ProgressOptions>,\n) => Promise<{\n  ref: BtreeGenerationReference | undefined;\n  generationIndex: GenerationIndex;\n}> {\n  const { isInline, findInLeaf, findInInterior } = options;\n  async function findVersion(\n    sharedKvStoreContext: SharedKvStoreContextCounterpart,\n    manifest: ManifestWithVersionTree,\n    query: Query,\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<{\n    ref: BtreeGenerationReference | undefined;\n    generationIndex: GenerationIndex;\n  }> {\n    const { config, versionTree } = manifest;\n    const generationIndex =\n      versionTree.versionTreeNodes.at(-1)?.cumulativeNumGenerations ?? 0n;\n    const { inlineVersions } = versionTree;\n    if (isInline(config, generationIndex, inlineVersions, query)) {\n      const index = findInLeaf(config, generationIndex, inlineVersions, query);\n      return {\n        ref: inlineVersions[index],\n        generationIndex: generationIndex + BigInt(index),\n      };\n    }\n    const { versionTreeNodes } = versionTree;\n    if (versionTreeNodes.length === 0) {\n      return { ref: undefined, generationIndex: 0n };\n    }\n    const ref = findInInterior(config, 0n, versionTreeNodes, query);\n    if (ref === undefined) return { ref: undefined, generationIndex: 0n };\n    return await findInSubtree(\n      sharedKvStoreContext,\n      manifest.config,\n      0n + ref.cumulativeNumGenerations - ref.numGenerations,\n      ref,\n      query,\n      progressOptions,\n    );\n  }\n\n  async function findInSubtree(\n    sharedKvStoreContext: SharedKvStoreContextCounterpart,\n    config: Config,\n    generationIndex: GenerationIndex,\n    ref: VersionNodeReference,\n    query: Query,\n    progressOptions: Partial<ProgressOptions>,\n  ): Promise<{\n    ref: BtreeGenerationReference | undefined;\n    generationIndex: GenerationIndex;\n  }> {\n    while (true) {\n      const node = await getVersionTreeNode(\n        sharedKvStoreContext,\n        ref.location,\n        progressOptions,\n      );\n      validateVersionTreeNodeReference(\n        node,\n        config,\n        ref.generationNumber,\n        ref.height,\n        ref.numGenerations,\n      );\n      if (node.height === 0) {\n        const entries = node.entries as BtreeGenerationReference[];\n        const index = findInLeaf(config, generationIndex, entries, query);\n        return {\n          ref: entries[index],\n          generationIndex: generationIndex + BigInt(index),\n        };\n      }\n      const result = findInInterior(\n        config,\n        generationIndex,\n        node.entries as VersionNodeReference[],\n        query,\n      );\n      if (result === undefined) return { ref: undefined, generationIndex };\n      ref = result;\n      generationIndex += ref.cumulativeNumGenerations - ref.numGenerations;\n    }\n  }\n\n  return findVersion;\n}\n\nfunction isVersionQueryInline(\n  generationIndex: GenerationIndex,\n  versions: BtreeGenerationReference[],\n  version: VersionQuery,\n): boolean {\n  if (\"generationIndex\" in version) {\n    return version.generationIndex >= generationIndex;\n  }\n  return compareVersionSpecToVersion(version, versions[0]) >= 0;\n}\n\nconst findVersion = findVersionImpl<VersionQuery>({\n  isInline(_config, generationIndex, versions, version) {\n    return isVersionQueryInline(generationIndex, versions, version);\n  },\n  findInLeaf(_config, generationIndex, versions, version) {\n    return findLeafVersion(generationIndex, versions, version);\n  },\n  findInInterior(config, generationIndex, versionNodes, version) {\n    return findVersionNode(\n      config.versionTreeArityLog2,\n      generationIndex,\n      versionNodes,\n      version,\n    );\n  },\n});\n\nconst findVersionLowerBoundImpl = findVersionImpl<VersionQuery>({\n  isInline(_config, generationIndex, versions, version) {\n    return isVersionQueryInline(generationIndex, versions, version);\n  },\n  findInLeaf(_config, generationIndex, versions, version) {\n    return findLeafVersionIndexByLowerBound(generationIndex, versions, version);\n  },\n  findInInterior(config, generationIndex, versionNodes, version) {\n    const index = findVersionNodeIndexByLowerBound(\n      config.versionTreeArityLog2,\n      generationIndex,\n      versionNodes,\n      version,\n    );\n    return versionNodes[index];\n  },\n});\n\nconst findVersionUpperBoundImpl = findVersionImpl<VersionQuery>({\n  isInline(_config, generationIndex, versions, version) {\n    return isVersionQueryInline(generationIndex, versions, version);\n  },\n  findInLeaf(_config, generationIndex, versions, version) {\n    return findLeafVersionIndexByLowerBound(generationIndex, versions, version);\n  },\n  findInInterior(_config, generationIndex, versionNodes, version) {\n    const index = findVersionNodeIndexByUpperBound(\n      generationIndex,\n      versionNodes,\n      version,\n    );\n    return versionNodes[index];\n  },\n});\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/kvstore/proxy.js\";\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type {\n  DriverListOptions,\n  DriverReadOptions,\n  KvStore,\n  ListResponse,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport type { Key } from \"#src/kvstore/ocdbt/key.js\";\nimport { listRoot } from \"#src/kvstore/ocdbt/list.js\";\nimport {\n  findEntryInRoot,\n  readFromLeafNodeEntry,\n} from \"#src/kvstore/ocdbt/read.js\";\nimport { getRoot } from \"#src/kvstore/ocdbt/read_version.js\";\nimport { getOcdbtUrl } from \"#src/kvstore/ocdbt/url.js\";\nimport { type VersionSpecifier } from \"#src/kvstore/ocdbt/version_specifier.js\";\nimport type { BtreeGenerationReference } from \"#src/kvstore/ocdbt/version_tree.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nexport class OcdbtKvStore implements KvStore {\n  constructor(\n    public sharedKvStoreContext: SharedKvStoreContextCounterpart,\n    public baseUrl: string,\n    public version: VersionSpecifier | undefined,\n  ) {}\n\n  private root: BtreeGenerationReference | undefined;\n\n  private async getRoot(options: Partial<ProgressOptions>) {\n    let { root } = this;\n    if (root === undefined) {\n      root = this.root = await getRoot(\n        this.sharedKvStoreContext,\n        this.baseUrl,\n        this.version,\n        options,\n      );\n    }\n    return root;\n  }\n\n  getUrl(key: string) {\n    return getOcdbtUrl(this, key);\n  }\n\n  async stat(\n    key: string,\n    options: StatOptions,\n  ): Promise<StatResponse | undefined> {\n    const root = await this.getRoot(options);\n    const encodedKey = new TextEncoder().encode(key) as Key;\n    const entry = await findEntryInRoot(\n      this.sharedKvStoreContext,\n      root,\n      encodedKey,\n      options,\n    );\n    if (entry === undefined) return undefined;\n    const { value } = entry;\n    const totalSize = Number(value.length);\n    return { totalSize };\n  }\n\n  async read(\n    key: string,\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const root = await this.getRoot(options);\n    const encodedKey = new TextEncoder().encode(key) as Key;\n    const entry = await findEntryInRoot(\n      this.sharedKvStoreContext,\n      root,\n      encodedKey,\n      options,\n    );\n    if (entry === undefined) return undefined;\n    return await readFromLeafNodeEntry(\n      this.sharedKvStoreContext,\n      entry,\n      options,\n    );\n  }\n\n  async list(\n    prefix: string,\n    options: DriverListOptions,\n  ): Promise<ListResponse> {\n    const root = await this.getRoot(options);\n    const encodedPrefix = new TextEncoder().encode(prefix) as Key;\n    return await listRoot(\n      this.sharedKvStoreContext,\n      root,\n      encodedPrefix,\n      options,\n    );\n  }\n\n  get supportsOffsetReads() {\n    return true;\n  }\n  get supportsSuffixReads() {\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { ManifestWithVersionTree } from \"#src/kvstore/ocdbt/manifest.js\";\nimport { getVersionTreeNode } from \"#src/kvstore/ocdbt/metadata_cache.js\";\nimport type {\n  BtreeGenerationReference,\n  GenerationIndex,\n  VersionNodeReference,\n  VersionQuery,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport {\n  findLeafVersionIndexByLowerBound,\n  findVersionNodeIndexByLowerBound,\n  findVersionNodeIndexByUpperBound,\n  validateVersionTreeNodeReference,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport { bigintCompare } from \"#src/util/bigint.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nconst DEBUG = false;\n\nexport interface ListVersionsOptions extends Partial<ProgressOptions> {\n  inclusiveMin?: VersionQuery;\n  exclusiveMax?: VersionQuery;\n}\n\nexport async function listVersions(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  options: ListVersionsOptions,\n): Promise<{\n  generationIndex: GenerationIndex;\n  versions: BtreeGenerationReference[];\n}> {\n  const { inclusiveMin, exclusiveMax } = options;\n  if (DEBUG) {\n    console.log(\"listVersions\", inclusiveMin, exclusiveMax);\n  }\n  const resolvedInclusiveMin: VersionQuery =\n    inclusiveMin === undefined ? { generationIndex: 0n } : inclusiveMin;\n  const resolvedExclusiveMax: VersionQuery =\n    exclusiveMax === undefined\n      ? { generationIndex: manifest.versionTree.numGenerations }\n      : exclusiveMax;\n  const { config, versionTree } = manifest;\n  const { versionTreeArityLog2 } = config;\n  let minGenerationIndex: GenerationIndex | undefined;\n  const results: BtreeGenerationReference[] = [];\n  {\n    const generationIndex =\n      versionTree.versionTreeNodes.at(-1)?.cumulativeNumGenerations ?? 0n;\n    visitLeafEntries(generationIndex, versionTree.inlineVersions);\n    await visitInteriorEntries(0n, versionTree.versionTreeNodes);\n  }\n\n  function visitLeafEntries(\n    generationIndex: GenerationIndex,\n    versions: BtreeGenerationReference[],\n  ) {\n    const lower = findLeafVersionIndexByLowerBound(\n      generationIndex,\n      versions,\n      resolvedInclusiveMin,\n    );\n    const upper = findLeafVersionIndexByLowerBound(\n      generationIndex,\n      versions,\n      resolvedExclusiveMax,\n    );\n    const resultGenerationIndex = generationIndex + BigInt(lower);\n    if (\n      minGenerationIndex === undefined ||\n      resultGenerationIndex < minGenerationIndex\n    ) {\n      minGenerationIndex = resultGenerationIndex;\n    }\n    for (let i = lower; i < upper; ++i) {\n      results.push(versions[i]);\n    }\n  }\n\n  async function visitInteriorEntries(\n    generationIndex: GenerationIndex,\n    versionNodes: VersionNodeReference[],\n  ): Promise<void> {\n    options.signal?.throwIfAborted();\n    const lower = findVersionNodeIndexByLowerBound(\n      versionTreeArityLog2,\n      generationIndex,\n      versionNodes,\n      resolvedInclusiveMin,\n    );\n    const upper = findVersionNodeIndexByUpperBound(\n      generationIndex,\n      versionNodes,\n      resolvedExclusiveMax,\n    );\n    if (DEBUG) {\n      console.log(\n        \"listVersions: visitInteriorEntries\",\n        resolvedInclusiveMin,\n        resolvedExclusiveMax,\n        `generationIndex=${generationIndex}`,\n        `versionNodes.length=${versionNodes.length}`,\n        lower,\n        upper,\n      );\n    }\n    const promises: Promise<void>[] = [];\n    for (let i = lower; i < upper; ++i) {\n      const ref = versionNodes[i];\n      promises.push(\n        visitNodeRef(\n          generationIndex + ref.cumulativeNumGenerations - ref.numGenerations,\n          ref,\n        ),\n      );\n    }\n    await Promise.all(promises);\n  }\n\n  async function visitNodeRef(\n    generationIndex: GenerationIndex,\n    ref: VersionNodeReference,\n  ): Promise<void> {\n    const node = await getVersionTreeNode(\n      sharedKvStoreContext,\n      ref.location,\n      options,\n    );\n    validateVersionTreeNodeReference(\n      node,\n      config,\n      ref.generationNumber,\n      ref.height,\n      ref.numGenerations,\n    );\n    if (node.height === 0) {\n      visitLeafEntries(\n        generationIndex,\n        node.entries as BtreeGenerationReference[],\n      );\n    } else {\n      await visitInteriorEntries(\n        generationIndex,\n        node.entries as VersionNodeReference[],\n      );\n    }\n  }\n  results.sort((a, b) => bigintCompare(a.generationNumber, b.generationNumber));\n  return { generationIndex: minGenerationIndex ?? 0n, versions: results };\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type {\n  CompletionResult,\n  KvStoreAdapterCompleteUrlOptions,\n} from \"#src/kvstore/context.js\";\nimport { listVersions } from \"#src/kvstore/ocdbt/list_versions.js\";\nimport type { ManifestWithVersionTree } from \"#src/kvstore/ocdbt/manifest.js\";\nimport { getResolvedManifest } from \"#src/kvstore/ocdbt/metadata_cache.js\";\nimport {\n  findVersionIndexByLowerBound,\n  findVersionIndexByUpperBound,\n} from \"#src/kvstore/ocdbt/read_version.js\";\nimport {\n  formatCommitTime,\n  parseCommitTimePrefix,\n  parseVersion,\n} from \"#src/kvstore/ocdbt/version_specifier.js\";\nimport type {\n  BtreeGenerationReference,\n  GenerationIndex,\n} from \"#src/kvstore/ocdbt/version_tree.js\";\nimport { ensurePathIsDirectory } from \"#src/kvstore/url.js\";\nimport type { ProgressOptions } from \"#src/util/progress_listener.js\";\n\nasync function listVersionsLimited(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  manifest: ManifestWithVersionTree,\n  minGenerationIndex: GenerationIndex,\n  maxGenerationIndex: GenerationIndex,\n  limit: GenerationIndex,\n  options: Partial<ProgressOptions>,\n): Promise<BtreeGenerationReference[]> {\n  if (maxGenerationIndex <= minGenerationIndex + limit) {\n    const { versions } = await listVersions(sharedKvStoreContext, manifest, {\n      inclusiveMin: { generationIndex: minGenerationIndex },\n      exclusiveMax: { generationIndex: maxGenerationIndex },\n      ...options,\n    });\n    return versions;\n  }\n\n  const [{ versions: lowerVersions }, { versions: upperVersions }] =\n    await Promise.all(\n      [minGenerationIndex, maxGenerationIndex - limit / 2n].map(\n        (generationIndex) =>\n          listVersions(sharedKvStoreContext, manifest, {\n            inclusiveMin: { generationIndex },\n            exclusiveMax: { generationIndex: generationIndex + limit / 2n },\n            ...options,\n          }),\n      ),\n    );\n\n  return [...lowerVersions, ...upperVersions];\n}\n\nexport async function completeOcdbtUrl(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n  options: KvStoreAdapterCompleteUrlOptions,\n): Promise<CompletionResult | undefined> {\n  const { url } = options;\n  const suffix = url.suffix ?? \"\";\n  if (suffix === \"\") {\n    return {\n      offset: 0,\n      completions: [{ value: \"@\", description: \"Version specifier\" }],\n    };\n  }\n  const m = suffix.match(/^@([^/]*)((?:\\/|$).*)/);\n  if (m === null) return undefined;\n  const [, version, rest] = m;\n  if (rest !== \"\") {\n    parseVersion(version);\n    return undefined;\n  }\n\n  const { base } = options;\n  const baseUrl = base.store.getUrl(ensurePathIsDirectory(base.path));\n  if (!version.startsWith(\"v\")) {\n    const [inclusiveMin, inclusiveMax] = parseCommitTimePrefix(version);\n    const progressOptions = {\n      signal: options.signal,\n      progressListener: options.progressListener,\n    };\n    const manifest = await getResolvedManifest(\n      sharedKvStoreContext,\n      baseUrl,\n      progressOptions,\n    );\n    const [minVersion, maxVersion] = await Promise.all([\n      findVersionIndexByLowerBound(\n        sharedKvStoreContext,\n        manifest,\n        { commitTime: inclusiveMin },\n        progressOptions,\n      ),\n      findVersionIndexByUpperBound(\n        sharedKvStoreContext,\n        manifest,\n        { commitTime: inclusiveMax + 1n },\n        progressOptions,\n      ),\n    ]);\n    const versions = await listVersionsLimited(\n      sharedKvStoreContext,\n      manifest,\n      minVersion,\n      maxVersion,\n      100n,\n      {\n        signal: options.signal,\n        progressListener: options.progressListener,\n      },\n    );\n    const completions = versions.map((version) => ({\n      value: `${formatCommitTime(version.commitTime)}/`,\n      description: `v${version.generationNumber}`,\n    }));\n    completions.reverse();\n    return { offset: 1, completions };\n  }\n  if (version === \"v\") {\n    const { base } = options;\n    const manifest = await getResolvedManifest(\n      sharedKvStoreContext,\n      base.store.getUrl(base.path),\n      options,\n    );\n    const completions = manifest.versionTree.inlineVersions.map((ref) => ({\n      value: `v${ref.generationNumber}/`,\n      description: formatCommitTime(ref.commitTime),\n    }));\n    completions.reverse();\n    return { offset: 1, completions };\n  }\n  return { offset: 1, completions: [{ value: `${version}/` }] };\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport type { KvStoreAdapterProvider } from \"#src/kvstore/context.js\";\nimport { OcdbtKvStore } from \"#src/kvstore/ocdbt/backend.js\";\nimport { completeOcdbtUrl } from \"#src/kvstore/ocdbt/complete_url.js\";\nimport { parseOcdbtUrl } from \"#src/kvstore/ocdbt/url.js\";\n\nfunction ocdbtProvider(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n): KvStoreAdapterProvider {\n  return {\n    scheme: \"ocdbt\",\n    description: \"OCDBT database\",\n    getKvStore(parsedUrl, base) {\n      const { baseUrl, version, path } = parseOcdbtUrl(parsedUrl, base);\n      return {\n        store: new OcdbtKvStore(sharedKvStoreContext, baseUrl, version),\n        path,\n      };\n    },\n\n    completeUrl(options) {\n      return completeOcdbtUrl(sharedKvStoreContext, options);\n    },\n  };\n}\n\nbackendOnlyKvStoreProviderRegistry.registerKvStoreAdapterProvider(\n  ocdbtProvider,\n);\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport type { DriverListOptions, ListResponse } from \"#src/kvstore/index.js\";\nimport { proxyList } from \"#src/kvstore/proxy.js\";\nimport { ReadableS3KvStore } from \"#src/kvstore/s3/common.js\";\n\nexport class S3KvStore extends ReadableS3KvStore<SharedKvStoreContextCounterpart> {\n  list(prefix: string, options: DriverListOptions): Promise<ListResponse> {\n    return proxyList(this.sharedKvStoreContext, this.getUrl(prefix), options);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport { S3KvStore } from \"#src/kvstore/s3/backend.js\";\nimport { registerProviders } from \"#src/kvstore/s3/common.js\";\n\nregisterProviders(backendOnlyKvStoreProviderRegistry, S3KvStore);\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"#src/kvstore/proxy.js\";\nimport type { ChunkManager } from \"#src/chunk_manager/backend.js\";\nimport { makeSimpleAsyncCache } from \"#src/chunk_manager/generic_file_source.js\";\nimport { FileByteRangeHandle } from \"#src/kvstore/byte_range/file_handle.js\";\nimport { GzipFileHandle } from \"#src/kvstore/gzip/file_handle.js\";\nimport type {\n  DriverListOptions,\n  DriverReadOptions,\n  FileHandle,\n  KvStore,\n  ListEntry,\n  ListResponse,\n  ReadResponse,\n  StatOptions,\n  StatResponse,\n} from \"#src/kvstore/index.js\";\nimport { readFileHandle } from \"#src/kvstore/index.js\";\nimport { encodePathForUrl } from \"#src/kvstore/url.js\";\nimport type {\n  ZipMetadata,\n  Reader,\n  ZipEntry,\n} from \"#src/kvstore/zip/metadata.js\";\nimport {\n  readZipMetadata,\n  readEntryDataHeader,\n  ZipCompressionMethod,\n} from \"#src/kvstore/zip/metadata.js\";\nimport {\n  binarySearch,\n  binarySearchLowerBound,\n  filterArrayInplace,\n} from \"#src/util/array.js\";\nimport {\n  ProgressSpan,\n  type ProgressOptions,\n} from \"#src/util/progress_listener.js\";\nimport { defaultStringCompare } from \"#src/util/string.js\";\n\nfunction makeZipReader(base: FileHandle): Reader {\n  return async (\n    offset: number,\n    length: number,\n    options: Partial<ProgressOptions>,\n  ) => {\n    const readResponse = await readFileHandle(base, {\n      throwIfMissing: true,\n      byteRange: { offset, length },\n      strictByteRange: true,\n      signal: options.signal,\n      progressListener: options.progressListener,\n    });\n    return new Uint8Array(await readResponse.response.arrayBuffer());\n  };\n}\n\ninterface CachedZipEntry extends ZipEntry {\n  fileDataStart?: number;\n}\n\ninterface CachedZipMetadata extends ZipMetadata {\n  entries: CachedZipEntry[];\n}\n\nfunction getZipMetadataCache(chunkManager: ChunkManager, base: FileHandle) {\n  const url = base.getUrl();\n  return makeSimpleAsyncCache(chunkManager, `zipMetadata:${url}`, {\n    get: async (_unusedCacheKey: undefined, progressOptions) => {\n      using _span = new ProgressSpan(progressOptions.progressListener, {\n        message: `Reading ZIP central directory from ${url}`,\n      });\n      const statResponse = await base.stat(progressOptions);\n      if (statResponse?.totalSize === undefined) {\n        throw new Error(`Failed to determine ZIP file size: ${url}`);\n      }\n      const metadata = await readZipMetadata(\n        makeZipReader(base),\n        statResponse.totalSize,\n        progressOptions,\n      );\n      // Zip files sometimes contain zero-length files corresponding to\n      // directories.\n      filterArrayInplace(\n        metadata.entries,\n        (entry) => !entry.fileName.endsWith(\"/\"),\n      );\n      metadata.entries.sort((a, b) =>\n        defaultStringCompare(a.fileName, b.fileName),\n      );\n      return { data: metadata, size: metadata.sizeEstimate };\n    },\n  });\n}\n\nasync function getZipMetadata(\n  chunkManager: ChunkManager,\n  base: FileHandle,\n  options: Partial<ProgressOptions>,\n): Promise<CachedZipMetadata> {\n  const cache = getZipMetadataCache(chunkManager, base);\n  try {\n    return (await cache.get(undefined, options)) as CachedZipMetadata;\n  } finally {\n    cache.dispose();\n  }\n}\n\nfunction findEntry(\n  metadata: CachedZipMetadata,\n  key: string,\n): CachedZipEntry | undefined {\n  const { entries } = metadata;\n  const index = binarySearch(entries, key, (key, entry) =>\n    defaultStringCompare(key, entry.fileName),\n  );\n  if (index < 0) return undefined;\n  return entries[index];\n}\n\nfunction list(metadata: ZipMetadata, prefix: string) {\n  const { entries } = metadata;\n  const startIndex = binarySearchLowerBound(\n    0,\n    entries.length,\n    (index) => entries[index].fileName >= prefix,\n  );\n\n  const endIndex = binarySearchLowerBound(\n    Math.min(entries.length, startIndex + 1),\n    entries.length,\n    (index) => !entries[index].fileName.startsWith(prefix),\n  );\n\n  const listEntries: ListEntry[] = [];\n  const directories: string[] = [];\n\n  for (let index = startIndex; index < endIndex; ) {\n    const entry = entries[index];\n    const i = entry.fileName.indexOf(\"/\", prefix.length);\n    if (i === -1) {\n      // Filename\n      listEntries.push({ key: entry.fileName });\n      ++index;\n    } else {\n      // Directory\n      directories.push(entry.fileName.substring(0, i));\n      const directoryPrefix = entry.fileName.substring(0, i + 1);\n      index = binarySearchLowerBound(\n        index + 1,\n        endIndex,\n        (index) => !entries[index].fileName.startsWith(directoryPrefix),\n      );\n    }\n  }\n\n  return { entries: listEntries, directories };\n}\n\nexport class ZipKvStore<BaseFileHandle extends FileHandle = FileHandle>\n  implements KvStore\n{\n  constructor(\n    public chunkManager: ChunkManager,\n    public base: BaseFileHandle,\n  ) {}\n\n  private metadata: ZipMetadata | undefined;\n\n  private async getMetadata(options: Partial<ProgressOptions>) {\n    let { metadata } = this;\n    if (metadata === undefined) {\n      metadata = this.metadata = await getZipMetadata(\n        this.chunkManager,\n        this.base,\n        options,\n      );\n    }\n    return metadata;\n  }\n\n  getUrl(key: string) {\n    return this.base.getUrl() + `|zip:${encodePathForUrl(key)}`;\n  }\n\n  async stat(\n    key: string,\n    options: StatOptions,\n  ): Promise<StatResponse | undefined> {\n    const entry = findEntry(await this.getMetadata(options), key);\n    if (entry === undefined) return undefined;\n    return { totalSize: entry.uncompressedSize };\n  }\n\n  async read(\n    key: string,\n    options: DriverReadOptions,\n  ): Promise<ReadResponse | undefined> {\n    const entry = findEntry(await this.getMetadata(options), key);\n    if (entry === undefined) return undefined;\n    let { fileDataStart } = entry;\n    if (fileDataStart === undefined) {\n      fileDataStart = entry.fileDataStart = await readEntryDataHeader(\n        makeZipReader(this.base),\n        entry,\n        options,\n      );\n    }\n    let handle: FileHandle = new FileByteRangeHandle(this.base, {\n      offset: fileDataStart,\n      length: entry.compressedSize,\n    });\n    switch (entry.compressionMethod) {\n      case ZipCompressionMethod.STORE:\n        break;\n      case ZipCompressionMethod.DEFLATE:\n        handle = new GzipFileHandle(handle, \"deflate-raw\");\n        break;\n      default:\n        throw new Error(\n          `Unsupported compression method: ${entry.compressionMethod}`,\n        );\n    }\n    return handle.read(options);\n  }\n\n  async list(\n    prefix: string,\n    options: DriverListOptions,\n  ): Promise<ListResponse> {\n    const metadata = await this.getMetadata(options);\n    return list(metadata, prefix);\n  }\n\n  get supportsOffsetReads() {\n    return true;\n  }\n  get supportsSuffixReads() {\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedKvStoreContextCounterpart } from \"#src/kvstore/backend.js\";\nimport { backendOnlyKvStoreProviderRegistry } from \"#src/kvstore/backend.js\";\nimport type { KvStoreAdapterProvider } from \"#src/kvstore/context.js\";\nimport { KvStoreFileHandle } from \"#src/kvstore/index.js\";\nimport { ensureNoQueryOrFragmentParameters } from \"#src/kvstore/url.js\";\nimport { ZipKvStore } from \"#src/kvstore/zip/backend.js\";\n\nfunction zipProvider(\n  sharedKvStoreContext: SharedKvStoreContextCounterpart,\n): KvStoreAdapterProvider {\n  return {\n    scheme: \"zip\",\n    description: \"ZIP archive\",\n    getKvStore(parsedUrl, base) {\n      ensureNoQueryOrFragmentParameters(parsedUrl);\n      return {\n        store: new ZipKvStore(\n          sharedKvStoreContext.chunkManager,\n          new KvStoreFileHandle(base.store, base.path),\n        ),\n        path: decodeURIComponent(parsedUrl.suffix ?? \"\"),\n      };\n    },\n  };\n}\n\nbackendOnlyKvStoreProviderRegistry.registerKvStoreAdapterProvider(zipProvider);\n","/**\n * @license\n * Copyright 2016 Google Inc.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RPC } from \"#src/worker_rpc.js\";\n\nexport const rpc = new RPC(self, /*waitUntilReady=*/ false);\nrpc.sendReady();\n(globalThis as any).rpc = rpc;\n"],"names":["composeMatchFunctions","specs","options","matches","result","Promise","spec","AutoDetectRegistry","undefined","registry","composeAutoDetectDirectorySpecs","fileNames","Set","subDirectories","curFileNames","curSubDirectories","fileName","subDirectory","fileSpecs","composeAutoDetectFileSpecs","prefixLength","suffixLength","Math","composeByteRangeRequest","outer","inner","length","Error","JSON","handleByteRangeRequestFromUint8Array","value","byteRange","offset","Response","FileByteRangeHandle","base","outerByteRange","innerByteRange","Uint8Array","response","readFileHandle","getRangeHeader","request","byteRangeCacheMode","navigator","wasRedirectedToDirectoryListing","url","URL","parse206ContentRangeHeader","contentRange","totalSize","m","parseInt","endPos","read","store","key","fetchOkImpl","fetchOk","resolvedByteRange","rangeHeader","byteRangeRequest","statResponse","stat","requestInit","getBodyLength","e","HttpError","handleThrowIfMissing","headers","contentLength","contentEncoding","size","Number","error","isNotFoundError","NotFoundError","KvStoreFileHandle","handle","readKvStore","listKvStore","kvStore","prefix","transformListResponse","responseKeys","entry","normalizeListResponse","a","b","defaultStringCompare","formatVersion","version","commitTime","formatCommitTime","parseVersion","versionString","generationString","generationNumber","BigInt","parseCommitTime","commitTimeString","commitTimeFractionalSeconds","commitTimeFromSecondsAndSubseconds","Date","seconds","subseconds","fraction","fractionalSeconds","timestampString","COMMIT_TIME_PREFIX_REGEXP","RegExp","getMinMaxDateComponent","componentName","digits","inclusiveMinBound","inclusiveMaxBound","min","max","parseCommitTimePrefix","year","month","daysInMaxMonth","getDaysInMonth","d","day","hour","minute","second","subsecondString","z","minSubseconds","maxSubseconds","getDate","i","date","EXPECTED_XML_NAMESPACE_URIS","getS3BucketListing","bucketUrl","encodeURIComponent","contentType","text","doc","DOMParser","documentElement","namespaceURI","namespaceResolver","commonPrefixNodes","XPathResult","directories","n","name","decodeURIComponent","entries","contents","getVirtualHostedStyleListing","baseUrl","path","getBaseHttpUrlAndPath","getPathStyleListing","parsed","parsePathStyleUrl","u","bucket","bucketPrefix","encodePathForUrl","listS3CompatibleUrl","origin","memoize","cache","Map","urlKind","finalPipelineUrlComponent","schemePattern","parsePipelineUrlComponent","scheme","suffix","splitPipelineUrl","pipelineUrlJoin","additionalParts","queryAndFragment","part","kvstoreEnsureDirectoryPipelineUrl","pipelinePrefix","joinPath","ensurePathIsDirectory","ensureNoQueryOrFragmentParameters","ensureEmptyUrlSuffix","resolveRelativePath","basePath","relativePath","origBasePath","component","prevSlash","encodeURI","c","joinBaseUrlAndPath","extractQueryAndFragment","VisibleSegmentEquivalencePolicy","WatchableValue","newValue","value_","NullarySignal","TrackableValue","validator","defaultValue","x","registerNested","f","watchables","values","w","count","context","RefCounted","handleChange","debounce","changed","watchable","signalDisposers","invokeDisposers","scopedAbortCallback","signal","callback","wrappedCallback","Symbol","SharedAbortController","AbortController","self","promiseWithResolversAndAbortCallback","abortCallback","promise","resolve","reject","cleanup","reason","raceWithAbort","bigintCompare","randomUint64","high","UINT64_MAX","disposers","disposer","index","target","type","listener","cancellable","RefCountedValue","mat4","vec3","kZeroVec","vec4","kOneVec","kInfinityVec","Infinity","prod3","vec3Key","transformVectorByMat4","out","y","transformVectorByMat4Transpose","translationRotationScaleZReflectionToMat4","translation","rotation","scale","zReflection","mat3FromMat4","m00","m01","m02","m10","m11","m12","m20","m21","m22","getFrustrumPlanes","m30","m31","m32","m03","m13","m23","m33","nearA","nearB","nearC","farA","farB","farC","nearNorm","nearD","farNorm","farD","isAABBVisible","xLower","yLower","zLower","xUpper","yUpper","zUpper","clippingPlanes","sum","isAABBIntersectingPlane","maxSum","epsilon","minSum","getViewFrustrumVolume","projectionMat","depth","width","near","baseArea","getViewFrustrumDepthRange","far","quat","isGzipFormat","data","view","decodeGzip","format","decompressedStream","decodeGzipStream","DecompressionStream","stableStringify","Array","s","keys","Object","verifyFloat","obj","t","parseFloat","verifyFiniteFloat","verifyFiniteNonNegativeFloat","verifyFinitePositiveFloat","parseFiniteVec","SINGLE_QUOTE_STRING_PATTERN","DOUBLE_QUOTE_STRING_PATTERN","SINGLE_OR_DOUBLE_QUOTE_STRING_PATTERN","DOUBLE_QUOTE_PATTERN","pythonLiteralParse","pythonLiteralToJSON","before","replacement","singleQuoteString","convertStringLiteral","quoteInitial","quoteReplace","quoteSearch","expectArray","parseArray","parseElement","parseFixedLengthArray","verifyObject","verifyInt","verifyString","verifyOptionalString","verifyObjectProperty","propertyName","parseError","verifyOptionalObjectProperty","verifyFloat01","verifyEnumString","enumType","pattern","objUpperCase","verifyStringArray","verifyIntegerArray","verifyBoolean","parseUint64","pivots","createIdentity","rows","cols","identity","lda","start","inverse","ldb","copy","col","aOff","bOff","row","inverseInplace","determinant","Uint32Array","k","kColOff","pivotRow","bestPivot","mag","off","temp","tempPivot","pivotValue","pivotInv","j","factor","jColOff","targetCol","colOff","targetColOff","off1","off2","ProgressSpan","id","startTime","message","MultiSet","item","items","KeyedMultiSet","getKey","getId","span","ProgressSpanSet","MultiConsumerProgressListener","spanId","getRandomHexString","numBits","numValues","crypto","getRandomValues","array","byteArray","Signal","handler","arguments","handlers","onceWrapper","args","wasmModule","dracoModulePromise","decodeResult","ChunkState","ChunkPriorityTier","ChunkDownloadStatistics","ChunkMemoryStatistics","NavigationLinkType","NavigationSimpleLinkType","VelocityBoundaryBehavior","DataType","Endianness","AnnotationType","NiftiDataType","factory","ShardIndexLocation","resolver","CompressionMethod","ZipCompressionMethod","IS_WORKER","Window","PROMISE_RESPONSE_ID","PROMISE_CANCEL_ID","PROMISE_PROGRESS_ADD_SPAN_ID","PROMISE_PROGRESS_REMOVE_SPAN_ID","READY_ID","registerRPC","ProxyProgressListener","rpc","registerPromiseRPC","progressListener","abortController","transfers","INITIAL_RPC_ID","SharedObject","rpcId","generation","initializeSharedObjectCounterpart","SharedObjectCounterpart","sharedObjectConstructors","registerSharedObject","identifier","constructorFunction","typeName","CHANGED_RPC_METHOD_ID","SharedWatchableValue","makePairingHeapOperations","CHILD","NEXT","PREV","compare","combineChildren","node","cur","head","next","curNext","meld","root","aChild","removeMin","newRoot","child","remove","prev","removedEntries","nextMarkGeneration","Chunk","msg","_transfers","newState","oldState","bytes","updateChunkStatistics","ChunkSourceBase","chunkManager","Float64Array","numChunkStates","numChunkStatistics","chunkType","freeChunks","freeChunksLength","chunk","chunks","keyListeners","idx","listeners","sign","statistics","systemMemoryBytes","gpuMemoryBytes","ChunkSource","cancelChunkDownload","controller","DOMException","ChunkPriorityQueue","heapOperations","linkedListOperations","priorityTier","heapRoots","recentHead","tier","linkedList0","makeLinkedListOperations","linkedList1","makeChunkPriorityQueue1","tryToFreeCapacity","capacity","priority","evictionCandidates","evict","evictionCandidate","evictionTier","AvailableCapacity","itemLimit","sizeLimit","ChunkQueueManager","getCapacity","setTimeout","add","queue","source","queueManager","evictFromGPUMemory","promotionCandidates","promotionCandidate","promotionLambda","systemMemoryEvictionCandidates","systemMemoryCapacity","promotionCandidateResult","startChunkDownload","downloadAbortController","endTime","console","sourceQueueLevel","gpuMemoryGeneration","ChunkRenderLayerBackend","ChunkManager","StringMemoize","throttle","layer","requestedState","newPriorityTier","tiers","existingTierChunks","newTierChunks","WithParameters","Base","parametersConstructor","C","withChunkManager","results","CredentialsProvider","makeCachedCredentialsGetter","getUncached","cachedCredentials","pendingCredentials","invalidCredentials","asyncMemoizeWithProgress","progressOptions","CachingCredentialsManager","parameters","SharedCredentialsProviderCounterpart","CREDENTIALS_PROVIDER_GET_RPC_ID","WithSharedCredentialsProviderCounterpart","ProxyCredentialsProvider","managerId","CREDENTIALS_MANAGER_GET_RPC_ID","SharedCredentialsManagerCounterpart","SharedKvStoreContextCounterpart","KvStoreContext","frontendBackendIsomorphicKvStoreProviderRegistry","backendOnlyKvStoreProviderRegistry","KvStoreProviderRegistry","WithSharedKvStoreContextCounterpart","RenderLayerBackendAttachment","RenderLayerBackend","attachment","RENDERED_VIEW_ADD_LAYER_RPC_ID","RENDERED_VIEW_REMOVE_LAYER_RPC_ID","SharedProjectionParametersBackend","binarySearch","haystack","needle","low","mid","compareResult","binarySearchLowerBound","begin","end","predicate","step","arraysEqual","length1","PROJECTION_PARAMETERS_CHANGED_RPC_METHOD_ID","oldValue","allSiPrefixes","siPrefixesWithAlternatives","supportedUnits","exponentToPrefix","exponent","unit","kEmptyFloat32Vec","Float32Array","kEmptyFloat64Vec","makeCoordinateSpace","space","names","units","scales","valid","rank","timestamps","ids","_","boundingBoxes","coordinateArrays","bounds","computeCombinedBounds","outputRank","lowerBounds","upperBounds","halfIntegerBounds","integerBounds","boundingBox","outputDim","computeCombinedLowerUpperBound","outputDimension","baseLowerBounds","baseUpperBounds","transform","inputRank","stride","targetLower","targetUpper","hasCoefficient","inputDim","lower","upper","lowerRound","upperRound","lowerFloor","upperFloor","voxelCenterAtIntegerCoordinates","integerCount","halfIntegerCount","emptyInvalidCoordinateSpace","vector","getCenterBound","isValidDimensionName","allowNumericalNames","WeakMap","TrackableEnum","DimensionPlaybackVelocity","dimensionVelocityFromJson","OrientationState","orientation","q","mat","mat3","usedAxes","maxComponent","argmaxComponent","peer","peerToSelf","updatingPeer","updatingSelf","selfToPeer","other","validateDisplayDimensionRenderInfoProperty","expected","actual","RenderViewport","DATA_TYPE_BYTES","DATA_TYPE_ARRAY_CONSTRUCTOR","Int8Array","Uint16Array","Int16Array","Int32Array","BigUint64Array","makeDataTypeArrayView","dataType","buffer","byteOffset","byteLength","bytesPerElement","tempMat4","updateFixedCurPositionInChunks","tsource","globalPosition","localPosition","curPositionInChunks","fixedPositionWithinChunk","nonDisplayLowerClipBound","nonDisplayUpperClipBound","chunkDataSize","lowerChunkBound","upperChunkBound","getChunkPositionFromCombinedGlobalLocalPositions","chunkPosition","layerRank","combinedGlobalLocalToChunkTransform","globalRank","localRank","chunkDim","globalDim","localDim","chunkSize","tempChunkLayout","ChunkLayout","SliceViewBase","projectionParameters","visibleSourcesInvalidated","oldViewMatrix","newViewMatrix","curDisplayDimensionRenderInfo","visibleLayers","renderLayer","visibleLayerSources","allSources","visibleSources","preferredOrientationIndex","pickBestAlternativeSource","viewMatrix","alternatives","numAlternatives","bestAlternativeIndex","bestSliceArea","alternativeIndex","chunkLayout","sliceArea","estimateSliceAreaPerChunk","viewZProjection","chunkVolume","sources","tempVisibleVolumetricChunkLower","tempVisibleVolumetricChunkUpper","tempVisibleVolumetricModelViewProjection","tempVisibleVolumetricClippingPlanes","forEachVolumetricChunkWithinFrustrum","transformedSource","lowerChunkDisplayBound","upperChunkDisplayBound","chunkDisplayDimensionIndices","recurse","splitDim","splitSize","volume","prevLower","prevUpper","splitPoint","forEachVisibleVolumetricChunk","modelViewProjection","forEachPlaneIntersectingVolumetricChunk","invModelViewProjection","BIAS_EPSILON","xCoeff","yCoeff","upperBound","lowerValue","zCoeff","getNormalizedChunkLayout","finiteRank","invTransform","invViewMatrix","height","chunkRenderDim","xc","yc","zc","scaleFactor","VelocityEstimator","velocityHalfLifeMilliseconds","modelHalfLifeMilliseconds","position","time","numSamples","deltaT","velocityAlpha","modelAlpha","velocity","prevPosition","mean","variance","curVelocitySample","prevVelocity","newVelocity","meanPrev","varPrev","delta","withSharedVisibility","getPriorityTier","visibility","getBasePriority","tempChunkPosition","tempCenter","tempChunkSize","disposeTransformedSources","SliceViewIntermediateBase","SliceViewBackend","centerDataPosition","basePriority","curVisibleChunks","numVisibleSources","prefetchOffsets","getPrefetchChunkOffsets","velocityEstimator","offsets","chunkRank","meanVec","varianceVec","isDisplayDimension","meanValue","varianceValue","coeff","initialFraction","adjustedMean","adjustedStddevTimesSqrt2","cdf","erf","p","a5","curChunk","minChunk","maxChunk","groupStart","probability","newGroupStart","PREFETCH_ENTRY_SIZE","localCenter","sourceBasePriority","SCALE_PRIORITY_MULTIPLIER","curMarkGeneration","positionInChunks","visibleChunk","newPriority","jumpOffset","oldIndex","newIndex","layerInfo","displayDimensionRenderInfo","deserializeTransformedSources","serializedSources","serializedSource","SliceViewChunk","chunkGridPosition","SliceViewChunkSourceBackend","SliceViewRenderLayerBackend","sliceView","filterVisibleSources","prevVoxelSize","pixelSize","smallestVoxelSize","renderScaleTarget","canImproveOnVoxelSize","voxelSize","targetSize","improvesOnPrevVoxelSize","prevSize","scaleIndex","disposeRecompute","PerspectiveViewBackend","PerspectiveViewRenderLayerBackend","tempMat3","tempCenterDataPosition","VolumeRenderingRenderLayerBackend","scheduleUpdateChunkPriorities","state","transformedSources","displayDimensionIndices","displayDim","forEachVisibleVolumeRenderingChunk","volumeRenderingDepthSamples","beginScale","voxelPhysicalScales","canonicalToPhysicalScale","depthRange","targetViewVolume","targetViewSpacing","viewDet","histogramInformation","getViewVolume","bestScaleIndex","bestViewVolume","viewVolume","physicalSpacing","optimalSamples","firstChunk","priorityIndex","ANNOTATION_COMMIT_UPDATE_RESULT_RPC_ID","ADD_METHOD_ID","CLEAR_METHOD_ID","HIGH_BIT_REPRESENTATIVE_CHANGED_ID","DELETE_SET_METHOD_ID","SharedDisjointUint64Sets","DisjointUint64Sets","highBitRepresentative","updateHighBitRepresentative","pending","backupPending","HashTableBase","hashSeeds","initialSize","numHashes","emptySlots","mungedEmptyKey","chooseMungedEmptyKey","h","table","empty","hashIndex","hash","hashCombine","entryStride","newKey","attempt","maxAttempts","tableIndex","tableSize","oldTable","desiredTableSize","rehashAttempt","HashSetUint64","pendingValue","backupPendingValue","HashMapUint64","Uint64Map","Uint64Set","v","tmp","VISIBLE_SEGMENTS_STATE_PROPERTIES","onVisibleSegmentsStateChanged","onTemporaryVisibleSegmentsStateChanged","getObjectKey","objectId","forEachVisibleSegment","visibleSegments","segmentEquivalences","equivalencePolicy","rootObjectId","rootObjectId2","segmentId","receiveVisibleSegmentsState","property","withSegmentationLayerBackendState","AnnotationMetadataChunk","AnnotationGeometryData","GeometryChunkMixin","AnnotationGeometryChunk","AnnotationSubsetGeometryChunk","AnnotationMetadataChunkSource","AnnotationGeometryChunkSourceBackend","AnnotationSubsetGeometryChunkSource","AnnotationSource","metadataChunkSource","annotation","newAnnotation","annotationId","AnnotationSpatiallyIndexedRenderLayerBackend","attachmentState","forEachVisibleAnnotationChunk","viewFrustrumVolume","baseSource","sourceVolume","lowerClipDisplayBound","upperClipDisplayBound","effectiveVolume","viewportArea","physicalDensityTarget","targetNumAnnotations","totalPhysicalDensity","physicalVolume","limit","sliceFraction","newTotalPhysicalDensity","totalPhysicalSpacing","totalPixelSpacing","drawFraction","desiredCount","AnnotationLayerSharedObjectCounterpart","states","segmentFilteredSources","numRelationships","fetchWithBossCredentials","credentialsProvider","input","init","fetchOkWithCredentials","credentials","Headers","status","ENDIANNESS","swapEndian16","swapEndian32","swapEndian64","convertEndian32","convertEndian","elementBytes","encodeZIndexCompressed3d","xBits","yBits","zBits","maxBits","outputBit","zIndex","writeBit","bit","zorder3LessThan","x0","y0","z0","x1","y1","z1","mostSignificant0","mostSignificant1","ManifestChunk","serializeMeshData","vertexPositions","indices","vertexNormals","strips","vertexPositionsBuffer","indicesBuffer","getMeshDataSize","FragmentChunk","manifestChunk","fragmentId","decodeJsonManifestChunk","keysPropertyName","computeVertexNormals","positions","faceNormal","v1v0","v2v1","numIndices","i0","i1","i2","numVertices","vec","snorm8","decodeVertexPositionsAndIndices","verticesPerPrimitive","endianness","vertexByteOffset","indexByteOffset","numPrimitives","MeshSource","fragmentSource","objectKey","fragmentKey","parsedFragmentId","FragmentSource","MeshLayer","fragmentChunk","MultiscaleManifestChunk","MultiscaleFragmentChunk","subChunkOffsets","MultiscaleMeshSource","lod","chunkIndex","MultiscaleFragmentSource","tempModelMatrix","MultiscaleMeshLayer","maxVisibility","manifestChunks","get3dModelToDisplaySpaceMatrix","fullRank","globalToRenderLayerDimensions","modelToRenderLayerTransform","layerDim","modelDim","globalDimensionNames","displayDimDesc","detailCutoff","maxLod","getDesiredMultiscaleMeshChunks","manifest","viewportWidth","viewportHeight","octree","lodScales","chunkGridSpatialOrigin","chunkShape","minWXcoeff","minWYcoeff","minWZcoeff","minWClip","objectXLower","objectYLower","objectZLower","objectXUpper","objectYUpper","objectZUpper","handleChunk","priorLodScale","rowOffset","gridX","gridY","gridZ","childBegin","childEndAndEmpty","minW","lodScale","nextPriorLodScale","childEnd","childRow","_renderScale","convertMeshData","vertexPositionFormat","encodedIndices","encodedVertexPositions","normals","encodedNormals","encodeNormals32fx3ToOctahedron8x2","outIndex","invL1Norm","VertexPositionFormat","inputIndex","outputIndex","assignMeshFragmentData","assignMultiscaleMeshFragmentData","generateHigherOctreeLevel","priorStart","priorEnd","curEnd","encodeCompressedSegmentationUint32","encodeCompressedSegmentationUint64","numWorkers","freeWorkers","pendingTasks","tasks","maxWorkers","nextTaskId","returnWorker","worker","task","requestAsyncComputation","transfer","abortHandler","launchWorker","Worker","ready","callbacks","postProcessRawData","shape","supportedDataTypes","endiannessChar","typeChar","NumpyArray","fortranOrder","decodeBossNpzChunk","parseResult","parseNpy","headerObject","majorVersion","minorVersion","headerLength","dv","DataView","header","TextDecoder","dataOffset","dtype","numElements","dim","parseNumpyDtype","typestr","arrayConstructor","parsedDataType","decodeJpeg","decodeJpegChunk","decoded","computeChunkBounds","tempChunkDataSize","upperVoxelBound","baseVoxelOffset","origChunkDataSize","partial","newChunkDataSize","VolumeChunkSource","chunkDecoders","acceptHeaders","BossSource","BossVolumeChunkSource","VolumeChunkSourceParameters","BossMeshSource","MeshSourceParameters","decodeFragmentChunk","numTriangles","parseRGBAColorSpecification","document","parseColorSerialization","packColor","serializeColor","float32ToString","float64Buf","annotationTypes","annotationPropertyTypeHandlers","AnnotationPropertySerializer","firstGroupInitialOffset","propertySpecs","serializedBytes","propertyGroupBytes","getPropertyOffsets","numProperties","permutation","getAlignment","propertyGroupIndex","propertyGroupOffset","nextPropertyGroup","propertyIndex","numBytes","alignment","alignmentOffset","newEndOffset","newStartOffset","newAlignedEndOffset","groupOffsetCode","groupIndex","serializeCode","deserializeCode","group","propId","offsetExpr","Function","serializeFloatVector","isLittleEndian","serializeTwoFloatVectors","vecA","vecB","deserializeFloatVector","deserializeTwoFloatVectors","annotationTypeHandlers","pointA","pointB","point","center","radii","AnnotationSerializer","propertySerializers","serializeAnnotations","allAnnotations","totalBytes","typeToOffset","annotationType","serializedPropertiesBytes","propertySerializer","annotations","typeToIds","typeToIdMaps","ArrayBuffer","dataView","serializeProperties","serialize","geometryDataStride","makeRequest","instance","fetchOkWithOAuth2Credentials","SkeletonChunk","total","vertexAttributes","vertexData","vertexAttributeOffsets","SkeletonSource","SkeletonLayer","decodeSkeletonVertexPositionsAndIndices","numEdges","meshData","decodeCompressedSegmentationChunk","decodeRawChunk","expectedBytes","CHUNK_DECODERS","VolumeChunkEncoding","applyChangeStack","changeStack","payload","BrainmapsSource","BrainmapsVolumeChunkSource","VolumeSourceParameters","encoding","decodeBatchMeshResponse","objectIdString","fragmentKeyLength","fragmentKeyLengthHigh","fullKey","numVerticesHigh","numTrianglesHigh","endOffset","combineBatchMeshFragments","fragments","totalVertices","totalIndices","fragment","vertexBuffer","indexBuffer","vertexOffset","indexOffset","sourceIndices","makeBatchMeshRequest","prevObjectId","batches","batchSize","pendingIds","idData","splitIndex","BrainmapsMultiscaleMeshSource","MultiscaleMeshSourceParameters","changeSpec","decodeMultiscaleManifestChunk","clipLowerBound","clipUpperBound","fragmentKeys","supervoxelIds","fragmentSupervoxelIds","gridShape","fragmentIdAndCorners","zindex","maxCoordBits","inputBit","coordBit","minNumLods","minCoord","maxCoord","corner","lods","lodIndex","octreeTemp","numBaseChunks","startChunkIndex","endChunkIndex","relativeBlockShape","supervoxelId","prevLod","idArray","meshName","requestsInProgress","maybeIssueMoreRequests","numSubChunks","prevSubChunkIndex","subChunkIndex","getOctreeChildIndex","BrainmapsMeshSource","decodeManifestChunkWithSupervoxelIds","fragmentIds","groupFragmentsIntoBatches","BrainmapsSkeletonSource","SkeletonSourceParameters","decodeSkeletonChunk","numEdgesHigh","spatialAnnotationTypes","parseCommaSeparatedPoint","cornerParts","getIdPrefix","parseBrainmapsAnnotationId","idPrefix","fullId","parseObjectLabels","parseAnnotation","expectedId","description","spatialAnnotationType","segments","annotationPropertySerializers","makeAnnotationPropertySerializers","serializers","parseAnnotations","responses","serializer","responseIndex","annotationsArray","getSpatialAnnotationTypeFromId","toCommaSeparated","getFullSpatialAnnotationId","annotationToBrainmaps","objectLabels","minPoint","maxPoint","BrainmapsAnnotationGeometryChunkSource","AnnotationSpatialIndexSourceParameters","BrainmapsAnnotationSource","AnnotationSourceParameters","_relationshipIndex","brainmapsAnnotation","decodePng","DeepzoomImageTileSource","ImageTileSourceParameters","tiledata","tilesize","overlap","ox","oy","responseArray","tilewidth","tileheight","ImageTileEncoding","pngbitmap","transposeArray2d","majorSize","minorSize","transpose","jpegbitmap","t2","twh","DVIDInstance","nodeKey","dataName","startKey","endKey","appendQueryStringForDvid","user","fetchWithDVIDCredentials","newInit","PointObj","DVIDSource","DVIDSkeletonSource","bodyid","decodeSwcSkeletonChunk","swcStr","swcObjects","parseSwc","swcInputAr","swcObjectsAr","float","match","indexMap","nodeCount","edgeCount","swcObj","glVertices","glIndices","nodeIndex","edgetIndex","enc","DVIDMeshSource","meshUrl","dvidInstance","DVIDVolumeChunkSource","params","decoder","ChunkedGraphSourceParameters","isBaseSegmentId","nBitsForLayerId","layerId","parseGrapheneError","getHttpSource","kvStoreContext","ReadableHttpKvStore","OBJECT_ID_SYMBOL","nextObjectId","AsyncCacheChunk","SimpleAsyncCache","encodedKey","getCachedDecodedUrl","sharedKvStoreContext","decodeFunction","getObjectId","readResponse","murmurHash3_x86_128Mix","rotl32","r","shardingHashFunctions","ShardingHashFunction","h1","h2","h3","h4","k2","k1","decodeFileHandle","DataEncoding","GzipFileHandle","ShardedKvStore","sharding","shardAndMinishard","minishard","shard","shardPath","shardFileHandle","shardIndexSize","shardIndexDv","minishardStartOffset","minishardEndOffset","minishardIndexBuffer","minishardIndex","convertEndian64","minishardIndexSize","prevEntryKey","prevStart","entryKey","hashCode","hashFunction","minishardEntry","findMinishardEntry","minishardIndexData","startOffset","findResult","shardInfo","getShardedKvStoreIfApplicable","chunkSource","numPartitions","libraryEnv","memoryIndex","numFaces","indicesPointer","vertexPositionsPointer","subchunkOffsetsPointer","memory","code","getDracoModulePromise","WebAssembly","fetch","decodeDracoPartitioned","vertexQuantizationBits","partition","heap","decodeDraco","decodeCompresso","decodeCompressoChunk","image","decodeJxl","decodeJxlChunk","decodePngChunk","getOrNotFoundError","PrecomputedVolumeChunkSource","shardedKvStore","decodeManifestChunk","PrecomputedMeshSource","decodeMultiscaleFragmentChunk","PrecomputedMultiscaleMeshSource","gridOrigin","numStoredLods","storedLodScales","vertexOffsets","numFragmentsPerLod","totalFragments","fragmentInfo","numLods","fragmentBase","numFragments","upperBoundValue","lowerBoundValue","maxFragments","prevNumFragments","prevLodIndex","offsetsTemp","baseRow","dataSize","computeOctreeChildOffsets","childStart","parentEnd","childNode","parentNode","parentX","parentY","parentZ","childX","childY","childZ","lodScaleMultiplier","requestPath","adjustedStartOffset","adjustedEndOffset","fullDataSize","fetchByUint64","PrecomputedSkeletonSource","curOffset","attributes","info","bytesPerVertex","attribute","convertEndian16","countLow","countHigh","idOffset","geometryData","origData","origOffset","groupOffset","groupBytesPerAnnotation","annotationIndex","origBase","newBase","PrecomputedAnnotationSpatialIndexSourceBackend","parent","encodeZIndexCompressed","PrecomputedAnnotationSourceBackend","relationshipIndex","parseSingleAnnotation","baseNumBytes","minNumBytes","relatedSegments","decodeDracoFragmentChunk","GrapheneMeshSource","segment","newSegments","manifestRequestCount","manifestPath","requestCount","fragmentKvStore","downloadFragmentWithSharding","parts","getGrapheneFragmentKey","ChunkedGraphChunk","GrapheneChunkedGraphChunkSource","res","leaves","err","errorPrefix","ChunkedGraphLayer","visibleLeaves","capacities","rootObject","leaf","decodeBlosc","decodeZstd","decodeChunk","mode","numDimensions","chunkKvStore","NiftiFileData","decodeNiftiFile","isCompressed","readHeader","getNiftiHeaderInfo","DATA_TYPE_CONVERSIONS","GET_NIFTI_VOLUME_INFO_RPC_ID","affine","dataTypeInfo","spatialInvScale","spatialUnit","NIFTI1","timeUnit","timeInvScale","sourceScales","viewScales","sourceNames","viewNames","quatern_b","quatern_c","quatern_d","quatern_a","qfac","qoffset","method2Transform","matrix","copyRank","NiftiVolumeChunkSource","sharedKvStoreContextCounterpart","imageBuffer","readImage","parseOBJFromArrayBuffer","SingleMeshChunk","transferSet","singleMeshFactories","protocolPattern","getCombinedMesh","getMesh","getDataSource","factories","dataSource","SingleMeshSource","SingleMeshSourceParametersWithInfo","SINGLE_MESH_CHUNK_KEY","SingleMeshLayerBase","SingleMeshLayer","parse","GET_SINGLE_MESH_INFO_RPC_ID","mesh","TileChunkSource","TileChunkSourceParameters","query_params","URLSearchParams","imageMethod","xTileSize","yTileSize","parseVTKFromArrayBuffer","codecRegistry","CodecKind","registerCodec","codec","decodeArray","codecs","encoded","bytesToBytes","impl","arrayToArray","configuration","decodedArrayInfo","compressionFormat","getCodecResolver","parseNameAndConfiguration","parseName","parseConfiguration","parseCodecChainSpec","arrayInfo","layoutInfo","encodedSize","codecSpecs","numCodecs","initialConfiguration","encodedArrayInfo","arrayResolver","arrayToBytes","finalLayoutInfo","initialEncodedSize","shardingInfo","arrayToBytesResolver","codecSpec","newEncodedSize","bytesResolver","UNITS","siPrefix","longPrefix","unitInfo","subChunkShape","indexLocation","subChunkGridShape","outerSize","innerSize","indexShape","indexCodecs","subChunkCodecs","MISSING_VALUE","physicalToLogicalIndexDimension","indexStrides","physicalIndexDim","logicalIndexDim","shardIndex","subChunk","pos","dataLength","fullByteRange","ZarrVolumeChunkSource","applySharding","baseKvStore","curCodecs","decodeCodecs","pathPrefix","getChunkKey","baseKey","physicalToLogicalDimension","readChunkShape","fOrderPhysicalDim","subChunkDim","sep","metadata","ChunkKeyEncoding","keyCoords","decodedDim","proxyList","LIST_RPC_ID","STAT_RPC_ID","READ_RPC_ID","arrayBuffer","COMPLETE_URL_RPC_ID","finalComponent","parsedUrl","provider","adapterUrl","HttpKvStore","registerProviders","ALPHABET","crockfordBase32Encode","output","bits","MAGIC","ENVELOPE_HEADER_SIZE","decodeEnvelope","maxVersion","fileType","specVersion","storedFileType","compressionMethod","content","decodeMsgpack","Unpackr","DataId","DataId12","DataId8","MIN_SAFE_INTEGER_BIGINT","MAX_SAFE_INTEGER_BIGINT","bigIntToSafeNumber","Integer","tupleToObject","parseDecodedMsgpack","schema","InlineChunkPayload","Chunksum","VirtualChunkRef","VirtualChunkRefPayload","ChunkRef","ChunkRefPayload","ChunkPayload","Manifest","decodeManifest","isSnapshotId","ManifestFileInfo","AttributeFileInfo","UserAttributesSnapshot","Configuration","Codec","FillValue","StorageTransformer","DimensionNames","ZarrArrayMetadata","ChunkIndices","ManifestRef","NodeDataGroup","NodeDataArray","NodeData","NodeSnapshot","Nodes","Snapshot","map","decodeSnapshot","makeMetadataCache","decode","getRef","decodeRef","resolveIcechunkPath","snapshot","nodePath","zarrJsonMatch","chunkMatch","findNode","nodes","resolveChunkPayload","manifests","chunkKey","nodeId","manifestRef","manifestExtentsContain","getManifest","chunkPayload","resolvedPath","readFromChunkPayload","ref","encodeZarrJson","userAttributes","nodeData","encodeArrayZarrJson","chunkKeyEncoding","fillValue","storageTransformers","dimensionNames","_key","TextEncoder","BRANCH_PREFIX","TAG_PREFIX","isValidBranchName","parseRefSpec","branch","tag","IcechunkKvStore","refSpec","snapshotId","resolveRefSpec","_span","headKey","listResponse","tagResponse","deletedResponse","getIcechunkUrl","getListResponseFromSnapshot","startIndex","endIndex","directoryPrefix","lastSlash","parentPath","parentNodeIndex","completeIcechunkUrl","_sharedKvStoreContext","refCompletionsPromise","snapshotCompletionsPromise","rest","refsPath","snapshotsPath","parseIcechunkUrl","refSpecString","expectedMagic","magic","checksum","actualChecksum","crc32cbuf","readBytes","reader","readLeb128","decodeLeb128","shift","byte","readLeb128Bigint","decodeLeb128Bigint","readLeb128Bounded","maxValue","readUint8","readUint64le","readArrayOf","readElement","toArrayOfStructs","arrays","structs","readStructOfArrays","members","validate","EMPTY_KEY","compareArraysLexicographically","minLength","findFirstMismatch","concatKeys","keyStartsWith","readDataFileId","dataFileTable","readIndirectDataReferences","locationIsMissing","location","readDataFileTable","transitiveBaseUrl","numFiles","pathLengthBuffer","dataFileIds","prevBasePath","prevRelativePathEncoded","textDecoder","basePathLength","pathLength","relativePathLength","baseSuffixLength","basePrefixLength","relativePathEncoded","decodeBtreeNode","numEntries","readBtreeLeafNodeEntries","commonPrefix","readKeys","readLeafNodeValueReferences","lengths","valueKinds","valueKind","dataFile","readBtreeInteriorNodeEntries","subtreeCommonPrefixLengths","readBtreeNodeReferences","interiorNode","keyLengthBuffer","commonPrefixLength","prevLength","keyLength","subtreeCommonPrefixLength","prevKey","readBtreeNodeStatistics","validateBtreeNodeReference","inclusiveMinKey","keyPrefix","findBtreeEntryPrefixUpperBound","difference","readVersionTreeLeafNode","versionTreeArityLog2","readVersionTreeLeafNodeEntries","validateVersionTreeLeafNodeEntries","maxNumEntries","lastGenerationNumber","firstGenerationNumber","minGenerationNumber","getMinVersionTreeNodeGenerationNumber","readVersionTreeArityLog2","decodeVersionTreeNode","readVersionTreeInteriorNode","maxHeight","getMaxVersionTreeHeight","readVersionTreeInteriorNodeEntries","validateVersionTreeInteriorNodeEntries","childGenerationNumberStride","maxArity","lastEntry","readVersionTreeNodeInteriorNodeEntriesWithKnownCount","computeCumulativeNumGenerations","versionNodes","compareVersionSpecToVersion","versionSpec","findLeafVersionIndexByLowerBound","generationIndex","versions","findVersionNodeIndexByGenerationIndex","findVersionNodeIndexByLowerBound","findVersionNodeIndexByCommitTimeLowerBound","findVersionNodeIndexByUpperBound","validateVersionTreeNodeReference","config","numGenerations","actualNumGenerations","decodeConfig","zstdLevel","uuid","manifestKind","maxInlineValueBytes","maxDecodedNodeBytes","readInt32le","versionTree","decodeManifestVersionTree","inlineVersions","versionTreeNodes","readManifestVersionTreeNodes","validateManifestVersionTreeNodes","maxGenerationNumber","getPossibleManifestVersionTreeNodeReferences","nextGenerationNumber","ensureEof","getResolvedManifest","fullUrl","makeIndirectDataReferenceCache","getBtreeNode","getVersionTreeNode","listRoot","listSubtree","nodeReference","subtreeKeyPrefix","addDirectoryIfValid","separatorIndex","prefixForCurrentNode","findBtreeInteriorEntryPrefixRange","promises","entryIndex","findBtreeLeafEntryPrefixRange","findEntryInRoot","findEntryInSubtree","nodeHeight","queryKey","findBtreeLeafEntry","findBtreeInteriorEntry","readFromLeafNodeEntry","getRoot","readVersion","findVersion","findVersionIndexByLowerBound","findVersionLowerBoundImpl","findVersionIndexByUpperBound","findVersionUpperBoundImpl","findVersionImpl","isInline","findInLeaf","findInInterior","findInSubtree","query","isVersionQueryInline","_config","findLeafVersion","findLeafVersionByGenerationNumber","findLeafVersionByCommitTime","findVersionNodeByGenerationNumber","findVersionNodeByCommitTime","OcdbtKvStore","getOcdbtUrl","encodedPrefix","listVersions","minGenerationIndex","inclusiveMin","exclusiveMax","resolvedInclusiveMin","resolvedExclusiveMax","visitLeafEntries","resultGenerationIndex","visitInteriorEntries","visitNodeRef","listVersionsLimited","maxGenerationIndex","lowerVersions","upperVersions","completeOcdbtUrl","inclusiveMax","minVersion","completions","parseOcdbtUrl","S3KvStore","ReadableS3KvStore","findEndOfCentralDirectory","totalLength","EOCDR_WITHOUT_COMMENT_SIZE","record","parseEndOfCentralDirectoryRecord","commentLength","diskNumber","entryCount","centralDirectorySize","centralDirectoryOffset","eocdrOffset","commentBytes","readZip64CentralDirectory","readEntries","eocdl","eocdlDv","zip64EocdrOffset","zip64Eocdr","zip64EocdrDv","rawEntryCount","readEntryCursor","allEntriesBuffer","rawEntries","signature","versionMadeBy","versionNeededToExtract","generalPurposeBitFlag","lastModFileTime","lastModFileDate","crc32","compressedSize","uncompressedSize","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","externalFileAttributes","relativeOffsetOfLocalHeader","nameBytes","extraFields","headerId","dataStart","dataEnd","zip64ExtraField","zip64EiefBufferOffset","zip64EiefBufferLength","nameField","crc32buf","expectedCompressedSize","rawEntry","readEntryDataHeader","readZipMetadata","lastReadBuffer","lastReadOffset","newBuffer","makeZipReader","getZipMetadata","getZipMetadataCache","memoizeKey","_unusedCacheKey","filterArrayInplace","findEntry","ZipKvStore","fileDataStart","list","listEntries","waitUntilReady","globalThis"],"mappings":"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"}